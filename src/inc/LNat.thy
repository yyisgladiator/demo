section \<open>The Datatype of Lazy Natural Numbers\<close> 

theory LNat
imports Prelude
begin

(* ----------------------------------------------------------------------- *)
section \<open>Type definition and the basics\<close>
(* ----------------------------------------------------------------------- *)

text \<open>
  Defined using the 'domain' command. Generates a bottom element (\<open>\<bottom>\<close>) and an order (\<open>\<sqsubseteq>\<close>),
  which are used to define zero and \<open>\<le>\<close>.
\<close>
domain lnat = lnsuc (lazy lnpred::lnat)

instantiation lnat :: "{ord, zero}"
begin
  definition lnzero_def: "(0::lnat) \<equiv> \<bottom>"
  definition lnless_def: "(m::lnat) < n \<equiv> m \<sqsubseteq> n \<and> m \<noteq> n"
  definition lnle_def:   "(m::lnat) \<le> n \<equiv> m \<sqsubseteq> n"
instance ..
end

text \<open>define @{term lntake} as an abbreviation for @{term lnat_take},
  which is generated by the \<open>domain\<close> command\<close>
abbreviation
  lntake :: "nat \<Rightarrow> lnat \<rightarrow> lnat"
    where "lntake \<equiv> lnat_take"

text \<open>eliminate double successors in @{term lntake} arguments\<close>
lemma lntake_more[simp]:
  "lntake (Suc n)\<cdot>(lnsuc\<cdot>k) = lnsuc\<cdot>(lntake n\<cdot>k)"
by (induct_tac n, auto)

(* ----------------------------------------------------------------------- *)
section \<open>Definitions\<close> 
(* ----------------------------------------------------------------------- *)
text \<open>\<open>\<infinity>\<close> is the maximum of all @{term lnat}s\<close>
definition Inf'  ::  "lnat"   ("\<infinity>") where
"Inf' \<equiv> fix\<cdot>lnsuc"

text \<open>A natural number @{term n} is represented by @{term "Fin n"}\<close>
definition Fin   ::  "nat \<Rightarrow> lnat" where
"Fin k \<equiv> lntake k\<cdot>\<infinity>" 

text \<open>Determine the minimum of the given two @{term lnat}s\<close>
definition lnmin ::  "lnat \<rightarrow> lnat \<rightarrow> lnat" where
"lnmin \<equiv> fix\<cdot>(\<Lambda> h. strictify\<cdot>(\<Lambda> m. strictify\<cdot>(\<Lambda> n. 
                     lnsuc\<cdot>(h\<cdot>(lnpred\<cdot>m)\<cdot>(lnpred\<cdot>n)))))"

abbreviation lnatGreater :: "lnat \<Rightarrow> lnat \<Rightarrow> bool" (infix ">\<^sup>l" 65) where
"n >\<^sup>l m \<equiv>  n \<ge> lnsuc\<cdot>m"

abbreviation lnatLess :: "lnat \<Rightarrow> lnat \<Rightarrow> bool" (infix "<\<^sup>l" 65) where
"n <\<^sup>l m \<equiv>  lnsuc\<cdot>n \<le> m"

instantiation lnat :: plus
begin  
  definition plus_lnat:: "lnat \<Rightarrow> lnat \<Rightarrow> lnat"  where 
    "plus_lnat ln1 ln2 \<equiv> if (ln1 = \<infinity> \<or> ln2=\<infinity>) then \<infinity> else Fin ((inv Fin) ln1 + (inv Fin) ln2)"

  (*definition lnat_plus2:: "lnat \<rightarrow> lnat \<rightarrow> lnat" where
    "lnat_plus2 \<equiv> \<Lambda> ln1 ln2. (if (ln1 = \<infinity> \<or> ln2=\<infinity>) then \<infinity> else Fin ((inv Fin) ln1 + (inv Fin) ln2))"
    
  definition lnat_plus_moreIdiotic :: "lnat \<rightarrow> lnat \<rightarrow> lnat" where
    "lnat_plus_moreIdiotic = fix\<cdot>(\<Lambda> h. (\<Lambda> m. ( \<Lambda> n. 
                           if m = 0 then n else h\<cdot>(lnpred\<cdot>m)\<cdot>(lnsuc\<cdot>n))))"*)   
instance 
  by(intro_classes)
end
      
(* ----------------------------------------------------------------------- *)
section \<open>Some basic lemmas\<close>
(* ----------------------------------------------------------------------- *)

(* ----------------------------------------------------------------------- *)
subsection 
  \<open>Brief characterization of 
     \<open>Fin\<close>, \<open>\<infinity>\<close>, \<open>\<le>\<close> and \<open><\<close>
\<close>
(* ----------------------------------------------------------------------- *)

text \<open>x is smaller then lnsuc x.\<close>
lemma less_lnsuc[simp]: "x \<le> lnsuc\<cdot>x"
apply (subst lnle_def)
by (rule lnat.induct [of _ x], auto)

text \<open>\<open>\<infinity>\<close> is a fix point of @{term lnsuc}\<close>
lemma fold_inf[simp]: "lnsuc\<cdot>\<infinity> = \<infinity>"
by (unfold Inf'_def, subst fix_eq2 [THEN sym], simp+)

text \<open>x is smaller then \<infinity>.\<close>
lemma inf_ub[simp]: "x \<le> \<infinity>"
apply (subst lnle_def)
apply (rule lnat.induct [of _ x], auto)
apply (subst fold_inf [THEN sym])
by (rule monofun_cfun_arg)

text \<open>0 is the bottom element.\<close>
lemma Fin_02bot: "Fin 0 = \<bottom>"
by (simp add: Fin_def)

text \<open>\<open>\<le>\<close> on lnats is antisymmetric\<close>
lemma lnat_po_eq_conv:
  "(x \<le> y \<and> y \<le> x) = ((x::lnat) = y)"
apply (auto simp add: lnle_def)
by (rule po_eq_conv [THEN iffD2], simp)

text \<open>lnsuc of x is not equal 0.\<close>
lemma lnsuc_neq_0[simp]: "lnsuc\<cdot>x \<noteq> 0"
by (simp add: lnzero_def)

text \<open>Similar to the lemma above.\<close>
lemma lnsuc_neq_0_rev[simp]: "0 \<noteq> lnsuc\<cdot>x"
by (simp add: lnzero_def)

text \<open>0 is not equal \<infinity>.\<close>
lemma Inf'_neq_0[simp]: "0 \<noteq> \<infinity>"
apply (subst fold_inf [THEN sym])
by (rule notI, simp del: fold_inf)

text \<open>Similar to the lemma above.\<close>
lemma Inf'_neq_0_rev[simp]: "\<infinity> \<noteq> 0"
by (rule notI, drule sym, simp)

text \<open>Successors are equal, so are the numbers themselves.\<close>
lemma inject_lnsuc[simp]: "(lnsuc\<cdot>x = lnsuc\<cdot>y) = (x = y)"
by (rule lnat.injects)

text \<open>Take lemma.\<close>
lemma [simp]: "lntake (Suc k)\<cdot>\<infinity> = lnsuc\<cdot>(lntake k\<cdot>\<infinity>)"
apply (subst fold_inf [THEN sym])
by (simp only: lntake_more)

text \<open>A property of lnsuc.\<close>
lemma Fin_Suc[simp]: "lnsuc\<cdot>(Fin k) = Fin (Suc k)"
by (simp add: Fin_def)

text \<open>A property of 0.\<close>
lemma Fin_0[simp]: "(Fin k = 0) = (k = 0)"
apply (induct_tac k, auto simp add: lnzero_def)
by (simp add: Fin_def)+

text \<open>Injectivity of Fin.\<close>
lemma inject_Fin[simp]: "(Fin n = Fin k) = (n = k)"
apply (rule spec [of _ k], induct_tac n, auto)
by (case_tac x, auto simp add: Fin_def)+

text \<open>If a lnat cannot be reached by @{term "lnat_take"}, it behaves like \<open>\<infinity>\<close>\<close>
lemma nreach_lnat_lemma: 
  "\<forall>x. (\<forall>j. lnat_take j\<cdot>x \<noteq> x) \<longrightarrow> lnat_take k\<cdot>x = lnat_take k\<cdot>\<infinity>"
apply (induct_tac k, auto)
apply (rule_tac y=x in lnat.exhaust, auto simp add: lnzero_def)
apply (erule_tac x="lnat" in allE, auto)
by (erule_tac x="Suc j" in allE, auto)

text \<open>If a lnat cannot be reached by @{term "lnat_take"}, it
  is \<open>\<infinity>\<close>.\<close>
lemma nreach_lnat:
  "(\<forall>j. lntake j\<cdot>x \<noteq> x) \<Longrightarrow> x = \<infinity>"
apply (rule lnat.take_lemma)
by (rule nreach_lnat_lemma [rule_format],simp)

text \<open>Every finite lnat can be reached by @{term lntake}\<close>
lemma nreach_lnat_rev:
  "x \<noteq> \<infinity> \<Longrightarrow> \<exists>n. lntake n\<cdot>x = x"
apply (rule ccontr, auto)
by (drule nreach_lnat, simp)

text \<open>If a lnat is reachable by @{term lntake}, it is finite\<close>
lemma exFin_take:
  "\<forall>x. lntake j\<cdot>x = x \<longrightarrow> (\<exists>k. x = Fin k)"
apply (induct_tac j, auto)
apply (rule_tac x="0" in exI,simp add: Fin_def)
apply (rule_tac y=x in lnat.exhaust, auto)
by (rule_tac x="0" in exI, simp add: Fin_def)

text \<open>If a predicate holds for both finite lnats and for \<open>\<infinity>\<close>,
  it holds for every lnat\<close>
lemma lncases:
  "\<And>x P. \<lbrakk>x = \<infinity> \<Longrightarrow> P; \<And>k. x = Fin k \<Longrightarrow> P\<rbrakk> \<Longrightarrow> P"
apply (case_tac "x = \<infinity>", auto)
apply (drule nreach_lnat_rev, auto)
by (drule exFin_take [rule_format],auto)

text \<open>Only \<open>\<infinity>\<close> is greater or equal to \<open>\<infinity>\<close>\<close>
lemma inf_less_eq[simp]: "(\<infinity> \<le> x) = (x = \<infinity>)"
apply (auto, rule lnat_po_eq_conv [THEN iffD1])
by (rule conjI, auto)

text \<open>Bottom is 0.\<close>
lemma bot_is_0: "(\<bottom>::lnat) = 0"
by (simp add: lnzero_def)

text \<open>Fin k \<le> 0 holds only for k = 0.\<close>
lemma lnle_Fin_0[simp]: "(Fin k \<le> 0) = (k = 0)"
apply (simp add: lnzero_def lnle_def)
by (subst bot_is_0, simp)

text \<open>\<open>\<le>\<close> on lnats is antisymmetric\<close>
lemma less2eq: "\<lbrakk>x \<le> y; y \<le> x\<rbrakk> \<Longrightarrow> (x :: lnat) = y"
by (rule lnat_po_eq_conv [THEN iffD1], simp)

text \<open>If a number is smaller than @{term i}, its predecessor is
  also smaller than @{term i}\<close>
lemma Fin_leq_Suc_leq: "Fin (Suc n) \<le> i \<Longrightarrow> Fin n \<le> i"
apply (simp add: lnle_def)
apply (rule below_trans, auto)
apply (simp only: Fin_def)
apply (rule monofun_cfun_fun)
by (rule chainE,simp)

text \<open>\<open>\<le>\<close> on lnats and on nats\<close>
lemma less2nat_lemma: "\<forall>k. (Fin n \<le> Fin k) \<longrightarrow> (n \<le> k)"
apply (induct_tac n, auto)
apply (case_tac "n=k", simp)
apply (subgoal_tac "Fin k \<le> Fin (Suc k)")
apply (drule less2eq, auto)
apply (subst lnle_def)
apply (rule chainE)
apply (simp add: Fin_def)
apply (erule_tac x="k" in allE,auto)
by (drule Fin_leq_Suc_leq, simp)

text \<open>If Fin n \<le> Fin k then n \<le> k.\<close>
lemma less2nat[simp]: "(Fin n \<le> Fin k) = (n \<le> k)"
apply (rule iffI)
apply (rule less2nat_lemma [rule_format], assumption)
apply (simp add: lnle_def)
apply (rule chain_mono)
by (simp add: Fin_def,auto)

text \<open>lnsuc x is \<infinity> iff x is \<infinity>.\<close>
lemma [simp]: "(lnsuc\<cdot>x = \<infinity>) = (x = \<infinity>)"
apply (rule iffI) 
by (rule lnat.injects [THEN iffD1], simp+)

text \<open>A finite number is not \<infinity>.\<close>
lemma Fin_neq_inf[simp]: "Fin k \<noteq> \<infinity>"
apply (induct_tac k, auto)
apply (simp add: Fin_def bot_is_0)
by (simp add: Fin_Suc [THEN sym] del: Fin_Suc)

text \<open>If lnsuc x \<le> lnsuc y then x \<le> y.\<close>
lemma lnsuc_lnle_emb[simp]:  "(lnsuc\<cdot>x \<le> lnsuc\<cdot>y) = (x \<le> y)"
apply (rule_tac x=x in lncases, simp)
by (rule_tac x=y in lncases, auto)

text \<open>0 is the smallest element.\<close>
lemma [simp]: "0 \<le> (x::lnat)"
by (simp add: lnzero_def lnle_def)

text \<open>If n \<le> 0 then n = 0.\<close>
lemma [simp]: "((n::lnat) \<le> 0) = (n = 0)"
by (rule iffI, rule_tac x=n in lncases, auto)

text \<open>If x \<sqsubseteq> y then x \<le> y.\<close>
lemma lnle_conv[simp]: "((x::lnat) \<sqsubseteq> y) = (x \<le> y)"
by (subst lnle_def,simp)

text \<open>transitivity of \<open>\<le>\<close>\<close>
lemma trans_lnle:
  "\<lbrakk>x \<le> y; y \<le> z\<rbrakk> \<Longrightarrow> (x::lnat) \<le> z"
by (subst lnle_def, rule_tac y = y in below_trans, simp+)

text \<open>reflexivity of \<open>\<le>\<close>\<close>
lemma refl_lnle[simp]: "(x::lnat) \<le> x"
by (subst lnle_def,rule below_refl)

text \<open>0 < \<infinity>.\<close>
lemma Zero_lnless_infty[simp]: "0 < \<infinity>"
by (auto simp add: lnless_def)

text \<open>Except for 0, every lnat has a predecessor\<close>
lemma gr_0[simp]: "(0 < j) = (\<exists>k. j = lnsuc\<cdot>k)"
apply (auto simp add: lnless_def)
apply (rule_tac y=j in lnat.exhaust)
by (simp add: lnzero_def, auto)

(*---*)
section \<open>Some basic lemmas on \<open><\<close>\<close>
(*---*)

text \<open>0 < lnsuc\<cdot>k\<close>
lemma [simp]: "0 < lnsuc\<cdot>k"
by (auto simp add: lnless_def)

text \<open>0 < Fin (Suc k)\<close>
lemma [simp]: "0 < Fin (Suc k)"
by (simp add: Fin_Suc [THEN sym] del: Fin_Suc)

text \<open>Fin k < \<infinity>\<close>
lemma [simp]: "Fin k < \<infinity>"
by (auto simp add: lnless_def)

text \<open>If Fin k < Fin n then k < n.\<close> 
lemma [simp]: "(Fin k < Fin n) = (k < n)"
by (auto simp add: lnless_def)

lemma trans_lnless:
  "\<lbrakk>x < y; y < z\<rbrakk> \<Longrightarrow> (x::lnat) < z"
apply (auto simp add: lnless_def)
apply (rule trans_lnle, auto)
by (simp add: lnat_po_eq_conv [THEN iffD1])

text \<open>If lnsuc\<cdot>n < lnsuc\<cdot>k then n < k\<close>
lemma [simp]: "(lnsuc\<cdot>n < lnsuc\<cdot>k) = (n < k)"
by (auto simp add: lnless_def)

text \<open>lnsuc k is not smaller then 0.\<close>
lemma [simp]: "\<not> lnsuc\<cdot>k < 0"
by (simp add: lnless_def)

text \<open>\<infinity> is not smaller then anything.\<close>
lemma [simp]: "\<not> \<infinity> < i"
by (auto simp add: lnless_def)

(*---*)
section \<open>Relationship between Fin and \<open>\<infinity>\<close>\<close>
(*---*)


text \<open>Every non-infinite number is finite\<close>
lemma ninf2Fin: "x \<noteq> \<infinity> \<Longrightarrow> \<exists>k. x = Fin k"
by (rule_tac x=x in lncases, auto)

lemma assumes "ln = lnsuc\<cdot>ln"
  shows "ln = \<infinity>"
using assms ninf2Fin by force

text \<open>Every non-finite number is infinite\<close>
lemma infI: "\<forall>k. x \<noteq> Fin k \<Longrightarrow> x = \<infinity>"
by (rule lncases [of x], auto)

text \<open>Every number below @{term "Fin k"} is finite\<close>
lemma below_fin_imp_ninf: "x \<sqsubseteq> Fin k \<Longrightarrow> x \<noteq> \<infinity>"
by (rule lncases [of "x"], simp_all)

text \<open>\<open>\<infinity>\<close> is not finite\<close>
lemma [simp]: "\<infinity> \<noteq> Fin k"
by (rule notI, drule sym, simp)

text \<open>\<open>\<infinity>\<close> is strictly greater than all finite lnats\<close>
lemma [simp]: "\<not> (\<infinity> \<le> Fin k)"
by (rule notI, auto)

text \<open>An unbounded number is infinite\<close>
lemma inf_belowI: "\<forall>k. Fin k \<sqsubseteq> x \<Longrightarrow> x = \<infinity>"
proof (rule lncases [of x], simp)
  fix k assume "x = Fin k" and "\<forall>k. Fin k \<sqsubseteq> x"
  hence "Fin (Suc k) \<sqsubseteq> Fin k" by simp
  thus ?thesis by simp
qed

(* ----------------------------------------------------------------------- *)
subsection \<open>Induction rules\<close>
(* ----------------------------------------------------------------------- *)

text \<open>admissibile predicates on lnats can be proved inductively\<close>
lemma lnat_ind: "\<And>P x. \<lbrakk>adm P; P 0; \<And>l. P l \<Longrightarrow> P (lnsuc\<cdot>l)\<rbrakk> \<Longrightarrow> P x"
apply (rule lnat.induct, simp)
by (simp add: lnzero_def, auto)

(* ----------------------------------------------------------------------- *)
subsection \<open>Basic lemmas on @{term lmin}\<close>
(* ----------------------------------------------------------------------- *)

text \<open>lnmin\<cdot>0\<cdot>n = 0\<close>
lemma strict_lnmin_fst[simp]: "lnmin\<cdot>0\<cdot>n = 0"
apply (subst lnmin_def [THEN fix_eq2])    
by (simp add: lnzero_def)

text \<open>lnmin\<cdot>m\<cdot>0 = 0\<close>
lemma strict_lnmin_snd[simp]: "lnmin\<cdot>m\<cdot>0 = 0"
apply (subst lnmin_def [THEN fix_eq2], auto)
apply (rule lnat.induct [of _ m], simp)
by (simp add: lnzero_def)+

text \<open>Relationship between lnmin and lnsuc.\<close>
lemma lnmin_lnsuc[simp]: "lnmin\<cdot>(lnsuc\<cdot>m)\<cdot>(lnsuc\<cdot>n) = lnsuc\<cdot>(lnmin\<cdot>m\<cdot>n)"
by (subst lnmin_def [THEN fix_eq2], simp)

text \<open>lnmin\<cdot>\<infinity>\<cdot>n = n\<close>
lemma lnmin_fst_inf[simp]: "lnmin\<cdot>\<infinity>\<cdot>n = n"
apply (rule lnat_ind [of _ n], auto)
apply (subst fold_inf [THEN sym])
by (simp del: fold_inf)

text \<open>lnmin\<cdot>m\<cdot>\<infinity> = m\<close>
lemma lnmin_snd_inf[simp]: "lnmin\<cdot>m\<cdot>\<infinity> = m"
apply (rule lnat_ind [of _ m], auto)
apply (subst fold_inf [THEN sym])
by (simp del: fold_inf)

text \<open>Fin 0 = 0\<close>
lemma [simp]: "Fin 0 = 0"
by simp

text \<open>lnmin\<cdot>(Fin j)\<cdot>(Fin k) = Fin (min j k)"\<close>
lemma lnmin_fin[simp]: "lnmin\<cdot>(Fin j)\<cdot>(Fin k) = Fin (min j k)"
apply (rule_tac x=k in spec)
apply (induct_tac j, auto)
apply (case_tac x, auto)
by (simp add: Fin_def lnzero_def)

lemma lub_mono2: "\<lbrakk>chain (X::nat\<Rightarrow>lnat); chain (Y::nat\<Rightarrow>lnat); \<And>i. X i \<le> Y i\<rbrakk>
    \<Longrightarrow> (\<Squnion>i. X i) \<le> (\<Squnion>i. Y i)"
using lnle_conv lub_mono by blast

text \<open>In an infinite chain, one can find for every element a bigger element
  in the chain\<close>
lemma inf_chainl2:
  "\<lbrakk>chain Y; \<not> finite_chain Y\<rbrakk> \<Longrightarrow> \<exists>j. Y k \<sqsubseteq> Y j \<and> Y k \<noteq> Y j"
apply (auto simp add: finite_chain_def max_in_chain_def)
apply (erule_tac x="k" in allE, auto)
apply (frule_tac i=k and j=j in chain_mono, assumption)
by (rule_tac x="j" in exI, simp)

text \<open>For constant chains, the first element is the maximum\<close>
lemma max_in_chainI2: "\<lbrakk>chain Y; \<forall>i. Y i = k\<rbrakk> \<Longrightarrow> max_in_chain 0 Y"
by (rule max_in_chainI, simp)

text \<open>In an infinite chain, there is no maximum\<close>
lemma finite_chainl1: "\<lbrakk>chain Y; \<not> finite_chain Y\<rbrakk> \<Longrightarrow> \<not> max_in_chain k Y"
apply (rule notI)
by (simp add: finite_chain_def)

text \<open>In an inifinite lnat chain, one can find for every lnat a bigger element
  in the chain\<close>
lemma inf_chainl3:
  "\<lbrakk>chain Y; \<not> finite_chain Y\<rbrakk> \<Longrightarrow> \<exists>j. (Fin k) \<sqsubseteq> Y j \<and> Fin k \<noteq> Y j"
apply (induct_tac k, simp+)
apply (case_tac "\<forall>i. Y i = \<bottom>")
apply (frule_tac k="\<bottom>" in max_in_chainI2, assumption)
apply (drule_tac k="0" in finite_chainl1, assumption, clarify)
apply (simp, erule exE)
apply (rule_tac x="i" in exI)
apply (simp add: lnzero_def)
apply (erule exE, erule conjE)
apply (frule_tac k="j" in finite_chainl1, assumption)
apply (simp add: max_in_chain_def)
apply (erule exE, erule conjE)
apply (rule_tac x="ja" in exI)
apply (rule_tac x="Y j" in lncases, simp+)
apply (drule_tac i="j" and j="ja" in chain_mono, assumption, simp+)
apply (rule_tac x="Y ja" in lncases, simp+)
by (drule_tac i="j" and j="ja" in chain_mono, assumption, simp+)

text \<open>The least upper bound of an infinite lnat chain is \<open>\<infinity>\<close>\<close>
lemma unique_inf_lub: "\<lbrakk>chain Y; \<not> finite_chain Y\<rbrakk> \<Longrightarrow> Lub Y = \<infinity>"
apply (rule ccontr, drule ninf2Fin, erule exE)
apply (frule_tac k="k" in inf_chainl3, assumption)
apply (erule exE, simp)
apply (erule conjE)
apply (drule_tac x="j" in is_ub_thelub, simp)
by (rule_tac x="Y j" in lncases, simp+)

text \<open>Every finite lnat is compact\<close>
lemma compact_Fin: "compact (Fin k)"
apply (rule compactI)
apply (rule admI)
apply (case_tac "finite_chain Y")
apply (simp add: finite_chain_def)
apply (erule exE)
apply (drule lub_finch1 [THEN lub_eqI], simp, simp)
apply (frule unique_inf_lub, assumption)
apply (subgoal_tac "range Y <| Fin k")
apply (drule_tac x="Fin k" in is_lub_thelub, simp+)
apply (rule ub_rangeI, simp)
apply (erule_tac x="i" in allE)
by (rule_tac x="Y i" in lncases, simp+)

text \<open>If the outputs of a continuous function for finite inputs are
  bounded, the output for \<open>\<infinity>\<close> has the same bound\<close>
lemma lnat_adml1[simp]: "adm (\<lambda>x. f\<cdot>x \<le> Fin n)"
apply (subst lnle_def)
apply (rule admI)
apply (subst contlub_cfun_arg, assumption)
apply (rule is_lub_thelub, rule chain_monofun, assumption)
by (rule ub_rangeI, simp)

text \<open>If a continuous function returns \<open>\<infinity>\<close> for all finite
  inputs, it also returns \<open>\<infinity>\<close> for input \<open>\<infinity>\<close>\<close>
lemma lnat_adnl2[simp]: "adm (\<lambda>x. f\<cdot>x = \<infinity>)"
apply (rule admI)
apply (subst contlub_cfun_arg, assumption)
apply (rule po_eq_conv [THEN iffD2])
apply (rule conjI)
apply (rule is_lub_thelub, rule chain_monofun, assumption)
apply (rule ub_rangeI, simp)
apply (erule_tac x="SOME x. True" in allE)
apply (drule sym, erule ssubst)
by (rule is_ub_thelub, rule chain_monofun)

text \<open>l \<le> Fin k \<Longrightarrow> l \<noteq> \<infinity>\<close>
lemma notinfI3: "l \<le> Fin k \<Longrightarrow> l \<noteq> \<infinity>"
by (rule_tac x="l" in lncases, simp+)

text \<open>Lifting to discrete cpo\<close>

definition lnsucu ::"lnat u \<rightarrow> lnat u" where
"lnsucu \<equiv> strictify\<cdot>(\<Lambda> n. up\<cdot>(fup\<cdot>lnsuc\<cdot>n))"


definition upinf  ::"lnat u" (* ("\<infinity>\<^isub>u") *) where
"upinf \<equiv> up\<cdot>\<infinity>"

text \<open>lnsucu\<cdot>\<bottom> = \<bottom>\<close>
lemma [simp]: "lnsucu\<cdot>\<bottom> = \<bottom>"
by (simp add: lnsucu_def)

text \<open>lnsucu\<cdot>(up\<cdot>(Fin n)) = up\<cdot>(Fin (Suc n))\<close>
lemma [simp]: "lnsucu\<cdot>(up\<cdot>(Fin n)) = up\<cdot>(Fin (Suc n))"
by (simp add: lnsucu_def)

text \<open>lnsucu\<cdot>(upinf) = upinf\<close>
lemma [simp]: "lnsucu\<cdot>(upinf) = upinf"
by (simp add: lnsucu_def upinf_def)

text \<open>We prove the cases lemma for the lifted lnat u\<close>
lemma lnatu_cases:
  "\<And>n P. \<lbrakk>n = upinf \<Longrightarrow> P; \<And>k. n = up\<cdot>(Fin k) \<Longrightarrow> P; n = \<bottom> \<Longrightarrow> P\<rbrakk> \<Longrightarrow> P"
apply (erule upE, auto simp add: upinf_def)
by (rule_tac x="x" in lncases, auto)

text \<open>up\<cdot>(Fin k) \<noteq> upinf\<close>
lemma [simp]: "up\<cdot>(Fin k) \<noteq> upinf"
by (simp add: upinf_def)

text \<open>up\<cdot>(Fin k) \<noteq> \<bottom>\<close>
lemma [simp]: "up\<cdot>(Fin k) \<noteq> \<bottom>"
by simp

text \<open>upinf \<noteq> \<bottom>\<close>
lemma [simp]: "upinf \<noteq> \<bottom>"
by (simp add: upinf_def)

text \<open>lnsucu\<cdot>lu \<noteq> up\<cdot>0\<close>
lemma [simp]: "lnsucu\<cdot>lu \<noteq> up\<cdot>0"
apply (rule_tac n="lu" in lnatu_cases)
apply (auto simp add: upinf_def)
by (simp add: lnsucu_def)

text \<open>(lnsucu\<cdot>l = up\<cdot>(Fin (Suc n))) = (l = up\<cdot>(Fin n))\<close>
lemma [simp]: "(lnsucu\<cdot>l = up\<cdot>(Fin (Suc n))) = (l = up\<cdot>(Fin n))"
apply (rule_tac n="l" in lnatu_cases)
apply (simp add: upinf_def)
by (auto simp add: lnsucu_def)

text \<open>(lnsuc\<cdot>n = Fin (Suc k)) = (n = Fin k)\<close>
lemma [simp]: "(lnsuc\<cdot>n = Fin (Suc k)) = (n = Fin k)"
by (simp add: Fin_Suc [THEN sym] del: Fin_Suc)

text \<open>(lnsuc\<cdot>n \<le> Fin (Suc k)) = (n \<le> Fin k)\<close>
lemma [simp]: "(lnsuc\<cdot>n \<le> Fin (Suc k)) = (n \<le> Fin k)"
by (simp add: Fin_Suc [THEN sym] del: Fin_Suc)

text \<open>(lnsuc\<cdot>n < Fin (Suc k)) = (n < Fin k)\<close>
lemma [simp]: "(lnsuc\<cdot>n < Fin (Suc k)) = (n < Fin k)"
by (simp add: Fin_Suc [THEN sym] del: Fin_Suc)

text \<open>(Fin (Suc n) \<le> lnsuc\<cdot>l) = (Fin n \<le> l)\<close>
lemma [simp]: "(Fin (Suc n) \<le> lnsuc\<cdot>l) = (Fin n \<le> l)"
by (simp add: Fin_Suc [THEN sym] del: Fin_Suc)

text \<open>(Fin (Suc n) < lnsuc\<cdot>l) = (Fin n < l)\<close>
lemma [simp]: "(Fin (Suc n) < lnsuc\<cdot>l) = (Fin n < l)"
by (simp add: Fin_Suc [THEN sym] del: Fin_Suc)

text \<open>\<not> Fin (Suc n) < 0\<close>
lemma [simp]: "\<not> Fin (Suc n) < 0"
by (simp add: Fin_Suc [THEN sym] del: Fin_Suc)

text \<open>\<not> Fin (Suc n) \<le> 0\<close>
lemma [simp]: "\<not> Fin (Suc n) \<le> 0"
by (simp add: Fin_Suc [THEN sym] del: Fin_Suc)

text \<open>\<exists>x. Fin x < 0 \<Longrightarrow> False\<close>
lemma [simp]: "\<exists>x. Fin x < 0 \<Longrightarrow> False"
by (simp add: lnless_def)

text \<open>l \<noteq> 0 \<Longrightarrow> Fin (Suc 0) \<le> l\<close>
lemma neq02Suclnle: "l \<noteq> 0 \<Longrightarrow> Fin (Suc 0) \<le> l"
by (rule_tac x="l" in lncases, simp+)

text \<open>(Fin k) < y \<Longrightarrow> Fin (Suc k) \<le> y\<close>
lemma less2lnleD: "(Fin k) < y \<Longrightarrow> Fin (Suc k) \<le> y"
by (rule_tac x="y" in lncases, simp+)

(* ----------------------------------------------------------------------- *)
subsection \<open>Basic lemmas on @{term lmin}\<close>
(* ----------------------------------------------------------------------- *)

text\<open>Instanciate lnat as a linorder to use min/max\<close>
instantiation lnat :: linorder
begin
  instance
  apply(intro_classes)
  using lnat_po_eq_conv lnle_def lnless_def apply blast
  apply simp
  using trans_lnle apply blast
  using lnat_po_eq_conv apply blast
  by (metis inf_ub less2nat linear ninf2Fin)
end

text\<open>A lazy natural number is smaller than its successor\<close>
lemma ln_less[simp]: assumes "ln<\<infinity>"
  shows "ln < lnsuc\<cdot>ln"
proof -
  have "ln \<le> lnsuc\<cdot>ln" by simp
  obtain n where "Fin n = ln" by (metis assms dual_order.strict_implies_not_eq infI)
  have "Fin n < Fin (Suc n)" by force
  thus ?thesis using \<open>Fin n = ln\<close> by auto 
qed

lemma lnle2le: "m < lnsuc\<cdot>n \<Longrightarrow> m \<le> n"
  apply (case_tac "m=\<infinity>", auto)
  by (metis Fin_Suc less2lnleD lncases lnsuc_lnle_emb)

lemma le2lnle: "m < \<infinity> \<Longrightarrow> lnsuc\<cdot>m \<le> n \<Longrightarrow> m < n"
  by (metis dual_order.strict_iff_order dual_order.trans leD ln_less)

(*few lemmas to simp min*)
text\<open>\<infinity> is greater than or equal to any lazy natural number\<close>
lemma [simp]: fixes ln :: lnat
  shows "min \<infinity> ln = ln"
by (simp add: min_def)

lemma [simp]: fixes ln :: lnat
  shows "min ln \<infinity> = ln"
by (simp add: min_def)

text\<open>0 is less than or equal to any lazy natural number\<close> 
lemma [simp]: fixes ln :: lnat
  shows "min ln 0 = 0"
by (simp add: min_def)

lemma [simp]: fixes ln :: lnat
  shows "min 0 ln = 0"
by (simp add: min_def)

lemma min_rek: assumes  "z = min x (lnsuc\<cdot>z)"
  shows "z = x"
  apply(rule ccontr, cases "x < z")
   apply (metis assms dual_order.irrefl min_less_iff_conj)
  by (metis assms inf_ub ln_less lnle_def lnless_def min_def)
    
lemma lnat_well_h1:
  "[| n < Fin m; \<And>k. n = Fin k ==> k < m ==> P |] ==> P"
by (metis less2nat less_le lncases notinfI3)

lemma lnat_well_h2:
  "[| n < \<infinity>; \<And>k. n = Fin k ==> P |] ==> P"
using lncases by auto 

lemma lnat_well:
  assumes prem: "\<And>n. \<forall>m::lnat. m < n --> P m ==> P n" shows "P n"
proof -
  have P_lnat: "\<And>k. P (Fin k)"
    apply (rule nat_less_induct)
    apply (rule prem, clarify)
    apply (erule lnat_well_h1, simp)
    done
  show ?thesis
  proof (induct n)
    next show "adm P" by (metis P_lnat adm_upward inf_ub lnat_well_h2 less_le_trans prem)
    next show "P \<bottom>" by (metis Fin_02bot P_lnat)
    then show "\<And>n. P n \<Longrightarrow> P (lnsuc\<cdot>n)" by (metis Fin_Suc P_lnat lncases)
  qed
qed

instance lnat :: wellorder
proof
  fix P and n
  assume hyp: "(\<And>n::lnat. (\<And>m::lnat. m < n ==> P m) ==> P n)"
  show "P n" by (blast intro: lnat_well hyp)
qed


(* ----------------------------------------------------------------------- *)
subsection \<open>Basic lemmas on @{term lnat_plus}\<close>
(* ----------------------------------------------------------------------- *) 

text \<open>Plus on nats behaves the same as on lnats.\<close>  
lemma lnat_plus_fin [simp]: "(Fin n) + (Fin m) = Fin (n + m)"
  apply(simp add: plus_lnat_def)
  by (metis UNIV_I f_inv_into_f image_eqI inject_Fin)

text \<open>0 + 0 = 0.\<close>    
lemma plus_lnat0_0:"Fin 0 + Fin 0 = Fin 0"
  apply(simp add: plus_lnat_def)
  apply(simp add: Fin_def inv_def)
  apply(rule_tac someI_ex)
  using Fin_def lnle_Fin_0 by auto

text \<open>0 is a right neutral element of + on lnats.\<close>    
lemma plus_lnat0_r[simp]:"(0::lnat) + n = n"
  apply(simp add: plus_lnat_def)
  by (metis Fin_0 Inf'_neq_0_rev add_cancel_right_left plus_lnat_def lnat_plus_fin ninf2Fin)

text \<open>0 is a left neutral element of + on lnats.\<close>       
lemma plus_lnat0_l:"m + (0::lnat) = m"
  apply(simp add: plus_lnat_def)
  by (metis (mono_tags, lifting) Fin_0 UNIV_I add.right_neutral f_inv_into_f image_eqI plus_lnat_def plus_lnat0_r)

text \<open>m + \<infinity> = \<infinity>.\<close>       
lemma plus_lnatInf_l[simp]:"m + \<infinity> = \<infinity>"
  by(simp add: plus_lnat_def)  

text \<open>\<infinity> + n = \<infinity>.\<close>    
lemma plus_lnatInf_r:"\<infinity> + n = \<infinity>"
  by(simp add: plus_lnat_def)  

text \<open>+ on lnats is commutative.\<close>    
lemma lnat_plus_commu:"(ln1::lnat) + ln2 = ln2 + ln1"
  by(simp add: plus_lnat_def)

text \<open>+ is associative.\<close>    
instance lnat:: semigroup_add
  apply(intro_classes)
  apply(simp add: plus_lnat_def)
  by (smt add.left_commute f_inv_into_f inject_Fin natl2 rangeI)

text\<open>+ is commutative.\<close>
instance lnat:: ab_semigroup_add
  apply(intro_classes)
  by (simp add: lnat_plus_commu)

text\<open>+ is zero neutral.\<close>    
instance lnat:: monoid_add
  apply(intro_classes)
  apply (simp)
  by (simp add: plus_lnat0_l)

text\<open>Define a 1 element in lnat.\<close>    
instantiation lnat :: one
begin
definition one_lnat:: "lnat" where 
  "one_lnat = Fin 1"
  
  instance ..
end 

text\<open>This 1 element is the successor of 0.\<close>  
lemma one_def: "1 = lnsuc\<cdot>0"
   by (metis Fin_02bot Fin_Suc One_nat_def lnzero_def one_lnat_def)

lemma lnat_1_inf [simp]: "1 < \<infinity>"
  unfolding one_lnat_def
  by simp

text\<open>Adding 1 to an lnat ln1 yields the same result as the successor of ln1.\<close>     
lemma lnat_plus_suc: "ln1 + 1 = lnsuc\<cdot>ln1"
  apply(simp add: plus_lnat_def)
  by (metis Fin_Suc Inf'_neq_0_rev One_nat_def Suc_def2 f_inv_into_f fold_inf inf_ub inject_Fin inject_lnsuc less_le lnat_well_h2 one_def one_lnat_def rangeI)

text\<open>Applying lnsuc to the first or second element of the addition yields the same result.\<close>    
lemma lnat_plus_lnsuc: "ln1 + (lnsuc\<cdot>ln2) = (lnsuc\<cdot>ln1) + ln2"
  apply(simp add: plus_lnat_def)
  proof -
    have f1: "\<And>f n. f (inv f (f (n::nat)::lnat)) = f n"
      by (simp add: f_inv_into_f)
    have "\<And>l. Fin (inv Fin l) = l \<or> \<infinity> = l"
      by (metis (no_types) f_inv_into_f ninf2Fin rangeI)
    then have f2: "\<And>l. inv Fin (lnsuc\<cdot>l) = Suc (inv Fin l) \<or> \<infinity> = l"
      using f1 by (metis (no_types) Fin_Suc inject_Fin)
    then have "\<And>n l. n + inv Fin (lnsuc\<cdot>l) = inv Fin l + Suc n \<or> \<infinity> = l"
      by simp
    then show "ln1 \<noteq> \<infinity> \<and> ln2 \<noteq> \<infinity> \<longrightarrow> inv Fin ln1 + inv Fin (lnsuc\<cdot>ln2) = inv Fin (lnsuc\<cdot>ln1) + inv Fin ln2"
      using f2 by (metis (no_types) natl2)
  qed
  

lemma min_adm[simp]: fixes y::lnat
  shows "adm (\<lambda>x. min y (g\<cdot>x) \<sqsubseteq> h\<cdot>x)"
proof (rule admI)
  fix Y
  assume Y_ch: "chain Y"  and as: "\<forall>i. min y (g\<cdot>(Y i)) \<sqsubseteq> h\<cdot>(Y i)"
  have h1:"finite_chain Y \<Longrightarrow> min y (g\<cdot>(\<Squnion>i. Y i)) \<sqsubseteq> h\<cdot>(\<Squnion>i. Y i)"
    using Y_ch as l42 by force
  have "\<not>finite_chain Y \<Longrightarrow> min y (g\<cdot>(\<Squnion>i. Y i)) \<sqsubseteq> h\<cdot>(\<Squnion>i. Y i)"
  proof (cases "g\<cdot>(\<Squnion>i. Y i) \<sqsubseteq> y")
    case True
    hence "\<And>i. g\<cdot>(Y i) \<sqsubseteq> y"
      using Y_ch is_ub_thelub monofun_cfun_arg rev_below_trans by blast
    then show ?thesis
      by (metis (no_types, lifting) Y_ch as ch2ch_Rep_cfunR contlub_cfun_arg lnle_conv lub_below_iff lub_mono min_absorb2)
  next
    case False
    then show ?thesis
      by (metis Y_ch as below_lub ch2ch_Rep_cfunR contlub_cfun_arg lnle_conv lub_below min.commute min_def)
  qed
  thus "min y (g\<cdot>(\<Squnion>i. Y i)) \<sqsubseteq> h\<cdot>(\<Squnion>i. Y i)"
    using h1 by blast 
qed

lemma min_adm2[simp]: fixes y::lnat
  shows "adm (\<lambda>x. min (g\<cdot>x) y \<sqsubseteq> h\<cdot>x)"
  apply(subst min.commute)
  using min_adm by blast
    
lemma lub_sml_eq:"\<lbrakk>chain (Y::nat\<Rightarrow>lnat); \<And>i. x \<le> Y i\<rbrakk> \<Longrightarrow> x \<le> (\<Squnion>i. Y i)"
  using l42 unique_inf_lub by force

text\<open>The lub of a chain in minimum is the minimum of the lub.\<close>
lemma min_lub:" chain Y \<Longrightarrow> (\<Squnion>i::nat. min (x::lnat) (Y i)) = min (x) (\<Squnion>i::nat. (Y i))"
  apply (case_tac "x=\<infinity>", simp_all)
  apply (case_tac "finite_chain Y")
proof -
  assume a1: "chain Y"
  assume a2: "finite_chain Y"
  then have "monofun (min x)"
    by (metis (mono_tags, lifting) lnle_conv min.idem min.semilattice_order_axioms monofunI
        semilattice_order.mono semilattice_order.orderI)
  then show ?thesis
    using a2 a1 by (metis (no_types) finite_chain_lub)
next
  assume a0:"chain Y"
  assume a1:"\<not> finite_chain Y"
  assume a2:"x \<noteq> \<infinity>"
  have h0:"\<forall>i. \<exists>j\<ge>i. Y i \<sqsubseteq> Y j"
  by blast  
  then have"(\<Squnion>i. min x (Y i)) = x"
  proof -
    have f1: "\<And>n. min x (Y n) \<sqsubseteq> x"
      by (metis (lifting) lnle_def min.bounded_iff order_refl)
    then have f2: "\<And>n. min x (Y n) = x \<or> Y n \<sqsubseteq> x"
      by (metis (lifting) min_def)
    have f3: "\<infinity> \<notsqsubseteq> x"
      by (metis (lifting) a2 inf_less_eq lnle_def) 
    have "Lub Y = \<infinity>"
      by (meson a0 a1 unique_inf_lub)
    then obtain nn :: "(nat \<Rightarrow> lnat) \<Rightarrow> lnat \<Rightarrow> nat" where
      f4: "min x (Y (nn Y x)) = x \<or> \<infinity> \<sqsubseteq> x"
      using f2 by (metis (no_types) a0 lub_below_iff)
    have "\<forall>f n. \<exists>na. (f (na::nat)::lnat) \<notsqsubseteq> f n \<or> Lub f = f n"
      by (metis lub_chain_maxelem)
    then show ?thesis
      using f4 f3 f1 by (metis (full_types))
    qed
  then show ?thesis
    by (simp add: a0 a1 unique_inf_lub)
qed

text\<open>Reversed Version of min_lub: The minimum of the lub is the lub of a chain in a minimum.\<close>  
lemma min_lub_rev:"chain Y \<Longrightarrow>  min (x) (\<Squnion>i::nat. (Y i)) = (\<Squnion>i::nat. min (x::lnat) (Y i)) "
  using min_lub by auto

text\<open>\<le> relation between two chains in a minimum is as well preserved by their lubs.\<close>
lemma lub_min_mono: "\<lbrakk>chain (X::nat\<Rightarrow>lnat); chain (Y::nat\<Rightarrow>lnat); \<And>i. min x (X i) \<le> Y i\<rbrakk>
    \<Longrightarrow> min x (\<Squnion>i. X i) \<le> (\<Squnion>i. Y i)"
  by (metis dual_order.trans is_ub_thelub lnle_def lub_mono2 min_le_iff_disj)

text\<open>Twisted version of lub_min_mono: \<le> rel. between two chains in minimum is preserved by lubs.\<close>
lemma lub_min_mono2: "\<lbrakk>chain (X::nat\<Rightarrow>lnat); chain (Y::nat\<Rightarrow>lnat); \<And>i. min (X i) y \<le> Y i\<rbrakk>
    \<Longrightarrow> min (\<Squnion>i. X i) y \<le> (\<Squnion>i. Y i)"
  by (metis dual_order.trans is_ub_thelub lnle_def lub_mono2 min_le_iff_disj)


lemma lessequal_addition: assumes "a \<le> b" and "c \<le> d" shows "a + c \<le> b + (d :: lnat)"
proof -
  have "b = \<infinity> \<Longrightarrow> a + c \<le> b + d"
    by (simp add: plus_lnatInf_r)
  moreover
  have "d = \<infinity> \<Longrightarrow> a + c \<le> b + d"
    by (simp add: plus_lnatInf_r)
  moreover
  have "a = \<infinity> \<Longrightarrow> a + c \<le> b + d"
    using assms(1) plus_lnatInf_r by auto
  moreover
  have "c = \<infinity> \<Longrightarrow> a + c \<le> b + d"
    using assms(2) plus_lnatInf_r by auto
  moreover
  have "a \<noteq> \<infinity> \<Longrightarrow> b \<noteq> \<infinity> \<Longrightarrow> c \<noteq> \<infinity> \<Longrightarrow> d \<noteq> \<infinity> \<Longrightarrow> a + c \<le> b + d"
  proof -
    assume "a \<noteq> \<infinity>"
    then obtain m where m_def: "Fin m = a"
      using infI by force
    assume "b \<noteq> \<infinity>"
    then obtain n where n_def: "Fin n = b"
      using infI by force
    assume "c \<noteq> \<infinity>"
    then obtain x where x_def: "Fin x = c"
      using infI by force
    assume "d \<noteq> \<infinity>"
    then obtain y where y_def: "Fin y = d"
      using infI by force
    show ?thesis
      using assms m_def n_def x_def y_def by auto
    qed
  then show "a + c \<le> b + d"
    using calculation by blast
qed

lemma lnmin_eqasmthmin: assumes "a = b" and "a \<le> c" shows "a = lnmin\<cdot>b\<cdot>c"
proof -
  have "a = \<infinity> \<Longrightarrow> a = lnmin\<cdot>b\<cdot>c"
    using assms by auto
  moreover
  have "b = \<infinity> \<Longrightarrow> a = lnmin\<cdot>b\<cdot>c"
    using assms by auto
  moreover
  have "c = \<infinity> \<Longrightarrow> a = lnmin\<cdot>b\<cdot>c"
    using assms by auto
  moreover
  have "a \<noteq> \<infinity> \<Longrightarrow> b \<noteq> \<infinity> \<Longrightarrow> c \<noteq> \<infinity> \<Longrightarrow>  a = lnmin\<cdot>b\<cdot>c"
    by (metis assms less2nat lncases lnmin_fin min.order_iff)

  then show ?thesis
    using calculation by blast
qed

lemma lnmin_asso: "lnmin\<cdot>x\<cdot>y = lnmin\<cdot>y\<cdot>x"
proof -
  have "x = \<infinity> \<Longrightarrow> lnmin\<cdot>x\<cdot>y = lnmin\<cdot>y\<cdot>x"
    by simp
  moreover
  have "y = \<infinity> \<Longrightarrow> lnmin\<cdot>x\<cdot>y = lnmin\<cdot>y\<cdot>x"
    by simp
  moreover
  have "x \<noteq> \<infinity> \<Longrightarrow> y \<noteq> \<infinity> \<Longrightarrow> lnmin\<cdot>x\<cdot>y = lnmin\<cdot>y\<cdot>x"
    by (metis (full_types) lncases lnmin_fin min.commute)
  then show ?thesis
    using calculation by blast
qed

lemma lnmin_smaller_addition: "lnmin\<cdot>x\<cdot>y \<le> x + y"
proof -
  have "x = \<infinity> \<Longrightarrow> lnmin\<cdot>x\<cdot>y \<le> x + y"
    by (simp add: plus_lnatInf_r)
  moreover
  have "y = \<infinity> \<Longrightarrow> lnmin\<cdot>x\<cdot>y \<le> x + y"
    by simp
  moreover
  have "x \<noteq> \<infinity> \<Longrightarrow> y \<noteq> \<infinity> \<Longrightarrow> lnmin\<cdot>x\<cdot>y \<le> x + y"
    by (metis bot_is_0 lessequal_addition linear lnle_def lnmin_asso lnmin_eqasmthmin minimal plus_lnat0_l)
  then show ?thesis
    using calculation by blast
qed

lemma lnat_no_chain: fixes Y:: " nat \<Rightarrow> lnat" 
  assumes "range Y = UNIV"
  shows "\<not>chain Y"
proof (rule ccontr)
  assume "\<not>\<not>chain Y"
  obtain i where "Y i = \<infinity>"
    by (metis assms surj_def)
  hence "max_in_chain i Y"
    by (metis \<open>\<not>\<not>chain Y\<close> inf_less_eq is_ub_thelub lnle_conv max_in_chainI3)
  hence "finite (range Y)"
    using Prelude.finite_chainI \<open>\<not> \<not> chain Y\<close> finch_imp_finite_range by blast
  thus False
    by (metis (mono_tags, hide_lams) Fin_neq_inf assms ex_new_if_finite  finite_imageI infinite_UNIV_nat inject_Fin lncases rangeI)
qed

text \<open>If the left summand is smaller then {@term \<infinity>}, then the right summand is unqiuely
        determined by the result of {@term +}\<close>
lemma plus_unique_r:
  fixes "l"
  assumes "m < \<infinity>"
  and "(l::lnat) = m + n"
  and "(l::lnat) = m + p"
shows "n = p"
  using assms apply(induction l, simp_all)
  apply (smt add_left_imp_eq fold_inf inject_Fin less_lnsuc lnat.sel_rews(2) lnat_plus_suc neq_iff notinfI3 plus_lnat_def triv_admI)
  using assms apply(induction m, simp_all)
  apply (simp_all add: bot_is_0)
  apply (smt add.left_commute lnat_plus_commu plus_lnat0_l triv_admI)
  apply (metis add.left_commute plus_lnat0_l)
  apply (case_tac "l = \<infinity>")
  apply simp_all
proof -
  fix la :: lnat
  assume a1: "m + n \<noteq> \<infinity>"
  assume a2: "m + p = m + n"
  have f3: "n = 0 + n"
  by auto
  have f4: "\<forall>l la. if l = \<infinity> \<or> la = \<infinity> then l + la = \<infinity> else l + la = Fin (inv Fin l + inv Fin la)"
  using plus_lnat_def by presburger
    have f5: "0 \<noteq> \<infinity> \<and> n \<noteq> \<infinity>"
      using a1 by force
    have f6: "m \<noteq> \<infinity> \<and> p \<noteq> \<infinity>"
      using f4 a2 a1 by metis
    then have f7: "Fin (inv Fin m + inv Fin p) = m + n"
      using f4 a2 by simp
    have "m \<noteq> \<infinity> \<and> n \<noteq> \<infinity>"
      using f4 a1 by fastforce
    then have "inv Fin p = inv Fin n"
      using f7 f4 by simp
    then have "n = 0 + p"
      using f6 f5 f4 f3 by presburger
    then show ?thesis
  by auto
qed

text \<open>If the right summand is smaller then {@term \<infinity>}, then the left summand is unqiuely
        determined by the result of {@term +}\<close>
lemma plus_unique_l:
  fixes "l"
  assumes "m < \<infinity>"
  and "(l::lnat) = n + m"
  and "(l::lnat) = p + m"
shows "n = p"
  using assms plus_unique_r
  by (metis lnat_plus_commu) 

text\<open>Declares Fin and {@term \<infinity>} as constructors for lnat. This is useful for patterns that use constructors\<close>
setup \<open>Sign.mandatory_path "SBv3"\<close>
old_rep_datatype Fin Inf'
  apply (metis ninf2Fin)
  by simp+

end