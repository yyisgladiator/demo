theory Medium
(* Non-Deterministic Medium for the Alternating-Bit-Spezification. 
    The Non-Determinisic-Automaton should be autogenerated from MAA, currently it is written by hand *)


(* Ich habe versucht von dem Nachrichten-Datentypen (und am liebsten Channels) zu abstrahieren... 
hat nicht so wirklich geklappt, nicht verwirren wenn da "'m" steht *)

imports NDA "../../timesyn/tsynBundle"

begin


(* This are the actual states from MAA *)
datatype MediumSubstate = TheOne (* Das MAA-Modell hat nur diesen einen State *)

(* And these have also the variables *)
datatype MediumState = State MediumSubstate nat

fun getSubState :: "MediumState \<Rightarrow> MediumSubstate" where
"getSubState (State automaton_s automaton_sum) = automaton_s"

fun getCounter :: "MediumState \<Rightarrow> nat" where
"getCounter (State automaton_s automaton_counter) = automaton_counter"


(* Zum Testen... die funktion setzt den Channel *)
definition makeOutput :: "'m::message \<Rightarrow> 'm event SB" where
"makeOutput = undefined"


fun abpMediumTransition:: "((MediumState \<times> 'm::message event) \<Rightarrow> ((MediumState \<times> 'm event SB) set rev))" where

  (* Deterministic, never delete Ticks, don't count down for them *)
"abpMediumTransition (state, Tick)= Rev {(state, tsynbOneTick c2)}" | 

  (* Deterministic, delete Message and count down *)
"abpMediumTransition (State TheOne (Suc n), (Msg m))= Rev {(State TheOne n, tsynbOneTick c2)}" |

  (* NON-Deterministic. Countdown is at 0, let a message through and set the countdown to a random value *)
"abpMediumTransition (State TheOne 0, (Msg m))= Rev {(State TheOne n, makeOutput m) | n . True}"




fun abpMediumTransitionFinal:: "((MediumState \<times>(channel \<rightharpoonup> 'm::message)) \<Rightarrow> ((MediumState \<times> 'm SB) set rev))" where
"abpMediumTransitionFinal a = undefined" (*Call abpMediumTransition like discussed in issue #100 *)

(*   "{f::(('state \<times>(channel \<rightharpoonup> 'm)) \<Rightarrow> (('state \<times> 'm SB) set rev)) \<times> ('state \<times> 'm SB) set rev \<times> channel set discr \<times> channel set discr. True}" *)
lift_definition abpMedium:: "(MediumState, 'm::message) NDA"  is
    (* Normal transitionsFunktion, minimal andere signatur *)
  "(abpMediumTransitionFinal, 

    (* Interessanter part. Die Startzustands/Ausgabe menge. 
      Am Anfang wird der countdown auf einen zufalls wert gesetzt und ein Tick ausgegeben*)
  Rev {((State TheOne n), tsynbOneTick c2)| n. True} , 

  (* Input/Output channel set. Der Prefix 'Discr' muss sein *)
  Discr {c1}, Discr {c2})"
  sorry (* Fehler liegt an dem parametrisierten datentypen 'm *)

end