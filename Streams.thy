section {* Lazy Streams *} 

theory Streams
imports LNat SetPcpo
begin

section {* The Datatype of Lazy Streams *}

default_sort countable

(* declare [[show_types]] *)

text {* @{text "discr u"} lifts an arbitrary type @{text "'a"} to the
  discrete @{text "pcpo"} and the usual rest operator @{text "rt"} on streams.*}

domain
  'a stream = lscons (lshd::"'a discr u") (lazy srt::"'a stream") 
                                        (infixr "&&" 65)

(* ----------------------------------------------------------------------- *)
section {* Signatures of Stream Processing Functions*}
(* ----------------------------------------------------------------------- *)

text {* Continuous function from stream to stream and shortcut 
for input and output of the same type: *}
type_synonym ('in, 'out) spf = "('in stream \<rightarrow> 'out stream)"
type_synonym 'm spfo      = "('m, 'm) spf"

text {* Same for general SPFs which are not continuous by definition: *}
type_synonym ('in, 'out) gspf = "('in stream \<Rightarrow> 'out stream)"
type_synonym 'm gspfo      = "('m, 'm) gspf"

text {* Again for list processing functions: *}
type_synonym ('in, 'out) lpf = "('in list \<Rightarrow> 'out list)"
type_synonym 'm lpfo      = "('m, 'm) lpf"


(* ----------------------------------------------------------------------- *)
subsection {* Some abbreviations *}
(* ----------------------------------------------------------------------- *)

text {* The empty stream is denoted as @{text "\<epsilon>"}.*}
abbreviation
  sbot ::  "'a stream"  ("\<epsilon>")
    where "sbot \<equiv> \<bottom>"

text {* The @{term "updis"} command lifts an arbitrary type to a
  discrete pointed partial order. *}
abbreviation
  updis :: "'a \<Rightarrow> 'a discr u"
    where "updis \<equiv> (\<lambda>a. up\<cdot>(Discr a))" 

text {* @{term stake}: This operator is generated by the @{text "domain"}
  command. It retrieves the first @{text "n"} elements of a stream
  (or less, if the stream is shorter). *}
abbreviation
  stake :: "nat \<Rightarrow> 'a spfo"
    where "stake \<equiv> stream_take"

(* ----------------------------------------------------------------------- *)
section {* Common functions on streams *}
(* ----------------------------------------------------------------------- *)

text {* Conversion of function with lifted values to a partial function: *}
definition fup2map :: "('a \<Rightarrow> 'b::cpo u) \<Rightarrow> ('a \<rightharpoonup> 'b)" where
"fup2map f a \<equiv> if (f a = \<bottom>) then None else Some (SOME x. up\<cdot>x = f a)" 

text {* @{term sup'}: Construct a stream by a single element. *}
definition sup'       :: "'a \<Rightarrow> 'a stream" ("\<up>_" [1000] 999) where
"sup' a \<equiv> updis a && \<epsilon>"


text {* @{term sconc}: Concatenate two streams over the same type.
  For infinite streams, arbitrary other streams can be appended
  without changing the stream. *}
definition sconc      :: "'a stream \<Rightarrow> 'a spfo" where
"sconc \<equiv> fix\<cdot>(\<Lambda> h. (\<lambda> s1. \<Lambda> s2. 
                      if s1 = \<epsilon> then s2 else  (lshd\<cdot>s1) && (h (srt\<cdot>s1)\<cdot>s2)))"

abbreviation sconc_abbr :: "'a stream \<Rightarrow> 'a stream \<Rightarrow> 'a stream" ("(_ \<bullet> _)" [66,65] 65)
where "s1 \<bullet> s2 \<equiv> sconc s1\<cdot>s2"

text {* @{term shd}: Retrieve the first element of a stream.
  For @{text "\<epsilon>"}, the result is not defined. *}
definition shd        :: "'a stream \<Rightarrow> 'a" where
"shd s \<equiv> THE a. lshd\<cdot>s = updis a"

text {* @{term slookahd}: Apply function to head of stream.
  If the stream is empty, @{text \<bottom>} is returned.
  This function is especially useful for defining own stream-processing
  functions. *}
definition slookahd   :: "'a stream \<rightarrow> ('a \<Rightarrow> 'b) \<rightarrow> ('b::pcpo)" where
"slookahd \<equiv> \<Lambda> s f. if s = \<epsilon> then \<bottom> else f (shd s)"  




(* ----------------------------------------------------------------------- *)
subsection {* Conversion of lists to streams and induced order on lists *}
(* ----------------------------------------------------------------------- *)

text {* Lists can be converted to streams by the function @{term list2s}: *}

primrec list2s :: "'a list \<Rightarrow> 'a stream"
where
  list2s_0:   "list2s [] = \<epsilon>" |
  list2s_Suc: "list2s (a#as) = updis a && (list2s as)"

abbreviation stream_abbrev :: "'a list \<Rightarrow> 'a stream" ("<_>" [1000] 999)
where "<l> == list2s l"

text {* The data type @{text "list"} is a partial order with the operator 
  @{text "\<sqsubseteq>"} derived from streams: *}
instantiation list :: (countable) po
begin

  definition sq_le_list:
    "s \<sqsubseteq> t \<equiv> (list2s s \<sqsubseteq> list2s t)"

  (* list2s is a bijection *)
  lemma list2s_inj[simp]: "(list2s l = list2s l') = (l = l')"
  apply (rule iffI)
  apply (simp add: atomize_imp)
  apply (rule_tac x="l'" in spec)
  apply (induct l, simp)
  apply (rule allI)
  apply (induct_tac x, simp+)
  apply (rule allI)
  by (induct_tac x, simp+)

instance
apply (intro_classes)
apply (simp add: sq_le_list)+
apply (rule_tac y="list2s y" in below_trans,assumption+)
apply (simp add: sq_le_list)
apply (rule list2s_inj [THEN iffD1])
by (rule po_eq_conv [THEN iffD2],rule conjI,assumption+)

end

(* ----------------------------------------------------------------------- *)
text {* Typical functions known from lists:*}
(* ----------------------------------------------------------------------- *)


text {* @{term slen}: Retrieve the length of a stream.
  It is defined as the number of its elements or @{text "\<infinity>"} for inifinite streams. *}
definition slen       :: "'a stream \<rightarrow> lnat" where
"slen \<equiv> fix\<cdot>(\<Lambda> h. strictify\<cdot>(\<Lambda> s. lnsuc\<cdot>(h\<cdot>(srt\<cdot>s))))"

abbreviation slen_abbr :: "'a stream \<Rightarrow> lnat" ("#_" [1000] 999)
where "#s == slen\<cdot>s"

text {* @{term sdrop}: Remove the first @{text "n"} elements
  of the stream. *}
definition sdrop      :: "nat \<Rightarrow> 'a spfo" where
"sdrop n \<equiv> Fix.iterate n\<cdot>srt"

text {* @{term snth}: Get the @{text "n"}th element of the stream. *}
definition snth       :: "nat \<Rightarrow> 'a stream \<Rightarrow> 'a" where
"snth k s \<equiv> shd (sdrop k\<cdot>s)" 

text {* @{term sdom}: Retrieve the set of all values in a stream. *}
definition sdom       :: "'a stream \<rightarrow> 'a set" where
"sdom \<equiv> \<Lambda> s. {z. \<exists>n. Fin n < #s \<and> z = snth n s}" 

text {* @{term sntimes}: Repeat the given stream @{text "n"} times. *}
text {* (Only listed as a constant below for reference;
  Use @{text "sntimes"} with same signature instead). *}
(* consts sntimes_    :: "nat \<Rightarrow> 'a stream \<Rightarrow> 'a stream" *)

text {* @{term sinftimes}: Concatenate a stream infinitely often to itself. *}
definition sinftimes  :: "'a stream \<Rightarrow> 'a stream" ("_\<infinity>") where
 "sinftimes \<equiv> fix\<cdot>(\<Lambda> h. (\<lambda>s. 
                        if s = \<epsilon> then \<epsilon> else (s \<bullet> (h s))))" 

text {* @{term smap}: Apply a function to all elements of the stream. *}
definition smap       :: "('a \<Rightarrow> 'b) \<Rightarrow> ('a,'b) spf" where
"smap f \<equiv> fix\<cdot>(\<Lambda> h s. slookahd\<cdot>s\<cdot>(\<lambda> a. 
                       \<up>(f a) \<bullet> (h\<cdot>(srt\<cdot>s))))"

text {* @{term sfilter}: Remove all elements from the stream which are
  not included in the given set. *}
definition sfilter    :: "'a set \<Rightarrow> 'a spfo" where
"sfilter M \<equiv> fix\<cdot>(\<Lambda> h s. slookahd\<cdot>s\<cdot>(\<lambda> a. 
                          (if (a \<in> M) then \<up>a \<bullet> (h\<cdot>(srt\<cdot>s)) else h\<cdot>(srt\<cdot>s))))"

text {* @{term stakewhile}: Take the first elements of a stream as
  long as the given function evaluates to @{text "true"}. *}
definition stakewhile :: "('a \<Rightarrow> bool) \<Rightarrow> 'a spfo" where
"stakewhile f \<equiv> fix\<cdot>(\<Lambda> h s. slookahd\<cdot>s\<cdot>(\<lambda> a. if (f a) then \<up>a \<bullet> h\<cdot>(srt\<cdot>s) else \<epsilon>))"

text {* @{term sdropwhile}: Drop the first elements of a stream as
  long as the given function evaluates to @{text "true"}. *}
definition sdropwhile :: "('a \<Rightarrow> bool) \<Rightarrow> 'a spfo" where
"sdropwhile f \<equiv> fix\<cdot>(\<Lambda> h s. slookahd\<cdot>s\<cdot>(\<lambda> a. 
                          if (f a) then h\<cdot>(srt\<cdot>s) else s))"

text {* Two streams can be combined into one stream by using tuples as elements. *}

text {* @{term szip}: Zip two streams into one stream. *}
definition szip       :: "'a stream \<rightarrow> 'b stream \<rightarrow> ('a \<times> 'b) stream" where
 "szip \<equiv> fix\<cdot>(\<Lambda> h s1 s2. slookahd\<cdot>s1\<cdot>(\<lambda> a. slookahd\<cdot>s2\<cdot>(\<lambda> b.
                     \<up>(a,b) \<bullet> (h\<cdot>(srt\<cdot>s1)\<cdot>(srt\<cdot>s2)))))"

text {* @{term sprojfst}: Access the first stream of two zipped streams. *}
definition sprojfst   :: "(('a \<times> 'b),'a) spf" where
"sprojfst \<equiv> \<Lambda> x. smap fst\<cdot>x"

text {* @{term sprojsnd}: Access the second stream of two zipped streams. *}
definition sprojsnd   :: "(('a \<times> 'b),'b) spf" where
"sprojsnd \<equiv> \<Lambda> x. smap snd\<cdot>x"

text {* The following two functions are "delayed" variants
  of @{term stakewhile} and @{term sdropwhile}. *}

text {* @{term stwbl}: Take while predicate holds but also keep
  first element violating condition. *}
definition stwbl      :: "('a \<Rightarrow> bool) \<Rightarrow> 'a spfo" where
"stwbl f \<equiv> fix\<cdot>(\<Lambda> h s. slookahd\<cdot>s\<cdot>(\<lambda> a. 
                          if (f a) then \<up>a \<bullet>  h\<cdot>(srt\<cdot>s) else \<up>a))"

text {* @{term srtdw}: Rest (@{text srt}) of stream after dropwhile. *}
definition srtdw      :: "('a \<Rightarrow> bool) \<Rightarrow> 'a spfo" where
"srtdw f \<equiv> \<Lambda> x. srt\<cdot>(sdropwhile f\<cdot>x)"

text {* @{term srcdups}: Remove successive duplicate values from stream. *}
definition srcdups    :: "'a spfo" where
"srcdups \<equiv> fix\<cdot>(\<Lambda> h s. slookahd\<cdot>s\<cdot>(\<lambda> a. 
                        \<up>a \<bullet>  h\<cdot>(sdropwhile (\<lambda> z. z = a)\<cdot>(srt\<cdot>s))))"

(* Takes a nat indicating the number of elements to scan, a reducing function, an initial initial element,
   and an input stream. Returns a stream consisting of the partial reductions of the input stream. *)
primrec SSCANL :: "nat \<Rightarrow> ('o \<Rightarrow> 'i \<Rightarrow> 'o) \<Rightarrow> 'o \<Rightarrow> 'i stream \<Rightarrow> 'o stream" where
  SSCANL_zero_def: "SSCANL 0 f q s = \<epsilon>" |
  "SSCANL (Suc n) f q s = (if s=\<epsilon> then \<epsilon> 
                           else \<up>(f q (shd s)) \<bullet> ( SSCANL n f (f q (shd s)) (srt\<cdot>s) )     )"


text {* @{term sscanl}: Apply a function elementwise to the input stream.
  Behaves like @{text "map"}, but also takes the previously generated
  output element as additional input to the function.
  For the first computation, an initial value is provided. *}
definition sscanl     :: "('o \<Rightarrow> 'i \<Rightarrow> 'o) \<Rightarrow> 'o \<Rightarrow> ('i, 'o) spf" where
"sscanl f q \<equiv> \<Lambda> s. \<Squnion>i. SSCANL i f q s"

text {* @{term siterate}: Create a stream by repeated application of
  a function to an element. The generated stream starts with @{text "a"},
  @{text "f(a)"}, @{text "f(f(a))"}, and so on. *}
definition siterate   :: "('a \<Rightarrow> 'a) \<Rightarrow> 'a \<Rightarrow> 'a stream" where
"siterate f (a::'a) \<equiv> \<up>a \<bullet> sscanl (\<lambda>a (b::'a). f a) a\<cdot>(SOME x. #x = \<infinity>)"

(* ----------------------------------------------------------------------- *)
text {* Conversion between lists and streams and the processing functions:*}
(* ----------------------------------------------------------------------- *)
text {* @{term list2s}: Convert a list to a (finite) stream. *}
text {* (Only listed as a constant below for reference;
  Use @{text "list2s"} with same signature instead). *}
(* consts list2s_   :: "'a list \<Rightarrow> 'a stream" *)

text {* @{term s2list}: Convert a stream to a list. Result for
  infinite streams is undefined. *}
definition s2list     :: "'a stream \<Rightarrow> 'a list" where
"s2list s \<equiv> if #s \<noteq> \<infinity> then SOME l. list2s l = s else undefined"

text {* @{term slpf2spf}: Convert a list-processing function to a
  stream-processing function. *}
definition slpf2spf   ::"('in,'out) lpf \<Rightarrow> ('in,'out) spf" where
"slpf2spf f \<equiv> 
    if monofun f 
      then \<Lambda> s. (\<Squnion>k. list2s (f (s2list (stake k\<cdot>s)))) 
      else undefined"

text {* @{term sislivespf}: Liveness predicate for SPFs. A SPF
  is considered live if all finite inputs are mapped to finite outputs. *}
definition sislivespf ::"('in,'out) spf \<Rightarrow> bool" where
"sislivespf f \<equiv> (\<forall>x. #(f\<cdot>x) = \<infinity> \<longrightarrow> #x = \<infinity>)"

text {* @{term sspf2lpf}: Convert a stream-processing function
  to a list-processing function. *}
definition sspf2lpf   ::"('in,'out) spf \<Rightarrow> ('in,'out) lpf" where
"sspf2lpf f \<equiv>  if sislivespf f then (\<lambda>x. s2list (f\<cdot>(list2s x))) else undefined"


(* ----------------------------------------------------------------------- *)
subsection {* Syntactic sugar and helpers*}
(* ----------------------------------------------------------------------- *)

text {* The following abbreviations define infix and prefix operators
  for a more intuitive usage. *}



abbreviation sfilter_abbr :: "'a set \<Rightarrow> 'a stream \<Rightarrow> 'a stream" ("(_ \<ominus> _)" [66,65] 65)
where "F \<ominus> s \<equiv> sfilter F\<cdot>s"


(* ----------------------------------------------------------------------- *)
subsection {* Definition of stream manipulating functions*}
(* ----------------------------------------------------------------------- *)

text {* In this section, the definitions for the previously
  declared functions are given. *}

text {* A typical procedure is to define a primary recursive function
  first and then define the stream-processing via the least upper
  bound of the function values for the prefixes of a stream. *}

(* concatenates a stream to itself n times *)
primrec sntimes :: "nat \<Rightarrow> 'a stream \<Rightarrow> 'a stream" where
  "sntimes 0 s = \<epsilon>" |
  "sntimes (Suc n) s = (sconc s)\<cdot>(sntimes n s)"

text {* In most cases, stream-processing functions or operators
  on streams are defined using the continuous fixed point operator. *}


(* ----------------------------------------------------------------------- *)
section {* Stream - basics *}
(* --------------------------------------\<Squnion>--------------------------------- *)

text {* In the following, lemmas on streams and their operators
  are proven. In most cases, the stated lemma is shortly summarized
  in natural language. Where this is not the case, the lemma
  itself is mostly self-explanatory. *}

(* ----------------------------------------------------------------------- *)
subsection {* Fundamental properties of @{term stake} *}
(* ----------------------------------------------------------------------- *)

text {* Some aliases of auto-generated lemmas are introduced: *}
lemmas scases' = stream.exhaust
lemmas sinjects' = stream.injects
lemmas sinverts' = stream.inverts

text {* Each stream is the least upper bound of its prefixes.
  As we we are in a CPO, upper bounds of chains always exist. *}
lemma reach_stream: "(\<Squnion>i. stake i\<cdot>s) = s"
apply (rule stream.take_lemma [OF spec [where x=s]])
apply (induct_tac n, simp, rule allI)
apply (rule_tac y=x in scases', simp)
apply (subst lub_range_shift [where j="Suc 0", THEN sym],simp+)
by (subst contlub_cfun_arg [THEN sym], auto)

(* ----------------------------------------------------------------------- *)
subsection {* The continuity of concatenation *}
(* ----------------------------------------------------------------------- *)

text {* The function body which is used to define concatenation
  is continuous. Continuity has to be proven before the Lambda-
  expression may be evaluated (beta reduction). *}

lemma cont_sconc: 
  "\<And>s1 s2. 
     cont (\<lambda>h. if s1 = \<epsilon> then s2 else (lshd\<cdot>s1) && (h (srt\<cdot>s1)\<cdot>s2))"
apply (rule contI)
apply (rule_tac y=s1 in scases', simp+)
apply (rule is_lub_const)
apply (subst lub_fun, assumption)
apply (subst contlub_cfun_fun)
apply (rule ch2ch_fun, assumption)
apply (subst contlub_cfun_arg)
apply (rule ch2ch_Rep_cfunL)
apply (rule ch2ch_fun, assumption)
apply (rule thelubE, simp)
apply (rule ch2ch_Rep_cfunR)
apply (rule ch2ch_Rep_cfunL)
by (rule ch2ch_fun, assumption, simp)

(* ----------------------------------------------------------------------- *)
subsection {* Construction by concatenation and more *}
(* ----------------------------------------------------------------------- *)

text {* Basic properties of @{text "\<up>_"} constructor *}

(* shd composed with \<up> is the identity. *)
lemma [simp]: "shd (\<up>a) = a"
by (simp add: shd_def sup'_def)

(* the singleton stream is never equal to the empty stream *)
lemma [simp]: "\<up>a \<noteq> \<epsilon>"
by (simp add: sup'_def)

(* the rest of the singleton stream is empty *)
lemma [simp]: "srt\<cdot>(\<up>a) = \<epsilon>"
by (simp add: sup'_def)

text {* Basic properties of concatenation *}

(* the empty stream is the identity element with respect to concatenation *)
lemma sconc_fst_empty[simp]:"\<epsilon> \<bullet> s = s"
apply (subst sconc_def [THEN fix_eq2])
by (simp add: cont2cont_LAM)

(* the lazy stream constructor and concatenation are associative *) 
lemma sconc_scons': "(updis a && as) \<bullet> s = updis a && (as \<bullet> s)"
apply (subst sconc_def [THEN fix_eq2])
by (simp add: cont2cont_LAM)

(* the lazy stream constructor is equivalent to concatenation with a singleton stream *)
lemma lscons_conv: "updis a && s = \<up>a \<bullet> s"
apply (subst sconc_def [THEN fix_eq2])
apply (simp add:  sup'_def)
by (simp add: cont2cont_LAM)

(* concatenation with respect to singleton streams is associative *)
lemma sconc_scons[simp]: "(\<up>a \<bullet> as) \<bullet> s = \<up>a \<bullet> (as \<bullet> s)"
apply (subst sconc_def [THEN fix_eq2])
by (simp add: sconc_scons' sup'_def cont2cont_LAM)

text {* If a predicate P holds for empty and non-empty streams, it holds for all streams *}
lemma scases: "\<And>x P. \<lbrakk>x = \<epsilon> \<Longrightarrow> P; \<And>a s. x = \<up>a \<bullet> s \<Longrightarrow> P\<rbrakk> \<Longrightarrow> P"
apply (rule_tac y=x in scases', simp+)
apply (rule_tac p=u in upE, simp+)
apply (case_tac "xa")
by (auto simp add: sup'_def sconc_scons')

(* Single element streams commute with the stake operation. *)
lemma stake_Suc[simp]: "stake (Suc n)\<cdot>(\<up>a \<bullet> as) = \<up>a \<bullet> stake n\<cdot>as"
by (simp add: sconc_scons' sup'_def)

(* see also sconc_fst_empty *)
lemma sconc_snd_empty[simp]: "s \<bullet> \<epsilon> = s"
apply (rule stream.take_lemma [OF spec [where x = "s"]])
apply (induct_tac n, simp)
apply (rule allI, simp)
by (rule_tac x=x in scases, simp+)

(* shd is the inverse of prepending a singleton *)
lemma shd1[simp]: "shd (\<up>a \<bullet> s) = a"
by (simp add: sconc_scons' shd_def sup'_def)

(* srt is the inverse of appending to a singleton *)
lemma [simp]: "srt\<cdot>(\<up>a\<bullet>as) = as"
by (simp add: sconc_scons' sup'_def)

(* appending to a singleton is monotone *)
lemma [simp]: "\<up>a \<sqsubseteq> \<up>a \<bullet> s"
apply (subst sconc_snd_empty [of "\<up>a", THEN sym])
by (rule monofun_cfun_arg, simp)

text {* Properties of discrete partial orders *}

(* updis is a bijection *)
lemma updis_eq: "(updis a = updis b) = (a = b)"
by simp

(* the discrete order only considers equal elements to be ordered *)
lemma updis_eq2: "(updis a \<sqsubseteq> updis b) = (a = b)"
by simp

text {* Mapping a stream to head and rest is injective *}
lemma inject_scons: "\<up>a \<bullet> s1 = \<up>b \<bullet> s2 \<Longrightarrow> a = b \<and> s1 = s2"
apply (subst updis_eq [THEN sym])
apply (rule sinjects' [THEN iffD1], simp)
by (simp add: sconc_scons' sup'_def)

text {* @{text "\<sqsubseteq>"} applied to head and rest *}
lemma less_all_sconsD: "\<up>a \<bullet> as \<sqsubseteq> \<up>b \<bullet> bs \<Longrightarrow> a = b \<and> as \<sqsubseteq> bs"
apply (subst updis_eq2 [THEN sym])
apply (rule sinverts' [THEN iffD1], simp)
by (simp add: sconc_scons' sup'_def)

(* appending to a singleton stream can never yield the empty stream *)
lemma [simp]: "\<epsilon> \<noteq> \<up>a \<bullet> as"
apply (rule ccontr, simp)
apply (drule po_eq_conv [THEN iffD1])
apply (erule conjE)
by (simp add: sconc_scons' sup'_def)

lemma [simp]: "\<up>a \<bullet> as \<noteq> \<epsilon>"
by (rule notI, drule sym, simp)

text {* Characterizations of equality with @{text "\<sqsubseteq>"}, head and rest *}

(* singleton streams are only in an ordered relation if the two elements are equal *)
lemma [simp]: "(\<up>a \<sqsubseteq> \<up>b) = (a = b)"
apply (rule iffI)
by (insert less_all_sconsD [of a \<epsilon> b \<epsilon>], simp+)

(* uparrow is a bijection *)
lemma [simp]: "(\<up>a = \<up>b) = (a = b)"
apply (rule iffI)
by (insert inject_scons [of a \<epsilon> b \<epsilon>], simp+)

(* appending a stream x to a singleton stream and producing another singleton stream implies that 
   the two singleton streams are equal and x was empty *)
lemma [simp]: "(\<up>a \<bullet> x = \<up>c) = (a = c \<and> x = \<epsilon>)"
by (rule iffI, insert inject_scons [of a x c \<epsilon>], simp+)

lemma [simp]: "(\<up>c = \<up>a \<bullet> x) = (a = c \<and> x = \<epsilon>)"
by (rule iffI, insert inject_scons [of c \<epsilon> a x], simp+)

lemma [simp]: "(\<up>a \<bullet> x \<sqsubseteq> \<up>b) = (a = b \<and> x = \<epsilon>)" 
by (rule iffI, insert less_all_sconsD [of a x b \<epsilon>], simp+)

(* if a singleton stream is the prefix of another stream then the heads of the two streams must match *)
lemma [simp]: "(\<up>a \<sqsubseteq> \<up>b \<bullet> x) = (a = b)" 
by (rule iffI, insert less_all_sconsD [of a \<epsilon> b x], simp+)

(* if x isn't empty then concatenating head and rest leaves the stream unchanged *)
lemma surj_scons: "x\<noteq>\<epsilon> \<Longrightarrow> \<up>(shd x) \<bullet> (srt\<cdot>x) = x"
by (rule_tac x=x in scases, simp+)

text {* Characterizations of @{text "\<sqsubseteq>"} with head and rest *}

(* any nonempty prefix of a stream y is still a prefix when ignoring the first element *)
lemma less_fst_sconsD: "\<up>a \<bullet> as \<sqsubseteq> y \<Longrightarrow> \<exists>ry. y = \<up>a \<bullet> ry \<and> as \<sqsubseteq> ry"
apply (rule_tac x=y in scases, simp+) 
apply (rule_tac x="s" in exI)
by (drule less_all_sconsD, simp)

(* the prefix of any non-empty stream is either empty or shares the same first element *)
lemma less_snd_sconsD: 
  "x \<sqsubseteq> \<up>a\<bullet>as \<Longrightarrow> (x = \<epsilon>) \<or> (\<exists>rx. x = \<up>a\<bullet>rx \<and> rx \<sqsubseteq> as)"
apply (rule_tac x=x in scases, simp+) 
apply (rule_tac x="s" in exI)
by (drule less_all_sconsD, simp)

(* semantically equivalent to less_fst_sconsD *)
lemma lessD: 
  "x \<sqsubseteq> y \<Longrightarrow> (x = \<epsilon>) \<or> (\<exists>a q w. x = \<up>a\<bullet>q \<and> y = \<up>a\<bullet>w \<and> q \<sqsubseteq> w)"
apply (rule_tac x=x in scases, simp+)  
apply (rule_tac x="a" in exI)
apply (rule_tac x="s" in exI, simp)
by (drule less_fst_sconsD, simp)

(* ----------------------------------------------------------------------- *)
subsection {* @{term slen} *}
(* ----------------------------------------------------------------------- *)

lemma strict_slen[simp]:"#\<epsilon> = 0"
by (subst slen_def [THEN fix_eq2], simp add: lnzero_def)

(* prepending a singleton stream increases the length by 1 *)
lemma slen_scons[simp]: "#(\<up>a\<bullet>as) = lnsuc\<cdot>(#as)" 
by (subst slen_def [THEN fix_eq2], simp add: lnle_def)

(* the singleton stream has length 1 *)
lemma [simp]: "#(\<up>a) = Fin (Suc 0)"
apply (subst sconc_snd_empty [of "\<up>a", THEN sym])
by (subst slen_scons, simp+)

text {* The rest of infinite streams is infinite as well *}
lemma inf_scase:"#s = \<infinity> \<Longrightarrow> \<exists>a as. s = \<up>a \<bullet> as \<and> #as = \<infinity>"
by (rule_tac x=s in scases, auto)
 
(* only the empty stream has length 0 *)
lemma slen_empty_eq[simp]: "(#x = 0) = (x = \<epsilon>)"
by (rule_tac x=x in scases, auto)

text {* Appending to an inifite stream does not change its @{text "n"}th element *}
lemma sconc_fst_inf_lemma: "\<forall>x. #x=\<infinity> \<longrightarrow> stake n\<cdot>(x\<bullet>y) = stake n\<cdot>x"
apply (induct_tac n, auto)
by (rule_tac x=x in scases, auto)

text {* Appending to an infinite stream does not change the stream *}
lemma sconc_fst_inf[simp]: "#x=\<infinity> \<Longrightarrow> x\<bullet>y = x"
apply (rule stream.take_lemma)
by (rule sconc_fst_inf_lemma [rule_format])

text {* For finite streams, their lengths are added on concatenation *}
lemma slen_sconc_all_finite: 
  "\<forall>x y n. #x = Fin k \<and> #y = Fin n \<longrightarrow> #(x\<bullet>y) = Fin (k+n)" 
apply (induct_tac k, auto)
by (rule_tac x=x in scases, auto)

text {* Streams with infinite prefixes are infinite *}
lemma mono_fst_infD: "\<lbrakk>#x = \<infinity>; x \<sqsubseteq> y\<rbrakk> \<Longrightarrow> #y = \<infinity> "
apply (drule monofun_cfun_arg [of _ _ slen])
by (rule lnat_po_eq_conv [THEN iffD1], simp)

text {* For @{term "s \<sqsubseteq> t"} with @{term s} and @{term t} of
  equal length, all finite prefixes are identical *}
lemma stake_eq_slen_eq_and_less: 
  "\<forall>s t. #s = #t \<and> s \<sqsubseteq> t \<longrightarrow> stake n\<cdot>s = stake n\<cdot>t"
apply (induct_tac n, auto)
apply (rule_tac x=s in scases, auto)
apply (rule_tac x=t in scases, auto)
by (drule less_all_sconsD, auto)

text {* For @{term "s \<sqsubseteq> t"} with @{term s} and @{term t} of
  equal length, @{term s} and @{term t} are identical *}
lemma eq_slen_eq_and_less: "\<lbrakk>#s = #t; s \<sqsubseteq> t\<rbrakk> \<Longrightarrow> s = t"
apply (rule stream.take_lemma)
by (rule stake_eq_slen_eq_and_less [rule_format], rule conjI)

text {* Infinite prefixes are equal to the original stream *}
lemma eq_less_and_fst_inf: "\<lbrakk>s1 \<sqsubseteq> s2; #s1 = \<infinity>\<rbrakk> \<Longrightarrow> s1 = s2"
apply (rule eq_slen_eq_and_less, simp) 
apply (rule sym)
by (rule mono_fst_infD [of "s1" "s2"])

(*
lemma s1: "chain S \<Longrightarrow> \<not> finite_chain S \<Longrightarrow> \<forall>i. \<exists>j\<ge>i. S i \<sqsubseteq> S j"
by auto

lemma "chain S \<Longrightarrow> \<not> finite_chain S \<Longrightarrow> \<exists>k. #(S k) = \<infinity>"
apply (simp add: finite_chain_def max_in_chain_def )
apply (subgoal_tac "chain S \<Longrightarrow> \<not> finite_chain S \<Longrightarrow> \<forall>i. \<exists>j\<ge>i. S i \<sqsubseteq> S j")
prefer 2
apply (simp add: s1, simp)
sledgehammer
*)




text {* For infinite streams, @{text "stake n"} returns @{text "n"} elements *}
lemma slen_stake_fst_inf[rule_format]: 
  "\<forall>x. #x = \<infinity> \<longrightarrow> #(stake n\<cdot>x) = Fin n"
apply (induct_tac n, auto)
by (rule_tac x=x in scases, auto)

(* mapping a stream to its length is a monotone function *)
lemma mono_slen: "x \<sqsubseteq> y \<Longrightarrow> #x \<le> #y"
by (drule_tac x = x and y = y and f = slen 
  in monofun_cfun_arg, simp)

text {* A stream is shorter than @{text "n+1"} iff its rest is shorter than @{text "n"} *}
lemma slen_rt_ile_eq: "(#x \<le> Fin (Suc n)) = (#(srt\<cdot>x) \<le> Fin n)"  
by (rule_tac x=x in scases, auto)

text {* If @{text "#x < #y"}, this also applies to the streams' rests (for nonempty, finite x) *}
lemma smono_slen_rt_lemma: 
  "#x = Fin k \<and> x \<noteq> \<epsilon> \<and> #x < #y \<longrightarrow> #(srt\<cdot>x) < #(srt\<cdot>y)"
apply (induct_tac k, auto)
apply (rule_tac x=x in scases, auto)
by (rule_tac x=y in scases, auto)

text {* If @{text "#x < #y"}, this also applies to the streams' rests (for finite x) *}
lemma smono_slen_rt: "\<lbrakk>x \<noteq> \<epsilon>; #x < #y\<rbrakk> \<Longrightarrow> #(srt\<cdot>x) < #(srt\<cdot>y)"
apply (rule_tac x="#x" in lncases, auto) 
by (rule smono_slen_rt_lemma [rule_format], simp)

text {* Infinite elements of a stream chain are equal to the LUB *}
lemma inf2max: "\<lbrakk>chain Y; #(Y k) = \<infinity>\<rbrakk> \<Longrightarrow> Y k = (\<Squnion>i. Y i)"
apply (subgoal_tac "Y k \<sqsubseteq> (\<Squnion>i. Y i)")
apply (drule eq_less_and_fst_inf, assumption+)
by (rule is_ub_thelub)

text {* @{text "stake n"} returns at most @{text "n"} elements *}
lemma ub_slen_stake[simp]: "#(stake n\<cdot>x) \<le> Fin n"
apply (rule spec [where x = x])
apply (induct_tac n, auto)
by (rule_tac x=x in scases, auto)

text {* @{text "stake"} always returns finite streams *}
lemma [simp]: "#(stake n\<cdot>x) \<noteq> \<infinity>"
proof (rule notI)
  assume inf: "#(stake n\<cdot>x) = \<infinity>"
  have "#(stake n\<cdot>x) \<le> Fin n" by (rule ub_slen_stake)
  thus False using inf by simp
qed

text {* @{text "stake"}ing at least @{text "#x"} elements returns @{text "x"} again *}
lemma fin2stake_lemma: "\<forall>x k. #x = Fin k \<and> k\<le>i \<longrightarrow> stake i\<cdot>x = x"
apply (induct_tac i, auto)
apply (rule_tac x=x in scases, auto)
by (case_tac "k", auto)

text {* @{text "stake"}ing @{text "#x"} elements returns @{text "x"} again *}
lemma fin2stake:"#x = Fin n \<Longrightarrow> stake n\<cdot>x = x"
by (rule fin2stake_lemma [rule_format, of "x" "n" "n"], simp)

(* ----------------------------------------------------------------------- *)
section {* Basic induction rules *}
(* ----------------------------------------------------------------------- *)

text {* induction for all prefixes *}
lemma stakeind: 
  "\<forall>x. (P \<epsilon> \<and> (\<forall>a s. P s \<longrightarrow> P (\<up>a \<bullet> s))) \<longrightarrow> P (stake n\<cdot>x)"
by (induct_tac n, auto, rule_tac x=x in scases, auto)

text {* induction for finite streams *}
lemma finind:
  "\<lbrakk>#x = Fin n; P \<epsilon>; \<And>a s. P s \<Longrightarrow> P (\<up>a \<bullet> s)\<rbrakk> \<Longrightarrow> P x"
apply (drule fin2stake)
apply (drule sym, erule ssubst)
apply (rule stakeind [rule_format])
apply (rule conjI, assumption)
apply (rule allI)+
by (rule impI, simp)

text {* induction for infinite streams and admissable predicates *}
lemma ind: 
  "\<lbrakk>adm P; P \<epsilon>; \<And>a s. P s  \<Longrightarrow> P (\<up>a \<bullet> s)\<rbrakk> \<Longrightarrow> P x"
apply (unfold adm_def)
apply (erule_tac x="\<lambda>i. stake i\<cdot>x" in allE, auto)
apply (simp add: stakeind)
by (simp add: reach_stream)

(* ----------------------------------------------------------------------- *)
subsection {* Other properties of @{term stake} *}
(* ----------------------------------------------------------------------- *)

text {* composition of @{text "stake"} *}
lemma stakeostake[simp]: "stake k\<cdot>(stake n\<cdot>x) = stake (min k n)\<cdot>x"
apply (rule_tac x="n" in spec)
apply (rule_tac x="k" in spec)
apply (rule ind [of _ x], simp+)
apply (rule allI)+
apply (case_tac "xa", simp+)
by (case_tac "x", simp+)

(* stake always returns a prefix of the input stream *)
lemma ub_stake[simp]: "stake n\<cdot>x \<sqsubseteq> x"
by (rule stream.take_below)

(* ----------------------------------------------------------------------- *)
subsection {* @{term sdrop} *}
(* ----------------------------------------------------------------------- *)

text {* basic properties of @{term sdrop} *}

lemma strict_sdrop[simp]: "sdrop n\<cdot>\<epsilon> = \<epsilon>"
by (simp add: sdrop_def, induct_tac n, auto)

lemma sdrop_0[simp]: "sdrop 0\<cdot>s = s"
by (simp add: sdrop_def)

(* dropping an additional element is equivalent to calling srt *)
lemma sdrop_back_rt: "sdrop (Suc n)\<cdot>s = srt\<cdot>(sdrop n\<cdot>s)"
by (simp add: sdrop_def)

lemma sdrop_forw_rt: "sdrop (Suc n)\<cdot>s = sdrop n\<cdot>(srt\<cdot>s)"
apply (simp add: sdrop_def)
by (subst iterate_Suc2 [THEN sym], simp)

(* dropping n + 1 elements from a non-empty stream is equivalent to dropping n items from the rest *)
lemma sdrop_scons[simp]: "sdrop (Suc n)\<cdot>(\<up>a \<bullet> as) = sdrop n\<cdot>as"
by (simp add: sdrop_forw_rt)

(* if dropping n items produces the empty stream then the stream contains n elements or less *)
lemma sdrop_stakel1: "\<forall>s. sdrop n\<cdot>s = \<epsilon> \<longrightarrow> stake n\<cdot>s = s"
apply (induct_tac n, auto)
by (rule_tac x=s in scases, auto)

text {* Dropping from infinite streams still returns infinite streams *}
lemma fair_sdrop[rule_format]: 
  "\<forall>x. #x = \<infinity> \<longrightarrow> #(sdrop n\<cdot>x) = \<infinity>"
apply (induct_tac n, simp, clarify)
by (rule_tac x=x in scases, auto)

text {* streams can be split by @{term stake} and @{term sdrop} *}
lemma split_streaml1[simp]: 
  "stake n\<cdot>s \<bullet> sdrop n\<cdot>s = s"
apply (rule spec [where x = s])
apply (induct_tac n, auto)
by (rule_tac x=x in scases, auto)

text {* @{term sdrop} may only create infinite outputs for infinite inputs *}
lemma fair_sdrop_rev:
  "#(sdrop k\<cdot>x) = \<infinity> \<Longrightarrow> #x = \<infinity>"
apply (simp add: atomize_imp)
apply (rule_tac x="x" in spec)
apply (induct_tac k, simp)
apply (rule allI, rule impI)
apply (rule_tac x="x" in scases, simp)
by (erule_tac x="s" in allE, simp)

text {* construct @{term "sdrop j"} from @{term "sdrop k"} (with @{term "j \<le> k"}) *}
lemma sdropl5:
  "j \<le> k \<Longrightarrow> sdrop j\<cdot>(stake k\<cdot>x) \<bullet> sdrop k\<cdot>x = sdrop j\<cdot>x"
apply (simp add: atomize_imp)
apply (rule_tac x="j" in spec)
apply (rule_tac x="x" in spec)
apply (induct_tac k, auto)
apply (rule_tac x="x" in scases, auto)
by (case_tac "xa", auto)

text {* Dropping as inverse of prepending a finite stream *}
lemma sdropl6:
  "#x = Fin k \<Longrightarrow> sdrop k\<cdot>(x \<bullet> y) = y"
apply (simp add: atomize_imp)
apply (rule_tac x="x" in spec)
apply (rule_tac x="y" in spec)
apply (induct_tac k, auto)
by (rule_tac x="xa" in scases, auto)

(* ----------------------------------------------------------------------- *)
subsection {* @{term snth} *}
(* ----------------------------------------------------------------------- *)

text {* Basic properties of @{term snth} *}

(* the element k + 1 of the stream s is identical to the element k of the rest of s *)
lemma snth_rt: "snth (Suc k) s = snth k (srt\<cdot>s)"
apply (simp add: snth_def)
by (subst sdrop_forw_rt,rule refl)

(* semantically equivalent to snth_rt *)
lemma snth_scons[simp]: "snth (Suc k) (\<up>a \<bullet> s) = snth k s"
by (simp add: snth_rt)

(* indexing starts at 0, so the 0'th element is equal to the head *)
lemma snth_shd[simp]: "snth 0 s = shd s"
by (simp add: snth_def)

text {* If two streams of same length agree on every element,
  all their finite prefixes are equal *}
lemma snths_eq_lemma [rule_format]: 
  "\<forall>x y. #x = #y \<and> (\<forall>n. Fin n < #x \<longrightarrow> snth n x = snth n y) 
           \<longrightarrow> stake k\<cdot>x = stake k\<cdot>y"
apply (induct_tac k, auto)
apply (rule_tac x=x in scases, auto)
apply (rule_tac x=y in scases, auto)
apply (erule_tac x="s" in allE)
apply (erule_tac x="sa" in allE, auto)
apply (erule_tac x="Suc na" in allE, simp)
by (erule_tac x="0" in allE, auto)

text {* If two streams of same length agree on every element, they are equal *}
lemma snths_eq: 
  "\<lbrakk>#x = #y; \<forall>n. Fin n < #x \<longrightarrow> snth n x = snth n y\<rbrakk> \<Longrightarrow> x = y"
apply (rule stream.take_lemma)
by (rule snths_eq_lemma, auto)

(* ----------------------------------------------------------------------- *)
section {* Further lemmas *}
(* ----------------------------------------------------------------------- *)

(* concatenation is associative *)
lemma assoc_sconc[simp]: "(s1\<bullet>s2)\<bullet>s3 = s1\<bullet>s2\<bullet>s3"
apply (rule_tac x="#s1" in lncases, auto)
by (rule finind [of "s1"], auto)

text {* Finite, equal streams agree on all postfixes *}
lemma inject_sconc: "\<lbrakk>#x = Fin k; x \<bullet> y = x \<bullet> z\<rbrakk> \<Longrightarrow> y = z"
apply (simp add: atomize_imp)
apply (rule_tac x=x in spec)
apply (induct_tac k, auto)
apply (rule_tac x=x in scases, auto)
by (drule inject_scons, auto)

lemma [simp]: "x \<sqsubseteq> x \<bullet> y"
apply (rule_tac x="#x" in lncases, auto)
apply (rule finind [of x], auto)
by (rule monofun_cfun_arg)

text {* Prepending to infinite streams produces infinite streams again *}
lemma slen_sconc_snd_inf: "#y=\<infinity> \<Longrightarrow> #(x \<bullet> y) = \<infinity>"
apply (rule_tac x="#x" in lncases, auto)
by (rule finind [of "x"], auto)

(* stake n results in a stream of length n, so sdrop n then results in the empty stream *)
lemma sdropostake: "sdrop n\<cdot>(stake n\<cdot>s) = \<epsilon>"
apply (rule spec [where x = n])
apply (rule ind [of _ s], auto)
by (case_tac x, auto)

(* ----------------------------------------------------------------------- *)
section {* Additional lemmas for approximation, chains and continuity *} 
(* ----------------------------------------------------------------------- *)

text {* A finite prefix of length @{term "k"} is created by @{term "stake k"} *}
lemma approxl1:
  "\<forall>s1 s2. s1 \<sqsubseteq> s2 \<and> #s1 = Fin k \<longrightarrow> stake k\<cdot>s2 = s1"
apply (induct_tac k, auto)
apply (rule_tac x=s1 in scases, auto)
apply (rule_tac x=s2 in scases, auto)
apply (erule_tac x="s" in allE)
apply (erule_tac x="sa" in allE)
by (drule less_all_sconsD, auto)

text {* A prefix of a stream is equal to the original one or a finite prefix *}
lemma approxl2:
  "s1 \<sqsubseteq> s2 \<Longrightarrow> (s1 = s2) \<or> (\<exists>n. stake n\<cdot>s2 = s1 \<and> Fin n = #s1)"
apply (rule_tac x="#s1" in lncases, auto)
apply (rule eq_less_and_fst_inf, assumption+)
by (insert approxl1 
  [rule_format, of "s1" "s2"], auto)

text {* In infinite chains, all streams are finite *}
lemma inf_chainl1:
  "\<lbrakk>chain Y; \<not>finite_chain Y\<rbrakk> \<Longrightarrow> \<exists>k. #(Y i) = Fin k"
apply (rule ccontr, simp, frule infI)
apply (frule_tac k="i" in inf2max, assumption)
apply (frule_tac i="i" in max_in_chainI3, simp+)
by (simp add: finite_chain_def)

text {* Each prefix of a stream can be expanded to the original stream *}
lemma approxl3: "s1 \<sqsubseteq> s2 \<Longrightarrow> \<exists>t. s1\<bullet>t = s2"
apply (rule_tac x="#s1" in lncases, simp)
apply (drule eq_less_and_fst_inf, simp+)
apply (subst approxl1 
  [rule_format, of "s1" "s2", THEN sym], simp+)
by (rule_tac x="sdrop k\<cdot>s2" in exI, simp)

text {* In infinite chains, there is an element which is a true prefix of another one *}
lemma inf_chainl2:
  "\<lbrakk>chain Y; \<not> finite_chain Y\<rbrakk> \<Longrightarrow> \<exists>j. Y k \<sqsubseteq> Y j \<and> #(Y k) < #(Y j)"
apply (auto simp add: finite_chain_def max_in_chain_def)
apply (erule_tac x="k" in allE, auto)
apply (frule_tac i=k and j=j in chain_mono, assumption)
apply (rule_tac x="j" in exI, simp)
apply (auto simp add: lnless_def)
apply (rule mono_slen, assumption)
by (frule eq_slen_eq_and_less, simp+)

text {* In infinite chains, the length of the streams is unbounded *}
lemma inf_chainl3:
  "chain Y \<and> \<not>finite_chain Y \<longrightarrow> (\<exists>k. Fin n \<le> #(Y k))"
apply (induct_tac n, auto)
apply (case_tac "Fin n = #(Y k)")
apply (frule_tac k=k in inf_chainl2, auto)
apply (rule_tac x="j" in exI)
apply (drule sym)
apply (rule_tac x="#(Y j)" in lncases, auto)
apply (rule_tac x="k" in exI)
by (rule_tac x="#(Y k)" in lncases, auto)

text {* In infinite chains, the lub is infinite *}
lemma inf_chainl4:
  "\<lbrakk>chain Y; \<not>finite_chain Y\<rbrakk> \<Longrightarrow> #(lub(range Y)) = \<infinity>"
apply (rule_tac x="#(Lub Y)" in lncases, auto)
apply (frule_tac n = "Suc k" in inf_chainl3 
  [rule_format, OF conjI], assumption, erule exE)
apply (subgoal_tac "Y ka \<sqsubseteq> (Lub Y)")
apply (drule monofun_cfun_arg [of _ _ slen], simp)
apply (frule_tac x = "Fin (Suc k)" and 
  y = "#(Y ka)" and z = "Fin k" in trans_lnle, simp+)
by (rule is_ub_thelub)

text {* Each chain becomes finite by mapping @{term "stake n"} to every element *}
lemma finite_chain_stake: 
  "chain Y \<Longrightarrow> finite_chain (\<lambda>i. stake n\<cdot>(Y i))"
apply (frule ch2ch_Rep_cfunR [of _ "stake n"])
apply (rule ccontr)
apply (frule inf_chainl4 [of "\<lambda>i. stake n\<cdot>(Y i)"],assumption)
by (simp add: contlub_cfun_arg [THEN sym])

text {* every finite prefix of the lub is also prefix of some element in the chain *}
lemma lub_approx: 
  "chain Y \<Longrightarrow> \<exists>k. stake n\<cdot>(lub (range Y)) = stake n\<cdot>(Y k)"
apply (subst contlub_cfun_arg, assumption)
apply (frule finite_chain_stake [of _ n])
apply (simp add: finite_chain_def, auto)
apply (rule_tac x="i" in exI)
by (rule lub_finch1  
  [THEN lub_eqI, of "\<lambda>i. stake n\<cdot>(Y i)"], auto)

text {* If @{term f} is monotone and for each @{term x} there is a finite prefix
  @{term y} such that @{term "f x = f y"}, @{term f} is continuous *}
lemma pr_contI: 
  "\<lbrakk>monofun f; \<forall>x.\<exists>n. (f x) = f (stake n\<cdot>x)\<rbrakk> \<Longrightarrow> cont f"
apply (rule contI2, assumption)
apply (rule allI, rule impI)
apply (erule_tac x="lub (range Y)" in allE, erule exE)
apply (frule_tac n = n in lub_approx, erule exE)
apply (subgoal_tac "f (stake n\<cdot>(Y k)) \<sqsubseteq> f (Y k)")
apply (subgoal_tac "f (Y k) \<sqsubseteq> (\<Squnion>i. f (Y i))")
apply (drule_tac x="f (stake n\<cdot>(Y k))" and 
  y="f (Y k)" and z = "\<Squnion>i. f (Y i)" in below_trans)
apply (rule is_ub_thelub)
apply (rule_tac f=f in ch2ch_monofun, assumption+)
apply (clarsimp)
apply (rule is_ub_thelub)
apply (rule_tac f=f in ch2ch_monofun, assumption+)
by (rule_tac f = f in monofunE, simp+)

text {* For continuous functions, each finite prefix of @{term "f\<cdot>x"} only
  depends on a finite prefix of @{term "x"} *}
lemma fun_approxl1: 
  "\<exists>j. stake k\<cdot>(f\<cdot>x) = stake k\<cdot>(f\<cdot>(stake j\<cdot>x))"
apply (subgoal_tac "f\<cdot>x = (\<Squnion>i. f\<cdot>(stake i\<cdot>x))")
apply (erule ssubst)
apply (rule lub_approx)
apply (rule chain_monofun)
apply (rule ch2ch_Rep_cfunL)
apply (rule stream.chain_take)
apply (subst contlub_cfun_arg [THEN sym])
apply (rule ch2ch_Rep_cfunL)
apply (rule stream.chain_take)
apply (subst reach_stream)
by (rule refl)

text {* For continuous functions, any finite output for stream @{term "x"} can also be
  obtained by some finite prefix of @{term "x"} *}
lemma fun_approxl2: "#(f\<cdot>x) = Fin k \<Longrightarrow> \<exists>j. f\<cdot>x = f\<cdot>(stake j\<cdot>x)" 
apply (insert fun_approxl1 [of k "f" x], auto)
apply (rule_tac x="j" in exI)
apply (frule fin2stake [THEN sym], simp)
apply (rule stream.take_lemma, simp)
apply (case_tac "n \<le> k")
apply (simp add: min_def)+
apply (rule po_eq_conv [THEN iffD2])
apply (rule conjI)
apply (rule monofun_cfun_fun)
apply (rule chain_mono)
apply (rule stream.chain_take, simp+)
apply (subgoal_tac "f\<cdot>(stake j\<cdot>x) \<sqsubseteq> f\<cdot>x")
apply (rule below_trans, auto)
apply (drule sym, drule sym, simp)
by (rule monofun_cfun_arg, simp)

(* ----------------------------------------------------------------------- *)
section {* Lemmas for the remaining definitions *}
(* ----------------------------------------------------------------------- *)

(* ----------------------------------------------------------------------- *)
subsection {* @{term slookahd} *}
(* ----------------------------------------------------------------------- *)

text {* @{term slookahd} is continuous *}
lemma cont_slookahd[simp]: "cont (\<lambda> s. if s=\<epsilon> then \<bottom> else eq (shd s))"
apply (rule pr_contI)
apply (rule monofunI, auto)
apply (rule_tac x=x in scases, auto)
apply (rule_tac x=y in scases, auto)
apply (drule less_all_sconsD, simp)
apply (rule_tac x=x in scases, auto)
by (rule_tac x="Suc 0" in exI, auto)

(* slookahd applied to the empty stream results in the bottom element for any function eq *)
lemma strict_slookahd[simp]: "slookahd\<cdot>\<epsilon>\<cdot>eq = \<bottom>"
by (simp add: slookahd_def cont2cont_LAM)

(* if s isn't the empty stream, the function eq will be applied to the head of s *)
lemma slookahd_scons[simp]: "s\<noteq>\<epsilon> \<Longrightarrow> slookahd\<cdot>s\<cdot>eq = eq (shd s)"
by (simp add: slookahd_def cont2cont_LAM)

(* the constant function that always returns the empty stream unifies the two cases of slookahd *)
lemma strict2_slookahd[simp]: "slookahd\<cdot>xs\<cdot>(\<lambda>y. \<epsilon>) = \<epsilon>"
by (cases xs, simp_all)

(* ----------------------------------------------------------------------- *)
subsection {* @{term sinftimes} *}
(* ----------------------------------------------------------------------- *)

text {* basic properties of @{term sntimes} and @{term sinftimes} *}

(* repeating the empty stream produces the empty stream again for any n*)
lemma sntimes_eps[simp]: "sntimes n \<epsilon> = \<epsilon>"
by (induct_tac n, simp+)

(* infinitely cycling the empty stream produces the empty stream again *)
lemma strict_icycle[simp]: "sinftimes \<epsilon> = \<epsilon>"
by (subst sinftimes_def [THEN fix_eq2], auto)

(* repeating a stream infinitely often is equivalent to repeating it once and then infinitely often *)
lemma sinftimes_unfold: "sinftimes s = s \<bullet> sinftimes s"
by (subst sinftimes_def [THEN fix_eq2], auto)

text {* For nonempty @{term s}, @{term "sinftimes s"} is infinite *}
lemma slen_sinftimes: "s \<noteq> \<epsilon> \<Longrightarrow> #(sinftimes s) = \<infinity>"
apply (rule ccontr)
apply (rule_tac x="#(sinftimes s)" in lncases, auto)
apply (rule_tac x="#s" in lncases)
apply (insert sinftimes_unfold [of s], auto)
by (insert slen_sconc_all_finite 
  [rule_format, of "s" _ "sinftimes s"], force)

lemma [simp]: "#(sinftimes (\<up>a)) = \<infinity>" 
by (simp add: slen_sinftimes)

(* ----------------------------------------------------------------------- *)
subsection {* @{term smap} *}
(* ----------------------------------------------------------------------- *)

lemma strict_smap[simp]: "smap f\<cdot>\<epsilon> = \<epsilon>"
by (subst smap_def [THEN fix_eq2], simp)

(* smap distributes over concatenation *)
lemma smap_scons[simp]: "smap f\<cdot>(\<up>a \<bullet> s) = \<up>(f a) \<bullet> smap f\<cdot>s"
by (subst smap_def [THEN fix_eq2], simp)

(* mapping f over a singleton stream is equivalent to applying f to the only element in the stream *) 
lemma [simp]: "smap f\<cdot>(\<up>a) = \<up>(f a)"
by (subst smap_def [THEN fix_eq2], simp)

(* smap leaves the length of a stream unchanged *)
lemma slen_smap[simp]: "#(smap f\<cdot>x) = #x"
by (rule ind [of _ x], auto)

text {* @{term smap} maps each element @{term x} to @{term "f(x)"} *}
lemma smap_snth_lemma:
  "Fin n < #s \<Longrightarrow> snth n (smap f\<cdot>s) = f (snth n s)"
apply (simp add: atomize_imp)
apply (rule_tac x="s" in spec)
apply (induct_tac n, simp+)
by (rule allI, rule_tac x="x" in scases, simp+)+

text {* @{term sdrop} after @{term smap} is like @{term smap} after @{term sdrop} *}
lemma sdrop_smap[simp]: "sdrop k\<cdot>(smap f\<cdot>s) = smap f\<cdot>(sdrop k\<cdot>s)"
apply (rule_tac x="k" in spec)
apply (rule ind [of _ s], simp+)
apply (rule allI)
by (case_tac "x", simp+)

text {* @{term "smap f"} is a homomorphism on streams with respect to concatenation *}
lemma smap_split: "smap f\<cdot>(a \<bullet> b) = (smap f\<cdot>a) \<bullet> (smap f\<cdot>b)"
proof (rule lncases [of "#a"], simp)
  fix k assume "#a = Fin k"
  thus ?thesis by (rule Streams.finind [of "a"], simp_all)
qed

(* ----------------------------------------------------------------------- *)
subsection {* @{term sprojfst} and @{term sprojsnd} *}
(* ----------------------------------------------------------------------- *)

text {* basic properties of @{term sprojfst} *}

(* sprojfst extracts the first element of the first tuple in any non-empty stream of tuples *)
lemma sprojfst_scons[simp]: "sprojfst\<cdot>(\<up>(x, y) \<bullet> s) = \<up>x \<bullet> sprojfst\<cdot>s"
by (unfold sprojfst_def, simp)

(* the empty stream is a fixed point of sprojfst *)
lemma strict_sprojfst[simp]: "sprojfst\<cdot>\<epsilon> = \<epsilon>"
by (unfold sprojfst_def, simp)

(* sprojfst extracts the first element of any singleton tuple-stream *)
lemma [simp]: "sprojfst\<cdot>(\<up>(a,b)) = \<up>a"
by (simp add: sprojfst_def)

text {* same properties for @{term sprojsnd} *}

(* sprojsnd extracts the second element of the first tuple in any non-empty stream of tuples *)
lemma sprojsnd_scons[simp]: "sprojsnd\<cdot>(\<up>(x,y) \<bullet> s) = \<up>y \<bullet> sprojsnd\<cdot>s"
by (unfold sprojsnd_def, simp)

(* the empty stream is a fixed point of sprojsnd *)
lemma strict_sprojsnd[simp]: "sprojsnd\<cdot>\<epsilon> = \<epsilon>"
by (unfold sprojsnd_def, simp)

(* sprojsnd extracts the second element of any singleton tuple-stream *)
lemma [simp]: "sprojsnd\<cdot>(\<up>(a,b)) = \<up>b"
by (simp add: sprojsnd_def)

text {* @{term sprojfst} / @{term sprojsnd} and @{term srt} commute *}

lemma rt_Sproj_2_eq: "sprojsnd\<cdot>(srt\<cdot>x) = srt\<cdot>(sprojsnd\<cdot>x)"
by (rule ind [of _ x], auto)

lemma rt_Sproj_1_eq: "sprojfst\<cdot>(srt\<cdot>x) = srt\<cdot>(sprojfst\<cdot>x)"
by (rule ind [of _ x], auto)

text {* length of projections and the empty stream *}

lemma slen_sprojs_eq: "#(sprojsnd\<cdot>x) = #(sprojfst\<cdot>x)"
by (rule ind [of _ "x"], auto)

lemma strict_rev_sprojfst: "sprojfst\<cdot>x = \<epsilon> \<Longrightarrow> x = \<epsilon>"
by (rule ccontr, rule_tac x=x in scases, auto)

lemma strict_rev_sprojsnd: "sprojsnd\<cdot>x = \<epsilon> \<Longrightarrow> x = \<epsilon>"
by (rule ccontr, rule_tac x=x in scases, auto)

lemma slen_sprojfst: "#(sprojfst\<cdot>x) = #x"
by (rule ind [of _ "x"], auto)

lemma slen_sprojsnd: "#(sprojsnd\<cdot>x) = #x"
by (rule ind [of _ "x"], auto)

(* ----------------------------------------------------------------------- *)
subsection {* @{term sfilter} *}
(* ----------------------------------------------------------------------- *)

text {* basic properties of @{term sfilter} *}

(* note that M is a set, not a predicate *)

lemma strict_sfilter[simp]: "sfilter M\<cdot>\<epsilon> = \<epsilon>"
by (subst sfilter_def [THEN fix_eq2], simp)

(* if the head of a stream is in M, then sfilter will keep the head *)
lemma sfilter_in[simp]: 
  "a \<in> M \<Longrightarrow> sfilter M\<cdot>(\<up>a \<bullet> s) = \<up>a \<bullet> sfilter M\<cdot>s" 
by (subst sfilter_def [THEN fix_eq2], simp)

(* if the head of a stream isn't in M, then sfilter will discard the head *)
lemma sfilter_nin[simp]: 
  "a \<notin> M \<Longrightarrow> sfilter M\<cdot>(\<up>a \<bullet> s) = sfilter M\<cdot>s" 
by (subst sfilter_def [THEN fix_eq2], simp)

(* if the sole element in a singleton stream is in M then sfilter is a no-op *)
lemma [simp]: "a \<in> M \<Longrightarrow> sfilter M\<cdot>(\<up>a) = \<up>a"
by (subst sfilter_def [THEN fix_eq2], simp)

(* if the sole element in a singleton stream is not in M then sfilter produces the empty stream *)
lemma [simp]: "a \<notin> M \<Longrightarrow> sfilter M\<cdot>(\<up>a) = \<epsilon>"
by (subst sfilter_def [THEN fix_eq2], simp)

text {* @{term sfilter} and @{term sinftimes} *}

(* filtering all elements that aren't in {a} from a stream consisting only of the element a has no effect *)
lemma sfilter_sinftimes_in[simp]: 
  "sfilter {a}\<cdot>(sinftimes (\<up>a)) = sinftimes (\<up>a)"
apply (rule stream.take_lemma)
apply (induct_tac n, auto)
apply (subst sinftimes_unfold, simp)
apply (rule sym)
by (subst sinftimes_unfold, simp)

(* if the element a isn't in the set F then filtering a stream of infinitely many a's using F will
   produce the empty stream *)
lemma sfilter_sinftimes_nin:
  "a \<notin> F \<Longrightarrow> (F \<ominus> (sinftimes (\<up>a))) = \<epsilon>"
proof -
  assume a_nin_F: "a \<notin> F"
  have "\<And>i. (F \<ominus> (stake i\<cdot>(sinftimes (\<up>a)))) = \<epsilon>"
  proof (induct_tac i, simp_all)
    fix n assume "F \<ominus> (stake n\<cdot>(sinftimes (\<up>a))) = \<epsilon>"
    hence "F \<ominus> (stake (Suc n)\<cdot>(\<up>a \<bullet> sinftimes (\<up>a))) = \<epsilon>" using a_nin_F by simp
    thus "F \<ominus> stake (Suc n)\<cdot>(sinftimes (\<up>a)) = \<epsilon>" by (subst sinftimes_unfold)
  qed
  hence "(F \<ominus> (\<Squnion>i. stake i\<cdot>(sinftimes (\<up>a)))) = \<epsilon>" by (simp add:contlub_cfun_arg)
  thus ?thesis by (simp add: reach_stream)
qed

text {* Filtering a postfix is at most as long as filtering the whole stream *}
lemma slen_sfilter_sdrop_ile: 
  "#(sfilter X\<cdot>(sdrop n\<cdot>p)) \<le> #(sfilter X\<cdot>p)"
apply (rule spec [where x = "n"])
apply (rule ind [of _ p], auto)
apply (subst lnle_def, simp del: lnle_conv)
apply (case_tac "x", auto)
apply (case_tac "a \<in> X", auto)
apply (erule_tac x="nat" in allE)
by (rule trans_lnle, auto)

text {* If the filtered stream is infinite, each filtered postfix is infinite *}
lemma slen_sfilter_sdrop: 
  "\<forall>p X. #(sfilter X\<cdot>p) = \<infinity> \<longrightarrow> #(sfilter X\<cdot>(sdrop n\<cdot>p)) = \<infinity>" 
apply (induct_tac n, auto)
apply (rule_tac x=p in scases, auto)
by (case_tac "a\<in>X", auto)

text {* @{term sfilter} on @{term "stake n"} returns @{text "\<epsilon>"} if none of the first
  @{term n} elements is included in the filter *}
lemma sfilter_empty_snths_nin_lemma: 
  "\<forall>p. (\<forall>n. Fin n < #p \<longrightarrow> snth n p \<notin> X) \<longrightarrow> sfilter X\<cdot>(stake k\<cdot>p) = \<epsilon>"
apply (induct_tac k, auto)
apply (rule_tac x=p in scases, auto)
apply (case_tac "a\<in>X", auto)
apply (erule_tac x="0" in allE, simp)
apply (case_tac "n", auto)
apply (erule_tac x="s" in allE, auto)
by (erule_tac x="Suc n" in allE, auto)

text {* @{term sfilter} returns @{text "\<epsilon>"} if no element is included in the filter *}
lemma ex_snth_in_sfilter_nempty:
  "(\<forall>n. Fin n < #p \<longrightarrow> snth n p \<notin> X) \<Longrightarrow> sfilter X\<cdot>p = \<epsilon>"
apply (subgoal_tac "sfilter X\<cdot>p = (\<Squnion>k. sfilter X\<cdot>(stake k\<cdot>p))")
apply (erule ssubst)
apply (subst lub_eq_bottom_iff, simp)
apply (subst sfilter_empty_snths_nin_lemma, simp+)
apply (subst contlub_cfun_arg [THEN sym], simp)
by (simp add: reach_stream)

text {* The filtered stream is at most as long as the original one *}
lemma slen_sfilterl1: "#(sfilter S\<cdot>x) \<le> #x"
apply (rule ind [of _ x], auto)
apply (subst lnle_def, simp del: lnle_conv)
apply (case_tac "a \<in> S", auto)
by (rule trans_lnle, auto)

text {* If the filtered stream is infinite, the original one is infinite as well *}
lemma sfilterl4:
  "#(sfilter X\<cdot>x) = \<infinity> \<Longrightarrow> #x = \<infinity>"
by (insert slen_sfilterl1 [of X x], auto)

text {* Prepending to the original stream never shortens the filtered result *}
lemma sfilterl2: 
  "\<forall>z. #(sfilter X\<cdot>s) \<le> #(sfilter X\<cdot>((stake n\<cdot>z) \<bullet> s))"
apply (induct_tac n, auto)
apply (rule_tac x=z in scases, auto)
apply (case_tac "a\<in>X", auto)
apply (erule_tac x="sa" in allE)
by (drule trans_lnle, auto) 

text {* The filtered result is not changed by concatenating streams which are
  filtered to @{text "\<epsilon>"} *}
lemma sfilterl3:
  "\<forall>s. #s = Fin k \<and> sfilter S\<cdot>s = \<epsilon> \<longrightarrow> 
       sfilter S\<cdot>(s\<bullet>Z) = sfilter S\<cdot>Z" 
apply (induct_tac k, auto)
apply (rule_tac x=s in scases, auto)
by (case_tac "a \<in> S", auto)

text {* A stream can be split by @{term stake} and @{term sdrop} for filtering *}
lemma split_sfilter: "sfilter X\<cdot>x = sfilter X\<cdot>(stake n\<cdot>x) \<bullet> sfilter X\<cdot>(sdrop n\<cdot>x)"
apply (rule_tac x=x in spec)
apply (induct_tac n, simp)
apply (rule allI)
apply (rule_tac x=x in scases, simp)
apply (erule_tac x="s" in allE, auto)
by (case_tac "a \<in> X", auto)

text {* double filtering *}
lemma int_sfilterl1[simp]: "sfilter S\<cdot>(sfilter M\<cdot>s) = sfilter (S \<inter> M)\<cdot>s"
apply (rule ind [of _ s], auto)
apply (case_tac "a \<in> S \<inter> M", auto)
by (case_tac "a \<in> M", auto)

text {* Streams can be split for filtering *}
lemma add_sfilter:
  "#x = Fin k \<Longrightarrow> sfilter t\<cdot>(x \<bullet> y) = sfilter t\<cdot>x \<bullet> sfilter t\<cdot>y"
apply (simp add: atomize_imp)
apply (rule_tac x="y" in spec)
apply (rule_tac x="x" in spec)
apply (induct_tac k, auto)
apply (rule_tac x="x" in scases, auto)
by (case_tac "a \<in> t", auto)

text {* After applying @{term "smap f"}, all elements are in the range of @{term f} *}
lemma sfilter_smap_nrange: 
  "m \<notin> range f \<Longrightarrow> sfilter {m}\<cdot>(smap f\<cdot>x) = \<epsilon>"
apply (rule ex_snth_in_sfilter_nempty [rule_format], simp)
apply (subst smap_snth_lemma, simp+)
apply (rule notI)
apply (drule sym)
by (drule_tac f="f" in range_eqI, simp)

(* ----------------------------------------------------------------------- *)
subsection {* @{term stakewhile} *}
(* ----------------------------------------------------------------------- *)

text {* basic properties of @{term stakewhile} *}

lemma strict_stakewhile[simp]: "stakewhile f\<cdot>\<epsilon> = \<epsilon>"
by (subst stakewhile_def [THEN fix_eq2], simp)

(* if the head a passes the predicate f, then the result of stakewhile will start with \<up>a *)
lemma stakewhile_t[simp]: "f a \<Longrightarrow> stakewhile f\<cdot>(\<up>a \<bullet> s) = \<up>a \<bullet> stakewhile f\<cdot>s"
by (subst stakewhile_def [THEN fix_eq2], simp)

(* if the head a fails the predicate f, then stakewhile will produce the empty stream *)
lemma stakewhile_f[simp]: "\<not>f a \<Longrightarrow> stakewhile f\<cdot>(\<up>a \<bullet> s) = \<epsilon>"
by (subst stakewhile_def [THEN fix_eq2], simp)

(* if the element a passes the predicate f, then stakewhile applied to \<up>a is a no-op *)
lemma [simp]: "f a \<Longrightarrow> stakewhile f\<cdot>(\<up>a) = \<up>a"
by (subst stakewhile_def [THEN fix_eq2], simp)

(* if the element a fails the predicate f, then stakewhile applied to \<up>a will produce the empty stream *)
lemma [simp]: "\<not>f a \<Longrightarrow> stakewhile f\<cdot>(\<up>a) = \<epsilon>"
by (subst stakewhile_def [THEN fix_eq2], simp)

(* ----------------------------------------------------------------------- *)
subsection {* @{term stwbl} *}
(* ----------------------------------------------------------------------- *)

text {* basic properties for @{term stwbl} *}

lemma strict_stwbl[simp]: "stwbl f\<cdot>\<epsilon> = \<epsilon>"
by (subst stwbl_def [THEN fix_eq2], simp)

(* if the head a passes the predicate f, then the result of stwbl will start with \<up>a *)
lemma stwbl_t[simp]: "f a \<Longrightarrow> stwbl f\<cdot>(\<up>a \<bullet> s) = \<up>a \<bullet> stwbl f\<cdot>s"
by (subst stwbl_def [THEN fix_eq2], simp)

(* if the head a fails the predicate f, then stwbl will produce only \<up>a *)
lemma stwbl_f[simp]: "\<not> f a \<Longrightarrow> stwbl f\<cdot>(\<up>a \<bullet> s) = \<up>a"
by (subst stwbl_def [THEN fix_eq2], simp)

text {* @{term sfilter} after @{term stakewhile}: produce the empty stream *}
lemma sfilter_twl1[simp]: 
  "sfilter X\<cdot>(stakewhile (\<lambda>x. x\<notin>X)\<cdot>p) = \<epsilon>"
apply (rule ind [of _ p], auto)
by (case_tac "a\<in>X", auto)

text {* @{term sfilter} after @{term stakewhile}: redundant filtering *}
lemma sfilter_twl2[simp]: 
  "sfilter X\<cdot>(stakewhile (\<lambda>x. x\<in>X)\<cdot>p) = stakewhile (\<lambda>x. x\<in>X)\<cdot>p"
apply (rule ind [of _ p], auto)
by (case_tac "a\<in>X", auto)

text {* If @{term "stakewhile (\<lambda>p. p = t)"} returns an infinite stream, all prefixes
  of the original stream only consist of "@{term t}"s *}
lemma stakewhile_sinftimes_lemma: 
  "\<forall>z. #(stakewhile (\<lambda>p. p = t)\<cdot>z) = \<infinity> \<longrightarrow> stake n\<cdot>z = stake n\<cdot>(sinftimes (\<up>t))"
apply (induct_tac n, auto)
apply (subst sinftimes_unfold, simp)
apply (rule_tac x=z in scases, auto)
by (case_tac "a=t", auto)

text {* If @{term "stakewhile (\<lambda>p. p = t)"} returns an infinite stream, the original stream
  is an infinite "@{term t}"-stream *}
lemma stakewhile_sinftimesup: 
  "#(stakewhile (\<lambda>p. p = t)\<cdot>z) = \<infinity> \<Longrightarrow> z = sinftimes (\<up>t)"
apply (rule stream.take_lemma)
by (rule stakewhile_sinftimes_lemma [rule_format])

(* ----------------------------------------------------------------------- *)
subsection {* @{term sdropwhile} *}
(* ----------------------------------------------------------------------- *)

text {* basic properties for @{term sdropwhile} *}

lemma strict_sdropwhile[simp]: "sdropwhile f\<cdot>\<epsilon> = \<epsilon>"
by (subst sdropwhile_def [THEN fix_eq2], simp)

(* if the head a passes the predicate f, then the result of sdropwhile will drop the head *)
lemma sdropwhile_t[simp]: "f a \<Longrightarrow> sdropwhile f\<cdot>(\<up>a \<bullet> s) = sdropwhile f\<cdot>s"
by (subst sdropwhile_def [THEN fix_eq2], simp)

(* if the head a fails the predicate f, then the result of sdropwhile will start with \<up>a *)
lemma sdropwhile_f[simp]: "\<not>f a \<Longrightarrow> sdropwhile f\<cdot>(\<up>a \<bullet> s) = \<up>a \<bullet> s"
by (subst sdropwhile_def [THEN fix_eq2], simp)

(* if the only element in a singleton stream passes the predicate f, then sdropwhile will produce
   the empty stream *)
lemma [simp]: "f a \<Longrightarrow> sdropwhile f\<cdot>(\<up>a) = \<epsilon>"
by (subst sdropwhile_def [THEN fix_eq2], simp)

(* if the only element in a singleton stream fails the predicate f, then sdropwhile will be a no-op *)
lemma [simp]: "\<not>f a \<Longrightarrow> sdropwhile f\<cdot>(\<up>a) = \<up>a"
by (subst sdropwhile_def [THEN fix_eq2], simp)

text {* special cases of @{term sfilter} after @{term sdropwhile} *}

(* the elements removed by sdropwhile are a subset of the elements removed by sfilter *)
lemma sfilter_dwl1[simp]: 
  "sfilter X\<cdot>(sdropwhile (\<lambda>x. x\<notin>X)\<cdot>p) = sfilter X\<cdot>p"
apply (rule ind [of _ p], auto)
by (case_tac "a\<in>X", auto)

(* the elements kept by sfilter are a subset of the elements kept by sdropwhile *)
lemma sfilter_dwl2:
  "sfilter T\<cdot>s \<noteq> \<epsilon> \<Longrightarrow> sdropwhile (\<lambda>a. a \<notin> T)\<cdot>s \<noteq> \<epsilon>"
apply (rule notI)
apply (erule notE)
apply (subst sfilter_dwl1 [THEN sym])
by simp

text {* Construct @{term stwbl} from @{term stakewhile}, @{term stake} and @{term sdropwhile} *}
lemma stwbl_stakewhile: "stwbl f\<cdot>s = stakewhile f\<cdot>s \<bullet> (stake (Suc 0)\<cdot>(sdropwhile f\<cdot>s))"
apply (rule stream.take_lemma)
apply (rule_tac x="s" in spec)
apply (induct_tac n, simp+)
apply (rule allI)
apply (rule_tac x="x" in scases, simp+)
by (case_tac "f a", simp+)

text {* Constructing @{term sdropwhile} from @{term stakewhile} and @{term sdrop} *}
lemma stakewhile_sdropwhilel1:
  "\<forall>x. #(stakewhile f\<cdot>x) = Fin n \<longrightarrow> sdropwhile f\<cdot>x = sdrop n\<cdot>x"  
apply (induct_tac n, auto)
apply (rule_tac x=x in scases, auto)
apply (case_tac "f a", auto)
apply (rule_tac x=x in scases, auto)
by (case_tac "f a", auto)

text {* @{term sdropwhile} is idempotent *}
lemma sdropwhile_idem: "sdropwhile f\<cdot>(sdropwhile f\<cdot>x) = sdropwhile f\<cdot>x"
apply (rule ind [of _ x], auto)
by (case_tac "f a", auto)

text {* @{term stakewhile} after @{term sdropwhile} gives the empty stream *}
lemma tdw[simp]: "stakewhile f\<cdot>(sdropwhile f\<cdot>s) = \<epsilon>"
apply (rule ind [of _ s], auto)
by (case_tac "f a", auto)

text {* For the head of @{term "sdropwhile f\<cdot>x"}, @{term f} does not hold *}
lemma sdropwhile_resup: "sdropwhile f\<cdot>x = \<up>a \<bullet> s \<Longrightarrow> \<not> f a"
apply (subgoal_tac "sdropwhile f\<cdot>(\<up>a \<bullet> s) = \<up>a \<bullet> s")
apply (case_tac "f a", auto)
apply rotate_tac
apply (drule cfun_arg_cong [of _ _ "stakewhile f"], simp)
apply (drule sym, simp)
by (rule sdropwhile_idem)

text {* elimination rule for @{term sfilter} after @{term sdropwhile} *}
lemma sfilter_srtdwl3[simp]: 
  "sfilter X\<cdot>(srt\<cdot>(sdropwhile (\<lambda>x. x\<notin>X)\<cdot>p)) = srt\<cdot>(sfilter X\<cdot>p)"
apply (rule ind [of _ p], auto)
by (case_tac "a\<in>X", auto)

text {* Further results concerning @{term sfilter} *}

text {* After filtering by filter @{term T}, the head of the result is in @{term T}
  (for non-empty results) *}
lemma sfilter_ne_resup: "sfilter T\<cdot>s \<noteq> \<epsilon> \<Longrightarrow> shd (sfilter T\<cdot>s) \<in> T"
apply (subst sfilter_dwl1 [THEN sym])
apply (rule_tac x="sdropwhile (\<lambda>x. x \<notin> T)\<cdot>s" in scases, auto)
apply (drule sfilter_dwl2, simp)
apply (rule_tac x="s" in scases, auto)
apply (case_tac "aa \<in> T", auto)
apply (drule inject_scons, simp)
by (drule sdropwhile_resup, simp)

text {* same result for @{term sconc} syntax *}
lemma sfilter_resl2:
  "sfilter T\<cdot>s = \<up>a \<bullet> as \<Longrightarrow> a \<in> T"
apply (case_tac "sfilter T\<cdot>s = \<epsilon>", simp)
by (drule sfilter_ne_resup, simp)

text {* After filtering with filter @{term T}, each element is in @{term T} *}
lemma sfilterl7:
  "\<lbrakk>Fin n < #x; sfilter T\<cdot>s = x\<rbrakk> \<Longrightarrow> snth n x \<in> T"
apply (simp add: atomize_imp)
apply (rule_tac x="s" in spec)
apply (rule_tac x="x" in spec)
apply (induct_tac n, auto)
apply (rule sfilter_ne_resup)
apply (rule_tac x="sfilter T\<cdot>xa" in scases, auto)
apply (rule_tac x="xa" in scases, auto)
apply (simp add: Fin_Suc [THEN sym] del: Fin_Suc)
apply (case_tac "a \<in> T", auto)
apply (case_tac "sfilter T\<cdot>s = \<epsilon>",simp+)
apply (simp add: Fin_Suc [THEN sym] del: Fin_Suc)
apply (rule_tac x="sfilter T\<cdot>s" in scases, auto)
apply (erule_tac x="sa" in allE,simp+)
apply (frule sfilter_resl2)
apply (drule mp)
by (rule_tac x="srt\<cdot>(sdropwhile (\<lambda>x. x\<notin>T)\<cdot>s)" in exI,simp+)

(* ----------------------------------------------------------------------- *)
subsection {* @{term srtdw} *}
(* ----------------------------------------------------------------------- *)

text {* basic properties of @{term srtdw} *}

lemma [simp]: "srtdw f\<cdot>\<epsilon> = \<epsilon>"
by (simp add: srtdw_def)

(* the rest of any singleton stream is the empty stream, regardless of whether the only element in
   the stream was dropped *)
lemma [simp]: "srtdw f\<cdot>(\<up>a) = \<epsilon>"
apply (simp add: srtdw_def)
by (case_tac "f a", auto)

(* if the head a passes the predicate f, srtdw will drop the head *)
lemma [simp]: "f a \<Longrightarrow> srtdw f\<cdot>(\<up>a\<bullet>as) = srtdw f\<cdot>as"
by (auto simp add: srtdw_def)

(* if the head a fails the predicate f, srtdw will produce the rest of the stream *)
lemma [simp]: "\<not> f a \<Longrightarrow> srtdw f\<cdot>(\<up>a\<bullet>as) = as"
by (simp add: srtdw_def)

text {* @{term "sfilter M"} after @{term "srtdw (\<lambda>x. x \<notin> M)"} almost behaves
  like @{term "sfilter M"} alone *}
lemma sfilterl8:
  "sfilter M\<cdot>x \<noteq> \<epsilon> \<Longrightarrow>
    #(sfilter M\<cdot>x) = lnsuc\<cdot>(#(sfilter M\<cdot>(srtdw (\<lambda>x. x \<notin> M)\<cdot>x)))"
apply (simp add: atomize_imp)
apply (rule ind [of _ x], simp+)
apply (rule impI)
by (case_tac "a \<in> M", simp+)

text {* similar result for infinite streams *}
lemma sfilter_srtdwl2:
  "#(sfilter X\<cdot>s) = \<infinity> \<Longrightarrow> #(sfilter X\<cdot>(srtdw (\<lambda>a. a \<notin> X)\<cdot>s)) = \<infinity>"
apply (case_tac "sfilter X\<cdot>s = \<epsilon>", auto)
by (drule sfilterl8, auto)

text {* streams can be split by @{term stwbl} and @{term srtdw} *}
lemma stwbl_srtdw: "stwbl f\<cdot>s \<bullet> srtdw f\<cdot>s = s"
apply (rule stream.take_lemma)
apply (rule_tac x="s" in spec)
apply (induct_tac n, simp+)
apply (rule allI)
apply (rule_tac x="x" in scases, simp+)
by (case_tac "f a", simp+)

lemma slen_srtdw: "#(srtdw f\<cdot>x) \<le> #x"
apply (rule ind [of _ x])
apply (subst lnle_conv [THEN sym], simp del: lnle_conv, simp)
apply (case_tac "f a", simp+)
by (rule trans_lnle, simp+)

(* ----------------------------------------------------------------------- *)
subsection {* @{term srcdups} *}
(* ----------------------------------------------------------------------- *)

text {* Basic simplification rules for @{term srcdups} *}

lemma strict_srcdups[simp]: "srcdups\<cdot>\<epsilon> = \<epsilon>" 
by (subst srcdups_def [THEN fix_eq2], simp)

(* a singleton stream can't possibly contain duplicates *)
lemma [simp]: "srcdups\<cdot>(\<up>a) = \<up>a"
by (subst srcdups_def [THEN fix_eq2], simp)

(* if the head a of a stream is followed by a duplicate, only one of the two elements will be kept by srcdups *)
lemma srcdups_eq[simp]: "srcdups\<cdot>(\<up>a\<bullet>\<up>a\<bullet>s) = srcdups\<cdot>(\<up>a\<bullet>s)" 
apply (subst srcdups_def [THEN fix_eq2], simp)
by (rule sym, subst srcdups_def [THEN fix_eq2], simp)

(* if the head a of a stream is followed by a distinct element, both elements will be keypt by srcdups *)
lemma srcdups_neq[simp]: 
  "a\<noteq>b \<Longrightarrow> srcdups\<cdot>(\<up>a \<bullet> \<up>b \<bullet> s) = \<up>a \<bullet>  srcdups\<cdot>(\<up>b \<bullet> s)" 
by (subst srcdups_def [THEN fix_eq2], simp)

(* ----------------------------------------------------------------------- *)
subsection {* @{term sscanl} *}
(* ----------------------------------------------------------------------- *)

lemma SSCANL_empty[simp]: "SSCANL n f q \<epsilon> = \<epsilon>"
by (induct_tac n, auto)

text {* monotonicity of SSCANL *}
lemma mono_SSCANL: 
  "\<forall> x y q. x \<sqsubseteq> y \<longrightarrow> SSCANL n f q x \<sqsubseteq> SSCANL n f q y"
apply (induct_tac n, auto)
apply (drule lessD, erule disjE, simp)
apply (erule exE)+
apply (erule conjE)+
by (simp, rule monofun_cfun_arg, simp)

text {* result of @{term "SSCANL n"} only depends on first @{term n}
  elements of input stream *}
lemma contlub_SSCANL:
  "\<forall>f q s. SSCANL n f q s = SSCANL n f q (stake n\<cdot>s)"
apply (induct_tac n, auto)
apply (rule_tac x=s in scases)
apply auto
apply (rule_tac x=s in scases)
by auto

text {* @{term SSCANL} is a chain. This means that, for all fixed inputs,
  @{term "SSCANL i"} returns a prefix of @{term "SSCANL (Suc i)"} *}
lemma chain_SSCANL: "chain SSCANL"
apply (rule chainI)
apply (subst fun_below_iff)+
apply (induct_tac i, auto)
apply (rule monofun_cfun_arg)
apply (erule_tac x="x" in allE)
apply (erule_tac x="x xa (shd xb)" in allE)
by (erule_tac x="srt\<cdot>xb" in allE, auto)

text {* @{term sscanl} is a continuous function *}
lemma cont_lub_SSCANL: "cont (\<lambda>s. \<Squnion>i. SSCANL i f q s)" 
apply (rule cont2cont_lub)
apply (rule ch2ch_fun)
apply (rule chainI)
apply (rule fun_belowD [of _ _ "q"])
apply (rule fun_belowD [of _ _ "f"])
apply (rule chainE)
apply (rule chain_SSCANL)
apply (rule pr_contI)
apply (rule monofunI)
apply (rule mono_SSCANL [rule_format], assumption)
apply (rule allI)
apply (rule_tac x="i" in exI)
by (rule contlub_SSCANL [rule_format])

text {* Basic simplification rules for @{term sscanl} *}

lemma sscanl_empty[simp]: "sscanl f q\<cdot>\<epsilon> = \<epsilon>"
apply (simp add: sscanl_def)
apply (subst beta_cfun, rule cont_lub_SSCANL)
by (subst is_lub_const 
  [THEN lub_eqI, of "\<epsilon>", THEN sym], simp)

(* scanning \<up>a\<bullet>s using q as the initial element is equivalent to computing \<up>(f q a) and appending the
   result of scanning s with (f q a) as the initial element *)
lemma sscanl_scons[simp]: 
  "sscanl f q\<cdot>(\<up>a\<bullet>s) = \<up>(f q a) \<bullet> sscanl f (f q a)\<cdot>s"  
apply (simp add: sscanl_def)
apply (subst beta_cfun, rule cont_lub_SSCANL)+
apply (subst contlub_cfun_arg)
apply (rule ch2ch_fun, rule ch2ch_fun)
apply (rule chainI)
apply (rule fun_belowD [of _ _ "f"])
apply (rule chain_SSCANL [THEN chainE])
apply (subst lub_range_shift [where j="Suc 0", THEN sym])
apply (rule ch2ch_fun, rule ch2ch_fun)
apply (rule chainI)
apply (rule fun_belowD [of _ _ "f"])
by (rule chain_SSCANL [THEN chainE], simp)

(* scanning a singleton stream is equivalent to computing \<up>(f a b) *)
lemma [simp]: "sscanl f a\<cdot>(\<up>b) = \<up>(f a b)"
by (insert sscanl_scons [of f a b \<epsilon>], auto)

text {* applying @{term sscanl} never shortens the stream *}
lemma fair_sscanl: "#x \<le> #(sscanl f a\<cdot>x)"
apply (rule spec [where x = a])
apply (rule ind [of _ x], auto)
by (subst lnle_def, simp del: lnle_conv)

(* ----------------------------------------------------------------------- *)
subsection {* @{term szip} *}
(* ----------------------------------------------------------------------- *)

text {* Basic simplification rules of @{term szip} *}

lemma strict_szip_fst[simp]: "szip\<cdot>\<epsilon>\<cdot>s = \<epsilon>"
by (subst szip_def [THEN fix_eq2],simp)

lemma strict_szip_snd[simp]: "szip\<cdot>s\<cdot>\<epsilon> = \<epsilon>"
by (subst szip_def [THEN fix_eq2], simp)

lemma szip_scons[simp]: "szip\<cdot>(\<up>a\<bullet>s1)\<cdot>(\<up>b\<bullet>s2) = \<up>(a,b) \<bullet> (szip\<cdot>s1\<cdot>s2)"
by (subst szip_def [THEN fix_eq2], simp)

lemma [simp]: "szip\<cdot>(\<up>a)\<cdot>(\<up>b \<bullet> y) = \<up>(a,b)"
by (subst szip_def [THEN fix_eq2], simp)

lemma [simp]: "szip\<cdot>(\<up>a \<bullet> x)\<cdot>(\<up>b) = \<up>(a,b)"
by (subst szip_def [THEN fix_eq2], simp)

lemma [simp]: "szip\<cdot>(\<up>a)\<cdot>(\<up>b) = \<up>(a,b)"
by (subst szip_def [THEN fix_eq2], simp)

text {* If @{term szip} returns an empty stream, an input stream was empty *}
lemma strict_rev_szip: "szip\<cdot>x\<cdot>y = \<epsilon> \<Longrightarrow> x = \<epsilon> \<or> y = \<epsilon>"
apply (rule_tac x=x in scases, auto)
by (rule_tac x=y in scases, auto)

text {* @{term sprojfst} and @{term sprojsnd} are "inverse" functions of
  @{term szip} - if the other zipped stream is infinite *}

lemma sprojfst_szipl1[rule_format]: 
  "\<forall>x. #x = \<infinity> \<longrightarrow> sprojfst\<cdot>(szip\<cdot>i\<cdot>x) = i"
apply (rule ind [of _ i], auto)
by (rule_tac x=x in scases, auto)

lemma sprojsnd_szipl1[rule_format]: 
  "\<forall>x. #x = \<infinity> \<longrightarrow> sprojsnd\<cdot>(szip\<cdot>x\<cdot>i) = i"
apply (rule ind [of _ i], auto)
by (rule_tac x=x in scases, auto)

(* ----------------------------------------------------------------------- *)
subsection {* @{term siterate} *}
(* ----------------------------------------------------------------------- *)

text {* @{term siterate} is defined by running @{term sscanl} on an arbitrary
  infinite stream. Only the stream length is relevant for the result *}
lemma siterate_inv_lemma:
  "\<forall>x z a. #z = #x 
     \<longrightarrow> stake n\<cdot>(sscanl (\<lambda>a b. f a) a\<cdot>x) = 
        stake n\<cdot>(sscanl (\<lambda>a b. f a) a\<cdot>z)"
apply (induct_tac n, auto)
apply (rule_tac x=x in scases, auto)
by (rule_tac x=z in scases, auto)

text {* @{term siterate} is well-defined (because it is independent of
  the infinite stream on which @{term sscanl} is applied) *}
lemma siterate_def2:
  "#x = \<infinity> \<Longrightarrow> siterate f a = \<up>a \<bullet> sscanl (\<lambda>a b. f a) a\<cdot>x"
apply (subst siterate_def)
apply (rule someI2_ex)
apply (rule_tac x="sinftimes (\<up>(SOME a. True))" in exI, simp)
apply (rule cfun_arg_cong)
apply (rule stream.take_lemma)
by (rule siterate_inv_lemma [rule_format], simp)

text {* unfolding of @{term siterate} definition *}
lemma siterate_scons: "siterate f a = \<up>a \<bullet> siterate f (f a)"
apply (rule stream.take_lemma [OF spec [where x="a"]])
apply (induct_tac n, auto)
apply (insert siterate_def2 [of _ f], atomize)
apply (erule_tac x="sinftimes (\<up>x)" in allE, auto)
by (subst sinftimes_unfold, simp)

text {* Addition of two numbers using @{term "siterate Suc"} *}

lemma snth_siterate_Suc: "snth k (siterate Suc j) = k + j"
apply (rule_tac x="j" in spec)
apply (induct_tac k, simp)
apply (rule allI)
by (subst siterate_scons, simp)+

lemma snth_siterate_Suc_0[simp]: "snth k (siterate Suc 0) = k"
by (simp add: snth_siterate_Suc)

lemma sdrop_siterate:
  "sdrop k\<cdot>(siterate Suc j) = siterate Suc (j + k)"
apply (rule_tac x="j" in spec)
apply (induct_tac k, simp+)
apply (rule allI)
by (subst siterate_scons, simp)

text {* @{term siterate} only creates infinite outputs *}
lemma [simp]: "#(siterate f k) = \<infinity>"
apply (rule infI)
apply (rule allI)
apply (rule_tac x="k" in spec)
apply (induct_tac k, simp+)
by (subst siterate_scons, simp)+

(* ----------------------------------------------------------------------- *)
subsection {* @{term sdom} *}
(* ----------------------------------------------------------------------- *)

text {* A stream and its prefix agree on their first elements *}
lemma snth_less: "\<lbrakk>Fin n < #x; x \<sqsubseteq> y\<rbrakk> \<Longrightarrow> snth n x = snth n y"
apply (simp add: atomize_imp)
apply (rule_tac x="x" in spec)
apply (rule_tac x="y" in spec)
apply (induct_tac n, auto)
by (drule lessD, auto)+


text {* monotonicity of @{term sdom} *}
lemma sdom_mono: "monofun (\<lambda>x. {z. \<exists>n. Fin n < #x \<and> z = snth n x})"
apply (rule monofunI)
apply (rule_tac x="#x" in lncases)
apply (drule eq_less_and_fst_inf, simp+)
apply (simp add: atomize_imp)
apply (rule_tac x="y" in spec)
apply (rule_tac x="x" in spec)
apply (induct_tac k, simp+)
apply (auto simp add: less_set_def)
apply (drule lessD, auto)
apply (erule_tac x="q" in allE)
apply (erule_tac x="w" in allE, auto)
apply (case_tac "na", auto)
apply (rule_tac x="0" in exI, auto)
apply (frule_tac f="slen" in monofun_cfun_arg, simp)
apply (rule_tac x="Suc nat" in exI, auto)
apply (rule_tac x="#w" in lncases, auto)
by (rule snth_less, auto)

text {* In infinite chains, the length of the streams is unbounded *}
lemma inf_chainl3rf:
  "\<lbrakk>chain Y; \<not>finite_chain Y\<rbrakk> \<Longrightarrow> \<exists>k. Fin n \<le> #(Y k)"
by (rule inf_chainl3 [rule_format], auto)


text {* @{term sdom} is a continuous function *}
lemma sdom_cont: "cont (\<lambda>s. {z. \<exists>n. Fin n < #s \<and> z = snth n s})"
apply (rule contI2)
apply (rule sdom_mono)
apply (rule allI, rule impI)
apply (simp add: less_set_def)
apply (auto simp add: lub_eq_Union) 
apply (case_tac "finite_chain Y")
apply (subst lub_finch2 [THEN lub_eqI], simp)
apply (rule_tac x="LEAST i. max_in_chain i Y" in exI)
apply (rule_tac x="n" in exI, simp)
apply (subst lub_finch2 [THEN lub_eqI, THEN sym], simp+)
apply (frule_tac n="Suc n" in inf_chainl3rf, simp+)
apply (erule exE)
apply (rule_tac x="k" in exI)
apply (rule_tac x="n" in exI)
apply (rule conjI)
apply (rule_tac x="#(Y k)" in lncases, simp+)
apply (rule sym)
apply (rule snth_less)
apply (rule_tac x="#(Y k)" in lncases, simp+)
by (rule is_ub_thelub)

text {* @{term sdom} is a continuous function *}
lemma sdom_def2: "sdom\<cdot>s = {z. \<exists>n. Fin n < #s \<and> z = snth n s}"
apply (subst sdom_def)
apply (subst beta_cfun)
by (rule sdom_cont, simp)

lemma sdom_cont2: "\<forall>Y. chain Y \<longrightarrow> sdom\<cdot>(\<Squnion> i. Y i) = (\<Squnion> i. sdom\<cdot>(Y i))"
by (simp add: contlub_cfun_arg)

text {* Basic properties of @{term sdom} *}

lemma [simp]: "sdom\<cdot>\<epsilon> = {}"
by (auto simp add: sdom_def2 lnless_def)

(* the head of any stream is always an element of the domain *)
lemma sdom2un[simp]: "sdom\<cdot>(\<up>z \<bullet> s) = {z} \<union> sdom\<cdot>s"
apply (auto simp add: sdom_def2)
apply (case_tac "n", auto)
apply (rule_tac x="0" in exI, auto)
by (rule_tac x="Suc n" in exI, auto)

(* only the empty stream has no elements in its domain *)
lemma strict_sdom_rev: "sdom\<cdot>s = {} \<Longrightarrow> s = \<epsilon>"
apply (auto simp add: sdom_def2)
apply (rule_tac x="s" in scases, auto)
apply (erule_tac x="a" in allE)
by (erule_tac x="0" in allE, auto)

(* the infinite repetition of a only has a in its domain *)
lemma [simp]: "sdom\<cdot>(sinftimes (\<up>a)) = {a}"
apply (auto simp add: sdom_def2)
apply (induct_tac n, auto)
apply (subst sinftimes_unfold, simp)
apply (subst sinftimes_unfold, simp)
apply (rule_tac x="0" in exI)
by (subst sinftimes_unfold, simp)

(* any singleton stream of z only has z in its domain *)
lemma [simp]: "sdom\<cdot>(\<up>z) = {z}"
by (auto simp add: sdom_def2)

(* if an element z is in the domain of a stream s, then z is the n'th element of s for some n *)
lemma sdom2snth: "z \<in> sdom\<cdot>s \<Longrightarrow> \<exists>n. snth n s = z"
by (auto simp add: sdom_def2)

(* if the natural number n is less than the length of the stream s, then snth n s is in the domain of s *)
lemma snth2sdom: "Fin n < #s \<Longrightarrow> snth n s \<in> sdom\<cdot>s"
by (auto simp add: sdom_def2)

(* checking if the domain of a stream x isn't a subset of another set M is an admissible predicate *)
lemma [simp]: "adm (\<lambda>x. \<not> sdom\<cdot>x \<subseteq> M)"
apply (rule admI)
apply (rule notI)
apply (frule_tac x="0" in is_ub_thelub)
apply (frule_tac f="sdom" in monofun_cfun_arg)
by (erule_tac x="0" in allE, auto simp add: less_set_def)

text {* filtering with a superset of the stream's domain does not change the stream *}
lemma sfilter_sdoml3:
  "sdom\<cdot>s \<subseteq> X \<longrightarrow> sfilter X\<cdot>s = s"
apply (rule impI)
apply (rule stream.take_lemma)
apply (simp add: atomize_imp)
apply (rule_tac x="s" in spec)
apply (rule_tac x="X" in spec)
apply (induct_tac n, simp+)
apply (rule allI)+
apply (rule impI)
by (rule_tac x="xa" in scases, simp+)

text {* filtering with the stream's domain does not change the stream *}
lemma sfilter_sdoml4 [simp]:
  "sfilter (sdom\<cdot>s)\<cdot>s = s"
by (rule sfilter_sdoml3 [rule_format, of "s" "sdom\<cdot>s"], simp)

text {* The domain of a concatenated stream is the union of the single domains *}
lemma sdom_sconc2un:
  "#x = Fin k \<Longrightarrow> sdom\<cdot>(x \<bullet> y) = sdom\<cdot>x \<union> sdom\<cdot>y"
apply (simp add: atomize_imp)
apply (rule_tac x="x" in spec)
apply (induct_tac k, simp+)
apply (rule allI, rule impI)
by (rule_tac x="x" in scases, simp+)

(* if filtering everything except z from the stream x doesn't produce the empty stream, then z must
   be an element of the domain of x *)
lemma sfilter2dom:
  "sfilter {z}\<cdot>x \<noteq> \<epsilon> \<Longrightarrow> z \<in> sdom\<cdot>x"
apply (subgoal_tac "\<exists>k. snth k x = z \<and> Fin k < #x", erule exE)
apply (erule conjE)
apply (drule sym, simp)
apply (rule snth2sdom, simp)
apply (rule ccontr, simp)
by (insert ex_snth_in_sfilter_nempty [of x "{z}"], auto)

text {* For injective functions @{term f} with @{term "f(y) = x"}, @{term x} can only
  be contained in @{term "smap f\<cdot>s"} if the original stream contained @{term y} *}
lemma sdom_smapl1: "\<lbrakk>x \<in> sdom\<cdot>(smap f\<cdot>s); inj f; f y = x\<rbrakk> \<Longrightarrow> y \<in> sdom\<cdot>s" 
apply (auto simp add: sdom_def2)
apply (rule_tac x="n" in exI, simp)
apply (simp add: smap_snth_lemma)
by (simp add: inj_on_def)

(* ----------------------------------------------------------------------- *)
subsection {* @{term sislivespf} *}
(* ----------------------------------------------------------------------- *)

text {* Some different formulations and implications of the @{term sislivespf} definition *}

lemma sislivespfI:
  "(\<And>x. #(f\<cdot>x) = \<infinity> \<Longrightarrow> #x = \<infinity>) \<Longrightarrow> sislivespf f"
by (simp add: sislivespf_def)

lemma sislivespfI2:
  "(\<And>k. \<forall>x. #x = Fin k \<longrightarrow> #(f\<cdot>x) \<noteq> \<infinity>) \<Longrightarrow> sislivespf f"
apply (rule sislivespfI)
by (rule_tac x="#x" in lncases, simp+)

lemma sislivespfD1:
  "\<lbrakk>sislivespf f; #x = Fin k\<rbrakk> \<Longrightarrow> #(f\<cdot>x) \<noteq> \<infinity>"
apply (rule notI)
by (simp add: sislivespf_def)

lemma sislivespfD2:
  "\<lbrakk>sislivespf f; #(f\<cdot>x) = \<infinity>\<rbrakk> \<Longrightarrow> #x = \<infinity>"
by (simp add: sislivespf_def)

(* ----------------------------------------------------------------------- *)
section {* Lemmas on lists and streams *}
(* ----------------------------------------------------------------------- *)

(* ----------------------------------------------------------------------- *)
subsection {* @{term list2s} *}
(* ----------------------------------------------------------------------- *)

(* consing onto a list is equivalent to prepending an element to a stream *)
lemma [simp]: "list2s (a#as) = \<up>a \<bullet> list2s as"
by (simp add: lscons_conv)

declare list2s_Suc [simp del]

(* infinite lists don't exist *)
lemma [simp]: "#(list2s x) \<noteq> \<infinity>"
by (induct x, simp+)

text {* Every finite stream can be converted to a list *}
lemma s2list_ex: 
  "#s = Fin k \<Longrightarrow> \<exists>l. list2s l = s"
apply (simp add: atomize_imp)
apply (rule_tac x="s" in spec)
apply (induct_tac k, simp+)
apply (rule_tac x="[]" in exI, simp+)
apply (rule allI, rule impI)
apply (rule_tac x="x" in scases, simp+)
apply (erule_tac x="s" in allE)
apply (drule mp)
apply (simp add: Fin_Suc [THEN sym] del: Fin_Suc)
apply (erule exE)
by (rule_tac x="a # l" in exI, simp)

(* the empty stream corresponds to the empty list *)
lemma [simp]: "s2list \<epsilon> = []"
apply (simp add: s2list_def)
apply (rule someI2_ex)
apply (rule_tac x="[]" in exI, simp)
apply (simp add: atomize_imp)
by (induct_tac x, simp+)

(* the singleton stream corresponds to the singleton list *)
lemma [simp]: "s2list (\<up>a) = [a]"
apply (simp add: s2list_def)
apply (rule someI2_ex)
apply (rule_tac x="[a]" in exI, simp)
apply (simp add: atomize_imp)
apply (induct_tac x, auto)
by (case_tac "list", simp+)

(* the empty list is the bottom element for lists *)
lemma [simp]: "[] \<sqsubseteq> l"
by (simp add: sq_le_list)

text {* The prefix relation translates from lists to streams *}
lemma list2s_emb: "\<lbrakk>#s \<noteq> \<infinity>; #s' \<noteq> \<infinity>\<rbrakk> \<Longrightarrow> (s2list s \<sqsubseteq> s2list s') = (s \<sqsubseteq> s')"
apply (simp add: s2list_def)
apply (rule someI2_ex)
apply (rule_tac x="#s'" in lncases, simp) 
apply (frule s2list_ex, simp)
apply (rule someI2_ex)
apply (rule_tac x="#s" in lncases, simp) 
apply (frule s2list_ex, simp)
apply (rule iffI)
apply (drule sym, drule sym, simp)
apply (simp add: sq_le_list)
by (simp add: sq_le_list)

text {* @{term list2s} is monotone *}
lemma list2s_mono: "l \<sqsubseteq> l' \<Longrightarrow> list2s l \<sqsubseteq> list2s l'"
by (simp add: sq_le_list)

text {* Prepending a fixed element to a list is a monotone function *}
lemma monofun_lcons: "monofun (\<lambda>l. a # l)"
apply (rule monofunI)
apply (simp add: atomize_imp)
apply (rule_tac x="a" in spec)
apply (induct_tac x, simp+)
apply (rule allI)
apply (simp add: sq_le_list)
apply (rule allI)
apply (rule impI)
apply (simp add: sq_le_list)
by (rule monofun_cfun_arg, simp)

text {* Head and rest on streams translate to head and rest on lists *}
lemma s2list2lcons: "#s \<noteq> \<infinity> \<Longrightarrow> s2list (\<up>a \<bullet> s) = a # (s2list s)"
apply (rule_tac x="#s" in lncases, simp+)
apply (simp add: atomize_imp)
apply (rule_tac x="s" in spec)
apply (rule_tac x="a" in spec)
apply (induct_tac k, simp+)
apply (rule allI,rule allI, rule impI)
apply (rule_tac x="xa" in scases, simp+)
apply (simp add: s2list_def)
apply (rule someI2_ex)
apply (frule s2list_ex, simp)
apply (rule someI2_ex)
apply (frule s2list_ex)
apply (erule exE)
apply (rule_tac x="x#a#l" in exI, simp+)
by (rule list2s_inj [THEN iffD1], simp)

text {* @{term s2list} is left-inverse to @{term list2s} *}
lemma [simp]: "s2list (list2s l) = l"
apply (induct_tac l, simp+)
by (subst s2list2lcons, simp+)

text {* Evaluation of @{term list2s} from right to left *}
lemma slistl5[simp]: "list2s (l @ [m]) = list2s l \<bullet> \<up>m"
by (induct_tac l, simp+)

(* ----------------------------------------------------------------------- *)
subsection {* List- and stream-processing functions *}
(* ----------------------------------------------------------------------- *)

text {* Monotone list-processing functions induce monotone stream-processing functions
  by applying them to the stream's k-element prefix *}
lemma mono_slpf2spf:
  "monofun f \<Longrightarrow> monofun (\<lambda>s. list2s (f (s2list (stake k\<cdot>s))))"
apply (rule monofunI)
apply (simp add: atomize_imp)
apply (rule_tac x="y" in spec)
apply (rule_tac x="x" in spec)
apply (induct_tac k, simp+)
apply (rule impI)
apply (drule mp, assumption)
apply (rule allI)+
apply (rule impI)
apply (drule lessD, simp)
apply (erule disjE, simp)
apply (rule list2s_mono)
apply (rule_tac f="f" in monofunE,simp+)
apply (erule exE)+
apply (erule conjE)
apply (erule exE,simp)
apply (erule conjE)
apply (rule list2s_mono)
apply (rule_tac f="f" in monofunE,simp+)
apply (rule_tac x="xa" in scases,simp)
apply (subst list2s_emb,simp+)
apply (rule monofun_cfun_arg)+
by simp

text {* Applying a monotone list-processing function to the @{term k}-element prefix of a stream
  is monotone with respect to @{term k} *}
lemma chain_slpf2spf:
  "monofun f \<Longrightarrow> list2s (f (s2list (stake i\<cdot>x))) \<sqsubseteq> list2s (f (s2list (stake (Suc i)\<cdot>x)))"
apply (rule list2s_mono)
apply (rule_tac f="f" in monofunE,simp+)
apply (subst list2s_emb,simp+)
by (rule chainE, simp)

text {* Now, a list-processing function is converted to a stream-processing one by building
  the LUB of applying the function to all prefixes of the stream *}
lemma slpf2spfl_contl:
  "monofun f \<Longrightarrow> 
  cont (\<lambda>s. (\<Squnion>k. list2s (f (s2list (stake k\<cdot>s)))))"
apply (rule cont2cont_lub)
apply (rule chainI)
apply (rule chain_slpf2spf, simp)
apply (rule pr_contI) 
apply (rule mono_slpf2spf, assumption) 
apply (rule allI)
by (rule_tac x="k" in exI, simp)

text {* The output function of @{term slpf2spf} is continuous *}
lemma slpf2spf_cont:
  "monofun f \<Longrightarrow> 
     (\<Lambda> s. (\<Squnion>k. list2s (f (s2list (stake k\<cdot>s)))))\<cdot>s = (\<Squnion>k. list2s (f (s2list (stake k\<cdot>s))))"
apply (subst beta_cfun)
by (rule slpf2spfl_contl, assumption, simp)

text {* Applying @{term "slpf2spf f"} to an element @{term x} *}
lemma slpf2spf_def2:
  "monofun f \<Longrightarrow> slpf2spf f\<cdot>x = (\<Squnion>k. list2s (f (s2list (stake k\<cdot>x))))"
apply (simp add: slpf2spf_def)
by (rule slpf2spf_cont)

text {* The output of @{term slpf2spf} is live *}
lemma sislivespf_slpf2spf:
  "monofun f \<Longrightarrow> sislivespf (slpf2spf f)"
apply (rule sislivespfI)
apply (rule_tac x="#x" in lncases, assumption)
apply (simp add: slpf2spf_def2)
apply (subgoal_tac 
  "finite_chain (\<lambda>k. list2s (f (s2list (stake k\<cdot>x))))")
apply (simp add: finite_chain_def)
apply (erule conjE, erule exE)
apply (frule lub_finch1, simp+)
apply (frule lub_eqI, simp)
apply (simp add: finite_chain_def, rule conjI)
apply (rule chainI)
apply (rule chain_slpf2spf, assumption)
apply (rule_tac x="k" in exI)
apply (simp add: max_in_chain_def)
apply (rule allI, rule impI)
apply (subgoal_tac "stake j\<cdot>x = stake k\<cdot>x", simp)
apply (subst fin2stake [THEN sym], simp+)
by (simp add: min_def)

text {* Any live stream-processing function can be converted to a monotone
  list-processing function *}
lemma sspf2lpf_mono: 
  "sislivespf f \<Longrightarrow> monofun (sspf2lpf f)"
apply (rule monofunI)
apply (simp add: sspf2lpf_def)
apply (subst list2s_emb)
apply (rule notI, frule sislivespfD2, simp+)+
apply (rule monofun_cfun_arg)
by (simp add: sq_le_list)

text {* The result of applying continuous functions to infinite inputs
  does not change on even longer inputs *}
lemma monofun_spf_ubl[simp]:
  "#(f\<cdot>x) = \<infinity> \<Longrightarrow> f\<cdot>(x \<bullet> y) = f\<cdot>x"
apply (rule sym)
apply (rule eq_less_and_fst_inf [of "f\<cdot>x"])
by (rule monofun_cfun_arg, auto)

text {* Some special results about @{term smap} and injective functions
  on streams of natural successors *}

lemma inj_sfilter_smap_siteratel1:
  "inj f \<Longrightarrow> sfilter {f j}\<cdot>(smap f\<cdot>(siterate Suc (Suc (k + j)))) = \<epsilon>"
apply (rule ex_snth_in_sfilter_nempty [rule_format])
apply (simp add: atomize_imp)
apply (rule impI)
apply (subst smap_snth_lemma, simp+)
apply (simp add: snth_siterate_Suc)
apply (rule notI)
by (frule_tac x="Suc (n+(k+j))" and y="j" in injD, simp+)

(* an element m can't appear infinitely often in a stream produced by mapping an injective function f
   over the natural numbers *)
lemma inj_sfilter_smap_siteratel2[simp]:
  "inj f \<Longrightarrow> #(sfilter {m}\<cdot>(smap f\<cdot>(siterate Suc j))) \<noteq> \<infinity>"
apply (case_tac "m\<in>range f")
apply (rule_tac b="m" and f="f" in rangeE, simp+)
apply (rule notI)
apply (drule_tac n="Suc x" in slen_sfilter_sdrop [rule_format], simp)
apply (simp add: sdrop_siterate)
apply (simp add: inj_sfilter_smap_siteratel1)
by (simp add: sfilter_smap_nrange)


end

