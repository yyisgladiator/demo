section {* Lazy Streams *} 

theory Streams
imports LNat SetPcpo
begin

section {* The Datatype of Lazy Streams *}

default_sort countable

(* deletes the Rule "1 = Suc 0" *)
 declare One_nat_def[simp del]

(* declare [[show_types]] *)

text {* @{text "discr u"} lifts an arbitrary type @{text "'a"} to the
  discrete @{text "pcpo"} and the usual rest operator @{text "rt"} on streams.*}

domain
  'a stream = lscons (lshd::"'a discr u") (lazy srt::"'a stream") 
                                        (infixr "&&" 65)

(* ----------------------------------------------------------------------- *)
section {* Signatures of Stream Processing Functions*}
(* ----------------------------------------------------------------------- *)

text {* Continuous function from stream to stream and shortcut 
for input and output of the same type: *}
type_synonym ('in, 'out) spf = "('in stream \<rightarrow> 'out stream)"
type_synonym 'm spfo      = "('m, 'm) spf"

text {* Same for general SPFs which are not continuous by definition: *}
type_synonym ('in, 'out) gspf = "('in stream \<Rightarrow> 'out stream)"
type_synonym 'm gspfo      = "('m, 'm) gspf"

text {* Again for list processing functions: *}
type_synonym ('in, 'out) lpf = "('in list \<Rightarrow> 'out list)"
type_synonym 'm lpfo      = "('m, 'm) lpf"


(* ----------------------------------------------------------------------- *)
subsection {* Some abbreviations *}
(* ----------------------------------------------------------------------- *)

text {* The empty stream is denoted as @{text "\<epsilon>"}.*}
abbreviation
  sbot ::  "'a stream"  ("\<epsilon>")
    where "sbot \<equiv> \<bottom>"

text {* The @{term "updis"} command lifts an arbitrary type to a
  discrete pointed partial order. *}
abbreviation
  updis :: "'a \<Rightarrow> 'a discr u"
    where "updis \<equiv> (\<lambda>a. up\<cdot>(Discr a))" 

text {* @{term stake}: This operator is generated by the @{text "domain"}
  command. It retrieves the first @{text "n"} elements of a stream
  (or less, if the stream is shorter). *}
abbreviation
  stake :: "nat \<Rightarrow> 'a spfo"
    where "stake \<equiv> stream_take"

(* ----------------------------------------------------------------------- *)
section {* Common functions on streams *}
(* ----------------------------------------------------------------------- *)

text {* Conversion of function with lifted values to a partial function: *}
definition fup2map :: "('a \<Rightarrow> 'b::cpo u) \<Rightarrow> ('a \<rightharpoonup> 'b)" where
"fup2map f a \<equiv> if (f a = \<bottom>) then None else Some (SOME x. up\<cdot>x = f a)" 

text {* @{term sup'}: Construct a stream by a single element. *}
definition sup'       :: "'a \<Rightarrow> 'a stream" ("\<up>_" [1000] 999) where
"sup' a \<equiv> updis a && \<epsilon>"


text {* @{term sconc}: Concatenate two streams over the same type.
  For infinite streams, arbitrary other streams can be appended
  without changing the stream. *}
definition sconc      :: "'a stream \<Rightarrow> 'a spfo" where
"sconc \<equiv> fix\<cdot>(\<Lambda> h. (\<lambda> s1. \<Lambda> s2. 
                      if s1 = \<epsilon> then s2 else  (lshd\<cdot>s1) && (h (srt\<cdot>s1)\<cdot>s2)))"

abbreviation sconc_abbr :: "'a stream \<Rightarrow> 'a stream \<Rightarrow> 'a stream" ("(_ \<bullet> _)" [66,65] 65)
where "s1 \<bullet> s2 \<equiv> sconc s1\<cdot>s2"

text {* @{term shd}: Retrieve the first element of a stream.
  For @{text "\<epsilon>"}, the result is not defined. *}
definition shd        :: "'a stream \<Rightarrow> 'a" where
"shd s \<equiv> THE a. lshd\<cdot>s = updis a"

text {* @{term slookahd}: Apply function to head of stream.
  If the stream is empty, @{text \<bottom>} is returned.
  This function is especially useful for defining own stream-processing
  functions. *}
definition slookahd   :: "'a stream \<rightarrow> ('a \<Rightarrow> 'b) \<rightarrow> ('b::pcpo)" where
"slookahd \<equiv> \<Lambda> s f. if s = \<epsilon> then \<bottom> else f (shd s)"  




(* ----------------------------------------------------------------------- *)
subsection {* Conversion of lists to streams and induced order on lists *}
(* ----------------------------------------------------------------------- *)

text {* Lists can be converted to streams by the function @{term list2s}: *}

primrec list2s :: "'a list \<Rightarrow> 'a stream"
where
  list2s_0:   "list2s [] = \<epsilon>" |
  list2s_Suc: "list2s (a#as) = updis a && (list2s as)"

abbreviation stream_abbrev :: "'a list \<Rightarrow> 'a stream" ("<_>" [1000] 999)
where "<l> == list2s l"

text {* The data type @{text "list"} is a partial order with the operator 
  @{text "\<sqsubseteq>"} derived from streams: *}
instantiation list :: (countable) po
begin

  definition sq_le_list:
    "s \<sqsubseteq> t \<equiv> (list2s s \<sqsubseteq> list2s t)"

  (* list2s is a bijection *)
  lemma list2s_inj[simp]: "(list2s l = list2s l') = (l = l')"
  apply (rule iffI)
  apply (simp add: atomize_imp)
  apply (rule_tac x="l'" in spec)
  apply (induct l, simp)
  apply (rule allI)
  apply (induct_tac x, simp+)
  apply (rule allI)
  by (induct_tac x, simp+)

instance
apply (intro_classes)
apply (simp add: sq_le_list)+
apply (rule_tac y="list2s y" in below_trans,assumption+)
apply (simp add: sq_le_list)
apply (rule list2s_inj [THEN iffD1])
by (rule po_eq_conv [THEN iffD2],rule conjI,assumption+)

end

(* ----------------------------------------------------------------------- *)
text {* Typical functions known from lists:*}
(* ----------------------------------------------------------------------- *)


text {* @{term slen}: Retrieve the length of a stream.
  It is defined as the number of its elements or @{text "\<infinity>"} for inifinite streams. *}
definition slen       :: "'a stream \<rightarrow> lnat" where
"slen \<equiv> fix\<cdot>(\<Lambda> h. strictify\<cdot>(\<Lambda> s. lnsuc\<cdot>(h\<cdot>(srt\<cdot>s))))"

abbreviation slen_abbr :: "'a stream \<Rightarrow> lnat" ("#_" [1000] 999)
where "#s == slen\<cdot>s"

text {* @{term sdrop}: Remove the first @{text "n"} elements
  of the stream. *}
definition sdrop      :: "nat \<Rightarrow> 'a spfo" where
"sdrop n \<equiv> Fix.iterate n\<cdot>srt"

text {* @{term snth}: Get the @{text "n"}th element of the stream. *}
definition snth       :: "nat \<Rightarrow> 'a stream \<Rightarrow> 'a" where
"snth k s \<equiv> shd (sdrop k\<cdot>s)" 

text{* @{term sfoot}: Get the last element of a not empty, finite stream *}
definition sfoot      :: "'a stream \<Rightarrow> 'a" where
"sfoot s = snth (THE a. lnsuc\<cdot>(Fin a) = #s) s"

text {* @{term sdom}: Retrieve the set of all values in a stream. *}
definition sdom       :: "'a stream \<rightarrow> 'a set" where
"sdom \<equiv> \<Lambda> s. {z. \<exists>n. Fin n < #s \<and> z = snth n s}" 

text {* @{term sntimes}: Repeat the given stream @{text "n"} times. *}
text {* (Only listed as a constant below for reference;
  Use @{text "sntimes"} with same signature instead). *}
(* consts sntimes_    :: "nat \<Rightarrow> 'a stream \<Rightarrow> 'a stream" *)

text {* @{term sinftimes}: Concatenate a stream infinitely often to itself. *}
definition sinftimes  :: "'a stream \<Rightarrow> 'a stream" ("_\<infinity>") where
 "sinftimes \<equiv> fix\<cdot>(\<Lambda> h. (\<lambda>s. 
                        if s = \<epsilon> then \<epsilon> else (s \<bullet> (h s))))" 
                      
                        
                        
text {* @{term smap}: Apply a function to all elements of the stream. *}
definition smap       :: "('a \<Rightarrow> 'b) \<Rightarrow> ('a,'b) spf" where
"smap f \<equiv> fix\<cdot>(\<Lambda> h s. slookahd\<cdot>s\<cdot>(\<lambda> a. 
                       \<up>(f a) \<bullet> (h\<cdot>(srt\<cdot>s))))"

text {* @{term sfilter}: Remove all elements from the stream which are
  not included in the given set. *}
definition sfilter    :: "'a set \<Rightarrow> 'a spfo" where
"sfilter M \<equiv> fix\<cdot>(\<Lambda> h s. slookahd\<cdot>s\<cdot>(\<lambda> a. 
                          (if (a \<in> M) then \<up>a \<bullet> (h\<cdot>(srt\<cdot>s)) else h\<cdot>(srt\<cdot>s))))"

text {* @{term stakewhile}: Take the first elements of a stream as
  long as the given function evaluates to @{text "true"}. *}
definition stakewhile :: "('a \<Rightarrow> bool) \<Rightarrow> 'a spfo" where
"stakewhile f \<equiv> fix\<cdot>(\<Lambda> h s. slookahd\<cdot>s\<cdot>(\<lambda> a. if (f a) then \<up>a \<bullet> h\<cdot>(srt\<cdot>s) else \<epsilon>))"

text {* @{term sdropwhile}: Drop the first elements of a stream as
  long as the given function evaluates to @{text "true"}. *}
definition sdropwhile :: "('a \<Rightarrow> bool) \<Rightarrow> 'a spfo" where
"sdropwhile f \<equiv> fix\<cdot>(\<Lambda> h s. slookahd\<cdot>s\<cdot>(\<lambda> a. 
                          if (f a) then h\<cdot>(srt\<cdot>s) else s))"

text {* Two streams can be combined into one stream by using tuples as elements. *}

text {* @{term szip}: Zip two streams into one stream. *}
definition szip       :: "'a stream \<rightarrow> 'b stream \<rightarrow> ('a \<times> 'b) stream" where
 "szip \<equiv> fix\<cdot>(\<Lambda> h s1 s2. slookahd\<cdot>s1\<cdot>(\<lambda> a. slookahd\<cdot>s2\<cdot>(\<lambda> b.
                     \<up>(a,b) \<bullet> (h\<cdot>(srt\<cdot>s1)\<cdot>(srt\<cdot>s2)))))"

text{* Takes a function and 2 streams, merges the 2 streams according to the function *}
definition merge:: "('a  \<Rightarrow> 'b \<Rightarrow> 'c) \<Rightarrow> 'a stream \<rightarrow> 'b stream \<rightarrow> 'c stream" where
"merge f \<equiv> \<Lambda> s1 s2 . smap (\<lambda> s3. f (fst s3) (snd s3))\<cdot>(szip\<cdot>s1\<cdot>s2)"


text {* @{term sprojfst}: Access the first stream of two zipped streams. *}
definition sprojfst   :: "(('a \<times> 'b),'a) spf" where
"sprojfst \<equiv> \<Lambda> x. smap fst\<cdot>x"

text {* @{term sprojsnd}: Access the second stream of two zipped streams. *}
definition sprojsnd   :: "(('a \<times> 'b),'b) spf" where
"sprojsnd \<equiv> \<Lambda> x. smap snd\<cdot>x"

text {* The following two functions are "delayed" variants
  of @{term stakewhile} and @{term sdropwhile}. *}

text {* @{term stwbl}: Take while predicate holds but also keep
  first element violating condition. *}
definition stwbl      :: "('a \<Rightarrow> bool) \<Rightarrow> 'a spfo" where
"stwbl f \<equiv> fix\<cdot>(\<Lambda> h s. slookahd\<cdot>s\<cdot>(\<lambda> a. 
                          if (f a) then \<up>a \<bullet>  h\<cdot>(srt\<cdot>s) else \<up>a))"

text {* @{term srtdw}: Rest (@{text srt}) of stream after dropwhile. *}
definition srtdw      :: "('a \<Rightarrow> bool) \<Rightarrow> 'a spfo" where
"srtdw f \<equiv> \<Lambda> x. srt\<cdot>(sdropwhile f\<cdot>x)"

text {* @{term srcdups}: Remove successive duplicate values from stream. *}
definition srcdups    :: "'a spfo" where
"srcdups \<equiv> fix\<cdot>(\<Lambda> h s. slookahd\<cdot>s\<cdot>(\<lambda> a. 
                        \<up>a \<bullet>  h\<cdot>(sdropwhile (\<lambda> z. z = a)\<cdot>(srt\<cdot>s))))"

(* Takes a nat indicating the number of elements to scan, a reducing function, an initial initial element,
   and an input stream. Returns a stream consisting of the partial reductions of the input stream. *)
primrec SSCANL :: "nat \<Rightarrow> ('o \<Rightarrow> 'i \<Rightarrow> 'o) \<Rightarrow> 'o \<Rightarrow> 'i stream \<Rightarrow> 'o stream" where
  SSCANL_zero_def: "SSCANL 0 f q s = \<epsilon>" |
  "SSCANL (Suc n) f q s = (if s=\<epsilon> then \<epsilon> 
                           else \<up>(f q (shd s)) \<bullet> ( SSCANL n f (f q (shd s)) (srt\<cdot>s) )     )"


text {* @{term sscanl}: Apply a function elementwise to the input stream.
  Behaves like @{text "map"}, but also takes the previously generated
  output element as additional input to the function.
  For the first computation, an initial value is provided. *}
definition sscanl     :: "('o \<Rightarrow> 'i \<Rightarrow> 'o) \<Rightarrow> 'o \<Rightarrow> ('i, 'o) spf" where
"sscanl f q \<equiv> \<Lambda> s. \<Squnion>i. SSCANL i f q s"

text {* @{term siterate}: Create a stream by repeated application of
  a function to an element. The generated stream starts with @{text "a"},
  @{text "f(a)"}, @{text "f(f(a))"}, and so on. *}
definition siterate   :: "('a \<Rightarrow> 'a) \<Rightarrow> 'a \<Rightarrow> 'a stream" where
"siterate f (a::'a) \<equiv> \<up>a \<bullet> sscanl (\<lambda>a (b::'a). f a) a\<cdot>(SOME x. #x = \<infinity>)"

text {*Alternative definition similar to @{term siterate},
it is more general than @{term siterate}*}
definition siterateBlock:: "('a stream \<Rightarrow> 'a stream) \<Rightarrow> 'a stream \<Rightarrow> 'a stream" where
"siterateBlock f \<equiv> fix \<cdot> (\<Lambda> h. (\<lambda>s. s \<bullet> (h (f s))))"

(* ----------------------------------------------------------------------- *)
text {* Conversion between lists and streams and the processing functions:*}
(* ----------------------------------------------------------------------- *)
text {* @{term list2s}: Convert a list to a (finite) stream. *}
text {* (Only listed as a constant below for reference;
  Use @{text "list2s"} with same signature instead). *}
(* consts list2s_   :: "'a list \<Rightarrow> 'a stream" *)

text {* @{term s2list}: Convert a stream to a list. Result for
  infinite streams is undefined. *}
definition s2list     :: "'a stream \<Rightarrow> 'a list" where
"s2list s \<equiv> if #s \<noteq> \<infinity> then SOME l. list2s l = s else undefined"

text {* @{term slpf2spf}: Convert a list-processing function to a
  stream-processing function. *}
definition slpf2spf   ::"('in,'out) lpf \<Rightarrow> ('in,'out) spf" where
"slpf2spf f \<equiv> 
    if monofun f 
      then \<Lambda> s. (\<Squnion>k. list2s (f (s2list (stake k\<cdot>s)))) 
      else undefined"

text {* @{term sislivespf}: Liveness predicate for SPFs. A SPF
  is considered live if all finite inputs are mapped to finite outputs. *}
definition sislivespf ::"('in,'out) spf \<Rightarrow> bool" where
"sislivespf f \<equiv> (\<forall>x. #(f\<cdot>x) = \<infinity> \<longrightarrow> #x = \<infinity>)"

text {* @{term sspf2lpf}: Convert a stream-processing function
  to a list-processing function. *}
definition sspf2lpf   ::"('in,'out) spf \<Rightarrow> ('in,'out) lpf" where
"sspf2lpf f \<equiv>  if sislivespf f then (\<lambda>x. s2list (f\<cdot>(list2s x))) else undefined"


(* ----------------------------------------------------------------------- *)
subsection {* Syntactic sugar and helpers*}
(* ----------------------------------------------------------------------- *)

text {* The following abbreviations define infix and prefix operators
  for a more intuitive usage. *}



abbreviation sfilter_abbr :: "'a set \<Rightarrow> 'a stream \<Rightarrow> 'a stream" ("(_ \<ominus> _)" [66,65] 65)
where "F \<ominus> s \<equiv> sfilter F\<cdot>s"


(* ----------------------------------------------------------------------- *)
subsection {* Definition of stream manipulating functions*}
(* ----------------------------------------------------------------------- *)

text {* In this section, the definitions for the previously
  declared functions are given. *}

text {* A typical procedure is to define a primary recursive function
  first and then define the stream-processing via the least upper
  bound of the function values for the prefixes of a stream. *}

(* concatenates a stream to itself n times *)
primrec sntimes :: "nat \<Rightarrow> 'a stream \<Rightarrow> 'a stream" where
  "sntimes 0 s = \<epsilon>" |
  "sntimes (Suc n) s = (sconc s)\<cdot>(sntimes n s)"
  
(* Abbreviation for sntimes *)
abbreviation sntimes_abbr :: "nat \<Rightarrow> 'a stream \<Rightarrow> 'a stream" ("_\<star>_" [60,80] 90)
where "(n \<star> s)  == (sntimes n s)"

text {* In most cases, stream-processing functions or operators
  on streams are defined using the continuous fixed point operator. *}


(* ----------------------------------------------------------------------- *)
section {* Stream - basics *}
(* --------------------------------------\<Squnion>--------------------------------- *)

text {* In the following, lemmas on streams and their operators
  are proven. In most cases, the stated lemma is shortly summarized
  in natural language. Where this is not the case, the lemma
  itself is mostly self-explanatory. *}

(* ----------------------------------------------------------------------- *)
subsection {* Fundamental properties of @{term stake} *}
(* ----------------------------------------------------------------------- *)

text {* Some aliases of auto-generated lemmas are introduced: *}
lemmas scases' = stream.exhaust
lemmas sinjects' = stream.injects
lemmas sinverts' = stream.inverts

text {* Each stream is the least upper bound of its prefixes.
  As we we are in a CPO, upper bounds of chains always exist. *}
lemma reach_stream: "(\<Squnion>i. stake i\<cdot>s) = s"
apply (rule stream.take_lemma [OF spec [where x=s]])
apply (induct_tac n, simp, rule allI)
apply (rule_tac y=x in scases', simp)
apply (subst lub_range_shift [where j="Suc 0", THEN sym],simp+)
by (subst contlub_cfun_arg [THEN sym], auto)

(* if two streams xs and ys are identical for any prefix that is a multiple of y long, then the two
   streams are identical for any prefix *)
lemma gstake2stake: assumes "\<forall>i. stake (i*y)\<cdot>xs = stake (i*y)\<cdot>ys" and "y\<noteq>0"
  shows "\<forall>i. stake i\<cdot>xs = stake i\<cdot>ys"
proof 
  fix i
  obtain k where "\<exists>l. k = y*l" and "k\<ge>i" by (metis One_nat_def Suc_le_eq assms(2) gr0I mult.commute mult_le_mono2 nat_mult_1_right)
  thus "stake i\<cdot>xs = stake i\<cdot>ys" by (metis assms(1) min_def mult.commute stream.take_take) 
qed

lemma stake_mono: assumes "i\<le>j"
  shows "stake i\<cdot>s \<sqsubseteq> stake j\<cdot>s"
by (metis assms min_def stream.take_below stream.take_take)

(* ----------------------------------------------------------------------- *)
subsection {* The continuity of concatenation *}
(* ----------------------------------------------------------------------- *)

text {* The function body which is used to define concatenation
  is continuous. Continuity has to be proven before the Lambda-
  expression may be evaluated (beta reduction). *}

lemma cont_sconc: 
  "\<And>s1 s2. 
     cont (\<lambda>h. if s1 = \<epsilon> then s2 else (lshd\<cdot>s1) && (h (srt\<cdot>s1)\<cdot>s2))"
apply (rule contI)
apply (rule_tac y=s1 in scases', simp+)
apply (rule is_lub_const)
apply (subst lub_fun, assumption)
apply (subst contlub_cfun_fun)
apply (rule ch2ch_fun, assumption)
apply (subst contlub_cfun_arg)
apply (rule ch2ch_Rep_cfunL)
apply (rule ch2ch_fun, assumption)
apply (rule thelubE, simp)
apply (rule ch2ch_Rep_cfunR)
apply (rule ch2ch_Rep_cfunL)
by (rule ch2ch_fun, assumption, simp)

(* ----------------------------------------------------------------------- *)
subsection {* Construction by concatenation and more *}
(* ----------------------------------------------------------------------- *)

text {* Basic properties of @{text "\<up>_"} constructor *}

(* shd composed with \<up> is the identity. *)
lemma [simp]: "shd (\<up>a) = a"
by (simp add: shd_def sup'_def)

(* the singleton stream is never equal to the empty stream *)
lemma [simp]: "\<up>a \<noteq> \<epsilon>"
by (simp add: sup'_def)

(* the rest of the singleton stream is empty *)
lemma [simp]: "srt\<cdot>(\<up>a) = \<epsilon>"
by (simp add: sup'_def)

text {* Basic properties of concatenation *}

(* the empty stream is the identity element with respect to concatenation *)
lemma sconc_fst_empty[simp]:"\<epsilon> \<bullet> s = s"
apply (subst sconc_def [THEN fix_eq2])
by (simp add: cont2cont_LAM)

(* the lazy stream constructor and concatenation are associative *) 
lemma sconc_scons': "(updis a && as) \<bullet> s = updis a && (as \<bullet> s)"
apply (subst sconc_def [THEN fix_eq2])
by (simp add: cont2cont_LAM)

(* the lazy stream constructor is equivalent to concatenation with a singleton stream *)
lemma lscons_conv: "updis a && s = \<up>a \<bullet> s"
apply (subst sconc_def [THEN fix_eq2])
apply (simp add:  sup'_def)
by (simp add: cont2cont_LAM)

(* concatenation with respect to singleton streams is associative *)
lemma sconc_scons[simp]: "(\<up>a \<bullet> as) \<bullet> s = \<up>a \<bullet> (as \<bullet> s)"
apply (subst sconc_def [THEN fix_eq2])
by (simp add: sconc_scons' sup'_def cont2cont_LAM)

text {* If a predicate P holds for empty and non-empty streams, it holds for all streams *}
lemma scases: "\<And>x P. \<lbrakk>x = \<epsilon> \<Longrightarrow> P; \<And>a s. x = \<up>a \<bullet> s \<Longrightarrow> P\<rbrakk> \<Longrightarrow> P"
apply (rule_tac y=x in scases', simp+)
apply (rule_tac p=u in upE, simp+)
apply (case_tac "xa")
by (auto simp add: sup'_def sconc_scons')

(* Single element streams commute with the stake operation. *)
lemma stake_Suc[simp]: "stake (Suc n)\<cdot>(\<up>a \<bullet> as) = \<up>a \<bullet> stake n\<cdot>as"
by (simp add: sconc_scons' sup'_def)

(* see also sconc_fst_empty *)
lemma sconc_snd_empty[simp]: "s \<bullet> \<epsilon> = s"
apply (rule stream.take_lemma [OF spec [where x = "s"]])
apply (induct_tac n, simp)
apply (rule allI, simp)
by (rule_tac x=x in scases, simp+)

(* shd is the inverse of prepending a singleton *)
lemma shd1[simp]: "shd (\<up>a \<bullet> s) = a"
by (simp add: sconc_scons' shd_def sup'_def)

(* prepending an element a to a stream and extracting it with lshd is equivalent to imposing the
   discrete order on a *)
lemma lshd_updis [simp]: "lshd\<cdot>(\<up>a \<bullet> s) = updis a"
by (metis lscons_conv stream.sel_rews(4))

(* srt is the inverse of appending to a singleton *)
lemma [simp]: "srt\<cdot>(\<up>a\<bullet>as) = as"
by (simp add: sconc_scons' sup'_def)

(* appending to a singleton is monotone *)
lemma [simp]: "\<up>a \<sqsubseteq> \<up>a \<bullet> s"
apply (subst sconc_snd_empty [of "\<up>a", THEN sym])
by (rule monofun_cfun_arg, simp)

text {* Properties of discrete partial orders *}

(* updis is a bijection *)
lemma updis_eq: "(updis a = updis b) = (a = b)"
by simp

(* the discrete order only considers equal elements to be ordered *)
lemma updis_eq2: "(updis a \<sqsubseteq> updis b) = (a = b)"
by simp

text {* Mapping a stream to head and rest is injective *}
lemma inject_scons: "\<up>a \<bullet> s1 = \<up>b \<bullet> s2 \<Longrightarrow> a = b \<and> s1 = s2"
apply (subst updis_eq [THEN sym])
apply (rule sinjects' [THEN iffD1], simp)
by (simp add: sconc_scons' sup'_def)

text {* @{text "\<sqsubseteq>"} applied to head and rest *}
lemma less_all_sconsD: "\<up>a \<bullet> as \<sqsubseteq> \<up>b \<bullet> bs \<Longrightarrow> a = b \<and> as \<sqsubseteq> bs"
apply (subst updis_eq2 [THEN sym])
apply (rule sinverts' [THEN iffD1], simp)
by (simp add: sconc_scons' sup'_def)

(* appending to a singleton stream can never yield the empty stream *)
lemma [simp]: "\<epsilon> \<noteq> \<up>a \<bullet> as"
apply (rule ccontr, simp)
apply (drule po_eq_conv [THEN iffD1])
apply (erule conjE)
by (simp add: sconc_scons' sup'_def)

lemma [simp]: "\<up>a \<bullet> as \<noteq> \<epsilon>"
by (rule notI, drule sym, simp)

text {* Characterizations of equality with @{text "\<sqsubseteq>"}, head and rest *}

(* singleton streams are only in an ordered relation if the two elements are equal *)
lemma [simp]: "(\<up>a \<sqsubseteq> \<up>b) = (a = b)"
apply (rule iffI)
by (insert less_all_sconsD [of a \<epsilon> b \<epsilon>], simp+)

lemma [simp]: "#as \<sqsubseteq> #(as \<bullet> ys)"
  by (metis minimal monofun_cfun_arg sconc_snd_empty)

(* uparrow is a bijection *)
lemma [simp]: "(\<up>a = \<up>b) = (a = b)"
apply (rule iffI)
by (insert inject_scons [of a \<epsilon> b \<epsilon>], simp+)

(* appending a stream x to a singleton stream and producing another singleton stream implies that 
   the two singleton streams are equal and x was empty *)
lemma [simp]: "(\<up>a \<bullet> x = \<up>c) = (a = c \<and> x = \<epsilon>)"
by (rule iffI, insert inject_scons [of a x c \<epsilon>], simp+)

lemma [simp]: "(\<up>c = \<up>a \<bullet> x) = (a = c \<and> x = \<epsilon>)"
by (rule iffI, insert inject_scons [of c \<epsilon> a x], simp+)

lemma [simp]: "(\<up>a \<bullet> x \<sqsubseteq> \<up>b) = (a = b \<and> x = \<epsilon>)" 
by (rule iffI, insert less_all_sconsD [of a x b \<epsilon>], simp+)

(* if a singleton stream is the prefix of another stream then the heads of the two streams must match *)
lemma [simp]: "(\<up>a \<sqsubseteq> \<up>b \<bullet> x) = (a = b)" 
by (rule iffI, insert less_all_sconsD [of a \<epsilon> b x], simp+)

(* if x isn't empty then concatenating head and rest leaves the stream unchanged *)
lemma surj_scons: "x\<noteq>\<epsilon> \<Longrightarrow> \<up>(shd x) \<bullet> (srt\<cdot>x) = x"
by (rule_tac x=x in scases, simp+)

text {* Characterizations of @{text "\<sqsubseteq>"} with head and rest *}

(* any nonempty prefix of a stream y is still a prefix when ignoring the first element *)
lemma less_fst_sconsD: "\<up>a \<bullet> as \<sqsubseteq> y \<Longrightarrow> \<exists>ry. y = \<up>a \<bullet> ry \<and> as \<sqsubseteq> ry"
apply (rule_tac x=y in scases, simp+) 
apply (rule_tac x="s" in exI)
by (drule less_all_sconsD, simp)

(* the prefix of any non-empty stream is either empty or shares the same first element *)
lemma less_snd_sconsD: 
  "x \<sqsubseteq> \<up>a\<bullet>as \<Longrightarrow> (x = \<epsilon>) \<or> (\<exists>rx. x = \<up>a\<bullet>rx \<and> rx \<sqsubseteq> as)"
apply (rule_tac x=x in scases, simp+) 
apply (rule_tac x="s" in exI)
by (drule less_all_sconsD, simp)

(* semantically equivalent to less_fst_sconsD *)
lemma lessD: 
  "x \<sqsubseteq> y \<Longrightarrow> (x = \<epsilon>) \<or> (\<exists>a q w. x = \<up>a\<bullet>q \<and> y = \<up>a\<bullet>w \<and> q \<sqsubseteq> w)"
apply (rule_tac x=x in scases, simp+)  
apply (rule_tac x="a" in exI)
apply (rule_tac x="s" in exI, simp)
by (drule less_fst_sconsD, simp)

(* ----------------------------------------------------------------------- *)
subsection {* @{term slen} *}
(* ----------------------------------------------------------------------- *)

lemma strict_slen[simp]:"#\<epsilon> = 0"
by (subst slen_def [THEN fix_eq2], simp add: lnzero_def)

(* prepending a singleton stream increases the length by 1 *)
lemma slen_scons[simp]: "#(\<up>a\<bullet>as) = lnsuc\<cdot>(#as)" 
by (subst slen_def [THEN fix_eq2], simp add: lnle_def)

(* the singleton stream has length 1 *)
lemma [simp]: "#(\<up>a) = Fin (Suc 0)"
apply (subst sconc_snd_empty [of "\<up>a", THEN sym])
by (subst slen_scons, simp+)

text {* The rest of infinite streams is infinite as well *}
lemma inf_scase:"#s = \<infinity> \<Longrightarrow> \<exists>a as. s = \<up>a \<bullet> as \<and> #as = \<infinity>"
by (rule_tac x=s in scases, auto)
 
(* only the empty stream has length 0 *)
lemma slen_empty_eq[simp]: "(#x = 0) = (x = \<epsilon>)"
by (rule_tac x=x in scases, auto)

text {* Appending to an inifite stream does not change its @{text "n"}th element *}
lemma sconc_fst_inf_lemma: "\<forall>x. #x=\<infinity> \<longrightarrow> stake n\<cdot>(x\<bullet>y) = stake n\<cdot>x"
apply (induct_tac n, auto)
by (rule_tac x=x in scases, auto)

text {* Appending to an infinite stream does not change the stream *}
lemma sconc_fst_inf[simp]: "#x=\<infinity> \<Longrightarrow> x\<bullet>y = x"
apply (rule stream.take_lemma)
by (rule sconc_fst_inf_lemma [rule_format])

text {* For finite streams, their lengths are added on concatenation *}
lemma slen_sconc_all_finite: 
  "\<forall>x y n. #x = Fin k \<and> #y = Fin n \<longrightarrow> #(x\<bullet>y) = Fin (k+n)" 
apply (induct_tac k, auto)
by (rule_tac x=x in scases, auto)

text {* Streams with infinite prefixes are infinite *}
lemma mono_fst_infD: "\<lbrakk>#x = \<infinity>; x \<sqsubseteq> y\<rbrakk> \<Longrightarrow> #y = \<infinity> "
apply (drule monofun_cfun_arg [of _ _ slen])
by (rule lnat_po_eq_conv [THEN iffD1], simp)

text {* For @{term "s \<sqsubseteq> t"} with @{term s} and @{term t} of
  equal length, all finite prefixes are identical *}
lemma stake_eq_slen_eq_and_less: 
  "\<forall>s t. #s = #t \<and> s \<sqsubseteq> t \<longrightarrow> stake n\<cdot>s = stake n\<cdot>t"
apply (induct_tac n, auto)
apply (rule_tac x=s in scases, auto)
apply (rule_tac x=t in scases, auto)
by (drule less_all_sconsD, auto)

text {* For @{term "s \<sqsubseteq> t"} with @{term s} and @{term t} of
  equal length, @{term s} and @{term t} are identical *}
lemma eq_slen_eq_and_less: "\<lbrakk>#s = #t; s \<sqsubseteq> t\<rbrakk> \<Longrightarrow> s = t"
apply (rule stream.take_lemma)
by (rule stake_eq_slen_eq_and_less [rule_format], rule conjI)

text {* Infinite prefixes are equal to the original stream *}
lemma eq_less_and_fst_inf: "\<lbrakk>s1 \<sqsubseteq> s2; #s1 = \<infinity>\<rbrakk> \<Longrightarrow> s1 = s2"
apply (rule eq_slen_eq_and_less, simp) 
apply (rule sym)
by (rule mono_fst_infD [of "s1" "s2"])

(*
lemma s1: "chain S \<Longrightarrow> \<not> finite_chain S \<Longrightarrow> \<forall>i. \<exists>j\<ge>i. S i \<sqsubseteq> S j"
by auto

lemma "chain S \<Longrightarrow> \<not> finite_chain S \<Longrightarrow> \<exists>k. #(S k) = \<infinity>"
apply (simp add: finite_chain_def max_in_chain_def )
apply (subgoal_tac "chain S \<Longrightarrow> \<not> finite_chain S \<Longrightarrow> \<forall>i. \<exists>j\<ge>i. S i \<sqsubseteq> S j")
prefer 2
apply (simp add: s1, simp)
sledgehammer
*)

lemma [simp]: "Fin n < #as \<Longrightarrow> Fin n < lnsuc\<cdot>(#as)"
  by (smt below_antisym below_trans less_lnsuc lnle_def lnless_def)

text {* For infinite streams, @{text "stake n"} returns @{text "n"} elements *}
lemma slen_stake_fst_inf[rule_format]: 
  "\<forall>x. #x = \<infinity> \<longrightarrow> #(stake n\<cdot>x) = Fin n"
apply (induct_tac n, auto)
by (rule_tac x=x in scases, auto)

(* mapping a stream to its length is a monotone function *)
lemma mono_slen: "x \<sqsubseteq> y \<Longrightarrow> #x \<le> #y"
by (drule_tac x = x and y = y and f = slen 
  in monofun_cfun_arg, simp)

text {* A stream is shorter than @{text "n+1"} iff its rest is shorter than @{text "n"} *}
lemma slen_rt_ile_eq: "(#x \<le> Fin (Suc n)) = (#(srt\<cdot>x) \<le> Fin n)"  
by (rule_tac x=x in scases, auto)

text {* If @{text "#x < #y"}, this also applies to the streams' rests (for nonempty, finite x) *}
lemma smono_slen_rt_lemma: 
  "#x = Fin k \<and> x \<noteq> \<epsilon> \<and> #x < #y \<longrightarrow> #(srt\<cdot>x) < #(srt\<cdot>y)"
apply (induct_tac k, auto)
apply (rule_tac x=x in scases, auto)
by (rule_tac x=y in scases, auto)

text {* If @{text "#x < #y"}, this also applies to the streams' rests (for finite x) *}
lemma smono_slen_rt: "\<lbrakk>x \<noteq> \<epsilon>; #x < #y\<rbrakk> \<Longrightarrow> #(srt\<cdot>x) < #(srt\<cdot>y)"
apply (rule_tac x="#x" in lncases, auto) 
by (rule smono_slen_rt_lemma [rule_format], simp)

text {* Infinite elements of a stream chain are equal to the LUB *}
lemma inf2max: "\<lbrakk>chain Y; #(Y k) = \<infinity>\<rbrakk> \<Longrightarrow> Y k = (\<Squnion>i. Y i)"
apply (subgoal_tac "Y k \<sqsubseteq> (\<Squnion>i. Y i)")
apply (drule eq_less_and_fst_inf, assumption+)
by (rule is_ub_thelub)

text {* @{text "stake n"} returns at most @{text "n"} elements *}
lemma ub_slen_stake[simp]: "#(stake n\<cdot>x) \<le> Fin n"
apply (rule spec [where x = x])
apply (induct_tac n, auto)
by (rule_tac x=x in scases, auto)

text {* @{text "stake"} always returns finite streams *}
lemma [simp]: "#(stake n\<cdot>x) \<noteq> \<infinity>"
proof (rule notI)
  assume inf: "#(stake n\<cdot>x) = \<infinity>"
  have "#(stake n\<cdot>x) \<le> Fin n" by (rule ub_slen_stake)
  thus False using inf by simp
qed

text {* @{text "stake"}ing at least @{text "#x"} elements returns @{text "x"} again *}
lemma fin2stake_lemma: "\<forall>x k. #x = Fin k \<and> k\<le>i \<longrightarrow> stake i\<cdot>x = x"
apply (induct_tac i, auto)
apply (rule_tac x=x in scases, auto)
by (case_tac "k", auto)

text {* @{text "stake"}ing @{text "#x"} elements returns @{text "x"} again *}
lemma fin2stake:"#x = Fin n \<Longrightarrow> stake n\<cdot>x = x"
by (rule fin2stake_lemma [rule_format, of "x" "n" "n"], simp)

(* ----------------------------------------------------------------------- *)
section {* Basic induction rules *}
(* ----------------------------------------------------------------------- *)

text {* induction for all prefixes *}
lemma stakeind: 
  "\<forall>x. (P \<epsilon> \<and> (\<forall>a s. P s \<longrightarrow> P (\<up>a \<bullet> s))) \<longrightarrow> P (stake n\<cdot>x)"
by (induct_tac n, auto, rule_tac x=x in scases, auto)

text {* induction for finite streams *}
lemma finind:
  "\<lbrakk>#x = Fin n; P \<epsilon>; \<And>a s. P s \<Longrightarrow> P (\<up>a \<bullet> s)\<rbrakk> \<Longrightarrow> P x"
apply (drule fin2stake)
apply (drule sym, erule ssubst)
apply (rule stakeind [rule_format])
apply (rule conjI, assumption)
apply (rule allI)+
by (rule impI, simp)

text {* induction for infinite streams and admissable predicates *}
lemma ind: 
  "\<lbrakk>adm P; P \<epsilon>; \<And>a s. P s  \<Longrightarrow> P (\<up>a \<bullet> s)\<rbrakk> \<Longrightarrow> P x"
apply (unfold adm_def)
apply (erule_tac x="\<lambda>i. stake i\<cdot>x" in allE, auto)
apply (simp add: stakeind)
by (simp add: reach_stream)

(* ----------------------------------------------------------------------- *)
subsection {* Other properties of @{term stake} *}
(* ----------------------------------------------------------------------- *)

text {* composition of @{text "stake"} *}
lemma stakeostake[simp]: "stake k\<cdot>(stake n\<cdot>x) = stake (min k n)\<cdot>x"
apply (rule_tac x="n" in spec)
apply (rule_tac x="k" in spec)
apply (rule ind [of _ x], simp+)
apply (rule allI)+
apply (case_tac "xa", simp+)
by (case_tac "x", simp+)

(* stake always returns a prefix of the input stream *)
lemma ub_stake[simp]: "stake n\<cdot>x \<sqsubseteq> x"
by (rule stream.take_below)

lemma stake_suc: "stake (Suc n)\<cdot>s = (stake 1\<cdot>s) \<bullet> stake n\<cdot>(srt\<cdot>s)"
by (metis (no_types, lifting) One_nat_def Rep_cfun_strict1 sconc_snd_empty stake_Suc stream.sel_rews(2) stream.take_0 stream.take_strict surj_scons)


(* ----------------------------------------------------------------------- *)
subsection {* @{term sdrop} *}
(* ----------------------------------------------------------------------- *)

text {* basic properties of @{term sdrop} *}

lemma strict_sdrop[simp]: "sdrop n\<cdot>\<epsilon> = \<epsilon>"
by (simp add: sdrop_def, induct_tac n, auto)

lemma sdrop_0[simp]: "sdrop 0\<cdot>s = s"
by (simp add: sdrop_def)

(* dropping an additional element is equivalent to calling srt *)
lemma sdrop_back_rt: "sdrop (Suc n)\<cdot>s = srt\<cdot>(sdrop n\<cdot>s)"
by (simp add: sdrop_def)

lemma sdrop_forw_rt: "sdrop (Suc n)\<cdot>s = sdrop n\<cdot>(srt\<cdot>s)"
apply (simp add: sdrop_def)
by (subst iterate_Suc2 [THEN sym], simp)

(* dropping n + 1 elements from a non-empty stream is equivalent to dropping n items from the rest *)
lemma sdrop_scons[simp]: "sdrop (Suc n)\<cdot>(\<up>a \<bullet> as) = sdrop n\<cdot>as"
by (simp add: sdrop_forw_rt)

(* if dropping n items produces the empty stream then the stream contains n elements or less *)
lemma sdrop_stakel1: "\<forall>s. sdrop n\<cdot>s = \<epsilon> \<longrightarrow> stake n\<cdot>s = s"
apply (induct_tac n, auto)
by (rule_tac x=s in scases, auto)

(* dropping k+x elements is equivalent to dropping x elements first and then k elements *) 
lemma sdrop_plus: "sdrop (k+x)\<cdot>xs = sdrop k\<cdot>(sdrop x\<cdot>xs)"
by (simp add: iterate_iterate sdrop_def)

text {* Dropping from infinite streams still returns infinite streams *}
lemma fair_sdrop[rule_format]: 
  "\<forall>x. #x = \<infinity> \<longrightarrow> #(sdrop n\<cdot>x) = \<infinity>"
apply (induct_tac n, simp, clarify)
by (rule_tac x=x in scases, auto)

text {* streams can be split by @{term stake} and @{term sdrop} *}
lemma split_streaml1[simp]: 
  "stake n\<cdot>s \<bullet> sdrop n\<cdot>s = s"
apply (rule spec [where x = s])
apply (induct_tac n, auto)
by (rule_tac x=x in scases, auto)

text {* @{term sdrop} may only create infinite outputs for infinite inputs *}
lemma fair_sdrop_rev:
  "#(sdrop k\<cdot>x) = \<infinity> \<Longrightarrow> #x = \<infinity>"
apply (simp add: atomize_imp)
apply (rule_tac x="x" in spec)
apply (induct_tac k, simp)
apply (rule allI, rule impI)
apply (rule_tac x="x" in scases, simp)
by (erule_tac x="s" in allE, simp)

text {* construct @{term "sdrop j"} from @{term "sdrop k"} (with @{term "j \<le> k"}) *}
lemma sdropl5:
  "j \<le> k \<Longrightarrow> sdrop j\<cdot>(stake k\<cdot>x) \<bullet> sdrop k\<cdot>x = sdrop j\<cdot>x"
apply (simp add: atomize_imp)
apply (rule_tac x="j" in spec)
apply (rule_tac x="x" in spec)
apply (induct_tac k, auto)
apply (rule_tac x="x" in scases, auto)
by (case_tac "xa", auto)

text {* Dropping as inverse of prepending a finite stream *}
lemma sdropl6:
  "#x = Fin k \<Longrightarrow> sdrop k\<cdot>(x \<bullet> y) = y"
apply (simp add: atomize_imp)
apply (rule_tac x="x" in spec)
apply (rule_tac x="y" in spec)
apply (induct_tac k, auto)
by (rule_tac x="xa" in scases, auto)

(* ----------------------------------------------------------------------- *)
subsection {* @{term snth} *}
(* ----------------------------------------------------------------------- *)

text {* Basic properties of @{term snth} *}

(* the element k + 1 of the stream s is identical to the element k of the rest of s *)
lemma snth_rt: "snth (Suc k) s = snth k (srt\<cdot>s)"
apply (simp add: snth_def)
by (subst sdrop_forw_rt,rule refl)

(* semantically equivalent to snth_rt *)
lemma snth_scons[simp]: "snth (Suc k) (\<up>a \<bullet> s) = snth k s"
by (simp add: snth_rt)

(* indexing starts at 0, so the 0'th element is equal to the head *)
lemma snth_shd[simp]: "snth 0 s = shd s"
by (simp add: snth_def)

text {* If two streams of same length agree on every element,
  all their finite prefixes are equal *}
lemma snths_eq_lemma [rule_format]: 
  "\<forall>x y. #x = #y \<and> (\<forall>n. Fin n < #x \<longrightarrow> snth n x = snth n y) 
           \<longrightarrow> stake k\<cdot>x = stake k\<cdot>y"
apply (induct_tac k, auto)
apply (rule_tac x=x in scases, auto)
apply (rule_tac x=y in scases, auto)
apply (erule_tac x="s" in allE)
apply (erule_tac x="sa" in allE, auto)
apply (erule_tac x="Suc na" in allE, simp)
by (erule_tac x="0" in allE, auto)

text {* If two streams of same length agree on every element, they are equal *}
lemma snths_eq: 
  "\<lbrakk>#x = #y; \<forall>n. Fin n < #x \<longrightarrow> snth n x = snth n y\<rbrakk> \<Longrightarrow> x = y"
apply (rule stream.take_lemma)
by (rule snths_eq_lemma, auto)

(* easy to use rule to show equality on infinite streams *)
(* if two finite streams x, s are identical at every position then x and s are identical *) 
lemma sinf_snt2eq: assumes "#s=\<infinity>" and "#x=\<infinity>" and "\<And>i. (snth i s = snth i x)"
  shows "s=x"
by (simp add: assms snths_eq)

(* ----------------------------------------------------------------------- *)
section {* Further lemmas *}
(* ----------------------------------------------------------------------- *)

(* concatenation is associative *)
lemma assoc_sconc[simp]: "(s1\<bullet>s2)\<bullet>s3 = s1\<bullet>s2\<bullet>s3"
apply (rule_tac x="#s1" in lncases, auto)
by (rule finind [of "s1"], auto)

(* 2 very specific lemmas, used in \<open>stake_add\<close> *)
  lemma stake_conc: "stake i\<cdot>s \<bullet> x = stake (Suc i)\<cdot>s \<Longrightarrow> x = stake 1\<cdot>(sdrop i\<cdot>s)"
  apply (induction i arbitrary: s)
  apply (simp add: One_nat_def)
  by (smt assoc_sconc inject_scons sdrop_forw_rt stake_Suc stream.take_strict strict_sdrop surj_scons) 
  
  
  lemma stake_concat:"stake i\<cdot>s \<bullet> stake (Suc j)\<cdot>(sdrop i\<cdot>s) = stake (Suc i)\<cdot>s \<bullet> stake j\<cdot>(sdrop (Suc i)\<cdot>s)"
  proof -
    obtain x where x_def: "stake i\<cdot>s \<bullet> x = stake (Suc i)\<cdot>s" 
      by (metis (no_types, hide_lams) Suc_n_not_le_n linear min_def split_streaml1 stream.take_take)  
    thus ?thesis
      by (smt One_nat_def Rep_cfun_strict1 assoc_sconc sconc_snd_empty sdrop_back_rt stake_Suc stake_conc stream.take_0 stream.take_strict strict_sdrop surj_scons)
  qed

(* for arbitrary natural numbers i, j and any streams s the following lemma holds: *)
lemma stake_add: "stake (i+j)\<cdot>s = (stake i\<cdot>s) \<bullet> (stake j\<cdot>(sdrop i\<cdot>s))"
apply (induction i arbitrary: j)
apply simp
by (metis add_Suc_shift stake_concat)

text {* Finite, equal streams agree on all postfixes *}
lemma inject_sconc: "\<lbrakk>#x = Fin k; x \<bullet> y = x \<bullet> z\<rbrakk> \<Longrightarrow> y = z"
apply (simp add: atomize_imp)
apply (rule_tac x=x in spec)
apply (induct_tac k, auto)
apply (rule_tac x=x in scases, auto)
by (drule inject_scons, auto)

lemma [simp]: "x \<sqsubseteq> x \<bullet> y"
apply (rule_tac x="#x" in lncases, auto)
apply (rule finind [of x], auto)
by (rule monofun_cfun_arg)

text {* Prepending to infinite streams produces infinite streams again *}
lemma slen_sconc_snd_inf: "#y=\<infinity> \<Longrightarrow> #(x \<bullet> y) = \<infinity>"
apply (rule_tac x="#x" in lncases, auto)
by (rule finind [of "x"], auto)

(* stake n results in a stream of length n, so sdrop n then results in the empty stream *)
lemma sdropostake: "sdrop n\<cdot>(stake n\<cdot>s) = \<epsilon>"
apply (rule spec [where x = n])
apply (rule ind [of _ s], auto)
by (case_tac x, auto)

lemma stakeind2: 
  "\<forall>x. (P \<epsilon> \<and> (\<forall>a s. P s \<longrightarrow> P (s \<bullet> \<up>a))) \<longrightarrow> P (stake n\<cdot>x)"
  apply(induction n)
   apply simp
  apply auto
  apply (subst stake_suc)
  by (metis (no_types, lifting) sconc_snd_empty sdrop_back_rt sdropostake split_streaml1 stake_suc surj_scons)

lemma ind2: assumes "adm P" and "P \<epsilon>"  and "\<And>a s. P s  \<Longrightarrow> P (s \<bullet> \<up>a)"
  shows "P x"
by (metis assms(1) assms(2) assms(3) stakeind2 stream.take_induct)

(* ----------------------------------------------------------------------- *)
section {* Additional lemmas for approximation, chains and continuity *} 
(* ----------------------------------------------------------------------- *)

text {* A finite prefix of length @{term "k"} is created by @{term "stake k"} *}
lemma approxl1:
  "\<forall>s1 s2. s1 \<sqsubseteq> s2 \<and> #s1 = Fin k \<longrightarrow> stake k\<cdot>s2 = s1"
apply (induct_tac k, auto)
apply (rule_tac x=s1 in scases, auto)
apply (rule_tac x=s2 in scases, auto)
apply (erule_tac x="s" in allE)
apply (erule_tac x="sa" in allE)
by (drule less_all_sconsD, auto)

text {* A prefix of a stream is equal to the original one or a finite prefix *}
lemma approxl2:
  "s1 \<sqsubseteq> s2 \<Longrightarrow> (s1 = s2) \<or> (\<exists>n. stake n\<cdot>s2 = s1 \<and> Fin n = #s1)"
apply (rule_tac x="#s1" in lncases, auto)
apply (rule eq_less_and_fst_inf, assumption+)
by (insert approxl1 
  [rule_format, of "s1" "s2"], auto)

text {* In infinite chains, all streams are finite *}
lemma inf_chainl1:
  "\<lbrakk>chain Y; \<not>finite_chain Y\<rbrakk> \<Longrightarrow> \<exists>k. #(Y i) = Fin k"
apply (rule ccontr, simp, frule infI)
apply (frule_tac k="i" in inf2max, assumption)
apply (frule_tac i="i" in max_in_chainI3, simp+)
by (simp add: finite_chain_def)

text {* Each prefix of a stream can be expanded to the original stream *}
lemma approxl3: "s1 \<sqsubseteq> s2 \<Longrightarrow> \<exists>t. s1\<bullet>t = s2"
apply (rule_tac x="#s1" in lncases, simp)
apply (drule eq_less_and_fst_inf, simp+)
apply (subst approxl1 
  [rule_format, of "s1" "s2", THEN sym], simp+)
by (rule_tac x="sdrop k\<cdot>s2" in exI, simp)

text {* In infinite chains, there is an element which is a true prefix of another one *}
lemma inf_chainl2:
  "\<lbrakk>chain Y; \<not> finite_chain Y\<rbrakk> \<Longrightarrow> \<exists>j. Y k \<sqsubseteq> Y j \<and> #(Y k) < #(Y j)"
apply (auto simp add: finite_chain_def max_in_chain_def)
apply (erule_tac x="k" in allE, auto)
apply (frule_tac i=k and j=j in chain_mono, assumption)
apply (rule_tac x="j" in exI, simp)
apply (auto simp add: lnless_def)
apply (rule mono_slen, assumption)
by (frule eq_slen_eq_and_less, simp+)

text {* In infinite chains, the length of the streams is unbounded *}
lemma inf_chainl3:
  "chain Y \<and> \<not>finite_chain Y \<longrightarrow> (\<exists>k. Fin n \<le> #(Y k))"
apply (induct_tac n, auto)
apply (case_tac "Fin n = #(Y k)")
apply (frule_tac k=k in inf_chainl2, auto)
apply (rule_tac x="j" in exI)
apply (drule sym)
apply (rule_tac x="#(Y j)" in lncases, auto)
apply (rule_tac x="k" in exI)
by (rule_tac x="#(Y k)" in lncases, auto)

text {* In infinite chains, the lub is infinite *}
lemma inf_chainl4:
  "\<lbrakk>chain Y; \<not>finite_chain Y\<rbrakk> \<Longrightarrow> #(lub(range Y)) = \<infinity>"
apply (rule_tac x="#(Lub Y)" in lncases, auto)
apply (frule_tac n = "Suc k" in inf_chainl3 
  [rule_format, OF conjI], assumption, erule exE)
apply (subgoal_tac "Y ka \<sqsubseteq> (Lub Y)")
apply (drule monofun_cfun_arg [of _ _ slen], simp)
apply (frule_tac x = "Fin (Suc k)" and 
  y = "#(Y ka)" and z = "Fin k" in trans_lnle, simp+)
by (rule is_ub_thelub)


text {* Each chain becomes finite by mapping @{term "stake n"} to every element *}
lemma finite_chain_stake: 
  "chain Y \<Longrightarrow> finite_chain (\<lambda>i. stake n\<cdot>(Y i))"
apply (frule ch2ch_Rep_cfunR [of _ "stake n"])
apply (rule ccontr)
apply (frule inf_chainl4 [of "\<lambda>i. stake n\<cdot>(Y i)"],assumption)
by (simp add: contlub_cfun_arg [THEN sym])

text {* every finite prefix of the lub is also prefix of some element in the chain *}
lemma lub_approx: 
  "chain Y \<Longrightarrow> \<exists>k. stake n\<cdot>(lub (range Y)) = stake n\<cdot>(Y k)"
apply (subst contlub_cfun_arg, assumption)
apply (frule finite_chain_stake [of _ n])
apply (simp add: finite_chain_def, auto)
apply (rule_tac x="i" in exI)
by (rule lub_finch1  
  [THEN lub_eqI, of "\<lambda>i. stake n\<cdot>(Y i)"], auto)

text {* If @{term f} is monotone and for each @{term x} there is a finite prefix
  @{term y} such that @{term "f x = f y"}, @{term f} is continuous *}
lemma pr_contI: 
  "\<lbrakk>monofun f; \<forall>x.\<exists>n. (f x) = f (stake n\<cdot>x)\<rbrakk> \<Longrightarrow> cont f"
apply (rule contI2, assumption)
apply (rule allI, rule impI)
apply (erule_tac x="lub (range Y)" in allE, erule exE)
apply (frule_tac n = n in lub_approx, erule exE)
apply (subgoal_tac "f (stake n\<cdot>(Y k)) \<sqsubseteq> f (Y k)")
apply (subgoal_tac "f (Y k) \<sqsubseteq> (\<Squnion>i. f (Y i))")
apply (drule_tac x="f (stake n\<cdot>(Y k))" and 
  y="f (Y k)" and z = "\<Squnion>i. f (Y i)" in below_trans)
apply (rule is_ub_thelub)
apply (rule_tac f=f in ch2ch_monofun, assumption+)
apply (clarsimp)
apply (rule is_ub_thelub)
apply (rule_tac f=f in ch2ch_monofun, assumption+)
by (rule_tac f = f in monofunE, simp+)

text {* For continuous functions, each finite prefix of @{term "f\<cdot>x"} only
  depends on a finite prefix of @{term "x"} *}
lemma fun_approxl1: 
  "\<exists>j. stake k\<cdot>(f\<cdot>x) = stake k\<cdot>(f\<cdot>(stake j\<cdot>x))"
apply (subgoal_tac "f\<cdot>x = (\<Squnion>i. f\<cdot>(stake i\<cdot>x))")
apply (erule ssubst)
apply (rule lub_approx)
apply (rule chain_monofun)
apply (rule ch2ch_Rep_cfunL)
apply (rule stream.chain_take)
apply (subst contlub_cfun_arg [THEN sym])
apply (rule ch2ch_Rep_cfunL)
apply (rule stream.chain_take)
apply (subst reach_stream)
by (rule refl)

text {* For continuous functions, any finite output for stream @{term "x"} can also be
  obtained by some finite prefix of @{term "x"} *}
lemma fun_approxl2: "#(f\<cdot>x) = Fin k \<Longrightarrow> \<exists>j. f\<cdot>x = f\<cdot>(stake j\<cdot>x)" 
apply (insert fun_approxl1 [of k "f" x], auto)
apply (rule_tac x="j" in exI)
apply (frule fin2stake [THEN sym], simp)
apply (rule stream.take_lemma, simp)
apply (case_tac "n \<le> k")
apply (simp add: min_def)+
apply (rule po_eq_conv [THEN iffD2])
apply (rule conjI)
apply (rule monofun_cfun_fun)
apply (rule chain_mono)
apply (rule stream.chain_take, simp+)
apply (subgoal_tac "f\<cdot>(stake j\<cdot>x) \<sqsubseteq> f\<cdot>x")
apply (rule below_trans, auto)
apply (drule sym, drule sym, simp)
by (rule monofun_cfun_arg, simp)

lemma sconc_neq_h: assumes "s1 \<noteq> s2"
  shows "#a < \<infinity> \<longrightarrow> a \<bullet> s1 \<noteq> a \<bullet> s2"
  apply(rule ind [of _a ])
    apply(rule admI)
    apply (rule impI)
    apply (metis inf_chainl4 l42 neq_iff)
   apply (simp add: assms)
  by (metis inf_ub inject_scons less_le sconc_scons slen_sconc_snd_inf)
 
lemma sconc_neq: assumes "s1 \<noteq> s2" and "#a < \<infinity>"
  shows "a \<bullet> s1 \<noteq> a \<bullet> s2"
using assms(1) assms(2) sconc_neq_h by blast

(* ----------------------------------------------------------------------- *)
section {* Lemmas for the remaining definitions *}
(* ----------------------------------------------------------------------- *)

(* ----------------------------------------------------------------------- *)
subsection {* @{term slookahd} *}
(* ----------------------------------------------------------------------- *)

text {* @{term slookahd} is continuous *}
lemma cont_slookahd[simp]: "cont (\<lambda> s. if s=\<epsilon> then \<bottom> else eq (shd s))"
apply (rule pr_contI)
apply (rule monofunI, auto)
apply (rule_tac x=x in scases, auto)
apply (rule_tac x=y in scases, auto)
apply (drule less_all_sconsD, simp)
apply (rule_tac x=x in scases, auto)
by (rule_tac x="Suc 0" in exI, auto)

(* slookahd applied to the empty stream results in the bottom element for any function eq *)
lemma strict_slookahd[simp]: "slookahd\<cdot>\<epsilon>\<cdot>eq = \<bottom>"
by (simp add: slookahd_def cont2cont_LAM)

(* if s isn't the empty stream, the function eq will be applied to the head of s *)
lemma slookahd_scons[simp]: "s\<noteq>\<epsilon> \<Longrightarrow> slookahd\<cdot>s\<cdot>eq = eq (shd s)"
by (simp add: slookahd_def cont2cont_LAM)

(* the constant function that always returns the empty stream unifies the two cases of slookahd *)
lemma strict2_slookahd[simp]: "slookahd\<cdot>xs\<cdot>(\<lambda>y. \<epsilon>) = \<epsilon>"
by (cases xs, simp_all)

(* ----------------------------------------------------------------------- *)
subsection {* @{term sinftimes} *}
(* ----------------------------------------------------------------------- *)

text {* basic properties of @{term sntimes} and @{term sinftimes} *}

(* repeating the empty stream produces the empty stream again for any n*)
lemma sntimes_eps[simp]: "sntimes n \<epsilon> = \<epsilon>"
by (induct_tac n, simp+)

(* after repeating the stream \<up>s n-times the head is s *)
  (* n>0 otherwise \<open>0 \<star> \<up>s = \<epsilon>\<close> *)
lemma shd_sntime [simp]: assumes "n>0" shows "shd (n \<star> \<up>s) = s"
by (metis assms gr0_implies_Suc shd1 sntimes.simps(2))

(* infinitely cycling the empty stream produces the empty stream again *)
lemma strict_icycle[simp]: "sinftimes \<epsilon> = \<epsilon>"
by (subst sinftimes_def [THEN fix_eq2], auto)

(* repeating a stream infinitely often is equivalent to repeating it once and then infinitely often *)
lemma sinftimes_unfold: "sinftimes s = s \<bullet> sinftimes s"
by (subst sinftimes_def [THEN fix_eq2], auto)

text {* For nonempty @{term s}, @{term "sinftimes s"} is infinite *}
lemma slen_sinftimes: "s \<noteq> \<epsilon> \<Longrightarrow> #(sinftimes s) = \<infinity>"
apply (rule ccontr)
apply (rule_tac x="#(sinftimes s)" in lncases, auto)
apply (rule_tac x="#s" in lncases)
apply (insert sinftimes_unfold [of s], auto)
by (insert slen_sconc_all_finite 
  [rule_format, of "s" _ "sinftimes s"], force)

lemma [simp]: "#(sinftimes (\<up>a)) = \<infinity>" 
by (simp add: slen_sinftimes)

(* converting the element x to a singleton stream, repeating the singleton and re-extracting x with
   lshd is equivalent to imposing the discrete order on x *)
lemma lshd_sinf [simp]: "lshd\<cdot>\<up>x\<infinity> = updis x"
by (metis lshd_updis sinftimes_unfold)

(* the infinite repetition of the stream x has the same head as x *)
lemma shd_sinf[simp]: "shd (x\<infinity>) = shd x"
by (metis assoc_sconc shd1 sinftimes_unfold strict_icycle surj_scons)

(* srt has no effect on an infinite constant stream of x *)
lemma srt_sinf [simp]: "srt\<cdot>\<up>x\<infinity> = (\<up>x\<infinity>)"
by (metis lscons_conv sinftimes_unfold stream.sel_rews(5) up_defined)

(* if the stream x contains y elements then the first y elements of the infinite repetition of x will
   be x again *)
lemma stake_y [simp]: assumes "#x = Fin y"
    shows "stake y\<cdot>(sinftimes x) = x"
by (metis approxl1 assms minimal monofun_cfun_arg sconc_snd_empty sinftimes_unfold)

(* the infinite repetitions of the singleton stream \<up>s consists only of the element s *)
lemma snth_sinftimes[simp]: "snth i (\<up>s\<infinity>) = s"
apply (induction i)
apply (simp) 
by (simp add: snth_rt)

(* dropping any finite number of elements from an infinite constant stream doesn't affect the stream *)
lemma sdrops_sinf[simp]: "sdrop i\<cdot>\<up>x\<infinity> = \<up>x\<infinity>"
apply (induction i)
apply(simp)
by (simp add: sdrop_forw_rt)

(* For a finite natural number "i", following relation between sntimes and stake holds:  *)
lemma sntimes_stake: "i \<star> \<up>x = stake i\<cdot>\<up>x\<infinity>"
apply(induction i)
apply simp
by (metis sinftimes_unfold sntimes.simps(2) stake_Suc) 

(* For every finite number "i" is sntimes \<noteq> sinftimes. *)
lemma snNEqSinf [simp]: "i \<star> \<up>x \<noteq> \<up>x\<infinity>"
by (metis lshd_sinf sdropostake sdrops_sinf sntimes_stake stream.sel_rews(3) up_defined)

(* for every natural number i, dropping the first (i*y) elements results in the same infinite stream *)
  (* the first i "blocks" of x are dropped *)
lemma sdrop_sinf[simp]: assumes "Fin y = #x"
  shows "sdrop (i * y)\<cdot>(sinftimes x) = x\<infinity>"
apply(induction i)
apply(simp)
by (metis assms mult_Suc sdrop_plus sdropl6 sinftimes_unfold) 

(* repeating the empty stream again produces the empty stream *)
lemma sinf_notEps[simp]: assumes "xs \<noteq> \<epsilon>" shows "(sinftimes xs) \<noteq> \<epsilon>"
using assms slen_sinftimes by fastforce

(* sinftimes has no effect on streams that are already infinite *)
(*removed simp because of lemma stakewhile_sinftimes_lemma*)
lemma sinf_inf: assumes "#s = \<infinity>" 
  shows "s\<infinity> = s"
by (metis assms sconc_fst_inf sinftimes_unfold)

(* sinftimes is idempotent *)
lemma sinf_dupE [simp]: "(sinftimes s) \<infinity> = (s\<infinity>)"
using sinf_inf slen_sinftimes by force

(* alternative unfold rule for sntimes, new element is appended on the end *)
lemma sntimes_Suc2: "(Suc i) \<star> s = (i\<star>s) \<bullet> s"
apply (induction i)
apply simp
by (metis assoc_sconc sntimes.simps(2))

(* Blockwise stake from sinftimes to sntimes. *)
lemma sinf2sntimes: assumes "Fin y = #x"
  shows "stake (i*y)\<cdot>(x\<infinity>) = i\<star>x"
apply(induction i)
apply simp
by (metis assms mult_Suc sdrop_plus sdrop_sinf sntimes.simps(2) stake_add stake_y) 

(* for any natural number i, sntimes is a prefix of sinftimes *)
lemma snT_le_sinfT [simp]: "i\<star>s \<sqsubseteq> s\<infinity>"
by (metis minimal monofun_cfun_arg ninf2Fin sconc_fst_inf sconc_snd_empty sinf2sntimes sinf_inf sntimes.simps(2) sntimes_Suc2 ub_stake)

(* repeating the stream s i times produces a prefix of repeating s i+1 times *)
lemma sntimes_leq: "i\<star>s \<sqsubseteq> (Suc i)\<star>s"
by (metis minimal monofun_cfun_arg sconc_snd_empty sntimes_Suc2)

(* the repetitions of a stream constitute a chain *)
lemma sntimes_chain: "chain (\<lambda>i. i\<star>s)"
by (meson po_class.chainI sntimes_leq)

(* xs is an infinite repetition of the finite stream x. Then dropping any fixed number i of repetitions
   of x leaves xs unchanged. *)
lemma sdrop_sinf2: assumes "xs = x\<bullet>xs" and "#x = Fin y"
  shows "sdrop (y*i)\<cdot>xs = xs"
apply (induction i)
apply simp 
by (metis assms mult_Suc_right sdrop_plus sdropl6) 

(* the recursive definition for a stream (xs = x\<bullet>xs) is identical to the infinite repetition of x at
   every multiple of the length of x *)
lemma stake_eq_sinf: assumes "xs = x\<bullet>xs" and "#x = Fin y" 
  shows "stake (i*y)\<cdot>xs = stake (i*y)\<cdot>(sinftimes x)"
proof (induction i)
  case 0 thus ?case by simp
next
  case (Suc i) 
  have drop_xs:"sdrop (i*y)\<cdot>xs = xs" by (metis assms mult.commute sdrop_sinf2) 

  have "stake (Suc i * y)\<cdot>xs  =  stake (i*y)\<cdot>xs \<bullet> stake y\<cdot>(sdrop (i*y)\<cdot>xs)" by (metis add.commute mult_Suc stake_add) 
  hence eq1:"stake (Suc i * y)\<cdot>xs =  stake (i*y)\<cdot>xs \<bullet> x"  by (metis approxl1 assms drop_xs minimal monofun_cfun_arg sconc_snd_empty)
  
  have "stake (Suc i * y)\<cdot>(sinftimes x) = stake (i*y)\<cdot>(sinftimes x) \<bullet> stake y\<cdot>(sdrop (i*y)\<cdot>(sinftimes x))"  
    by (metis add.commute mult_Suc stake_add)
  hence eq2:"stake (Suc i * y)\<cdot>(sinftimes x) =  stake (i*y)\<cdot>(sinftimes x) \<bullet> x" by (simp add: assms(2)) 

  thus ?case using Suc.IH eq1 by auto 
qed

(* when repeating a stream s a different number of times, one of the repetitions will be a prefix of
   the other *)
lemma stake_sntimes2sntimes: assumes "j\<le>k" and "#s = Fin y"
  shows "stake (j*y)\<cdot>(k\<star>s) = j\<star>s"
by (smt assms(1) assms(2) min_def mult_le_mono1 sinf2sntimes stakeostake)

(* For a stream s, a natural y and an arbitrary natural j, apply blockwise stake sntimes. *)
lemma lubStake2sn: assumes "#s = Fin y"
  shows "(\<Squnion> i. stake (y*j)\<cdot>(i\<star>s)) = j\<star>s" (is "(\<Squnion>i. ?c i) = _")
proof -
  have "max_in_chain j (\<lambda>i. ?c i)" by (simp add: assms max_in_chainI mult.commute stake_sntimes2sntimes) 
  thus ?thesis by (simp add: assms maxinch_is_thelub mult.commute sntimes_chain stake_sntimes2sntimes)  
qed

(* building block of the lemma sntimesLub_Fin *)
lemma sntimesChain: assumes "#s = Fin y" and "y \<noteq> 0"
  shows "\<forall>j. stake (y*j)\<cdot>(\<Squnion> i. i\<star>s) = stake (y*j)\<cdot> (s\<infinity>)"
by (metis assms(1) contlub_cfun_arg lubStake2sn mult.commute sinf2sntimes sntimes_chain)

lemma sntimesLub_Fin: assumes "#s = Fin y" and "y \<noteq> 0"
  shows "(\<Squnion> i. i\<star>s) = s\<infinity>"
proof - 
  have  "\<forall>j. stake (j*y)\<cdot>(\<Squnion> i. i\<star>s) = stake (j*y)\<cdot> (s\<infinity>)" by (metis assms(1) assms(2) mult.commute sntimesChain) 
  hence "\<forall>j. stake j\<cdot>(\<Squnion> i. i\<star>s) = stake j\<cdot> (s\<infinity>)" using assms by (metis gstake2stake)
  thus ?thesis by (simp add:  stream.take_lemma)
qed

(* for any stream s the LUB of sntimes is sinftimes *)
lemma sntimesLub[simp]:"(\<Squnion> i. i\<star>s) = s\<infinity>"
apply(cases "#s = \<infinity>")
apply (metis inf2max sconc_fst_inf sinf_inf sntimes.simps(2) sntimes_chain)
by (metis Fin_0 lncases lub_eq_bottom_iff slen_empty_eq sntimesLub_Fin sntimes_chain sntimes_eps strict_icycle)

(* shows that any recursive definition with the following form is equal to sinftimes *)
lemma rek2sinftimes: assumes "xs = x \<bullet> xs" and "x\<noteq>\<epsilon>"
  shows "xs = sinftimes x"
proof (cases "#x = \<infinity>")
  case True thus ?thesis by (metis assms(1) sconc_fst_inf sinftimes_unfold)
next
  case False 
  obtain y where y_def: "Fin y = #x \<and> y\<noteq>0"  by (metis False Fin_02bot assms(2) infI lnzero_def slen_empty_eq)
  hence "\<forall>i. stake (i*y)\<cdot>xs = stake (i*y)\<cdot>(x\<infinity>)" using assms(1) stake_eq_sinf by fastforce  
  hence "\<forall>i. stake i\<cdot>xs = stake i\<cdot>(x\<infinity>)" using gstake2stake y_def by blast 
  thus ?thesis by (simp add: stream.take_lemma)
qed

(* specializes the result from rek2sinftimes to singleton streams *)
lemma s2sinftimes: assumes "xs = \<up>x \<bullet> xs"
  shows "xs = \<up>x\<infinity>"
using assms rek2sinftimes by fastforce

(* shows that the infinite repetition of a stream x is the least fixed point of iterating (\<Lambda> s. x \<bullet> s),
   which maps streams to streams *)
lemma fix2sinf[simp]: "fix\<cdot>(\<Lambda> s. x \<bullet> s) = x\<infinity>"
by (metis eta_cfun fix_eq fix_strict rek2sinftimes sconc_snd_empty strict_icycle)

(* ----------------------------------------------------------------------- *)
subsection {* @{term smap} *}
(* ----------------------------------------------------------------------- *)

lemma strict_smap[simp]: "smap f\<cdot>\<epsilon> = \<epsilon>"
by (subst smap_def [THEN fix_eq2], simp)

(* smap distributes over concatenation *)
lemma smap_scons[simp]: "smap f\<cdot>(\<up>a \<bullet> s) = \<up>(f a) \<bullet> smap f\<cdot>s"
by (subst smap_def [THEN fix_eq2], simp)

lemma rek2smap: assumes "\<And>a as. f\<cdot>(\<up>a \<bullet> as) = \<up>(g a) \<bullet> f\<cdot>as"
  and "f\<cdot>\<bottom> = \<bottom>"
  shows "f\<cdot>s = smap g\<cdot>s"
apply(rule ind [of _s])
by(simp_all add: assms)

(* mapping f over a singleton stream is equivalent to applying f to the only element in the stream *) 
lemma [simp]: "smap f\<cdot>(\<up>a) = \<up>(f a)"
by (subst smap_def [THEN fix_eq2], simp)

(* smap leaves the length of a stream unchanged *)
lemma slen_smap[simp]: "#(smap f\<cdot>x) = #x"
by (rule ind [of _ x], auto)

text {* @{term smap} maps each element @{term x} to @{term "f(x)"} *}
lemma smap_snth_lemma:
  "Fin n < #s \<Longrightarrow> snth n (smap f\<cdot>s) = f (snth n s)"
apply (simp add: atomize_imp)
apply (rule_tac x="s" in spec)
apply (induct_tac n, simp+)
by (rule allI, rule_tac x="x" in scases, simp+)+

text{*Doing smap in two passes, applying h in the first pass and g in the second is
equivalent to applying g \<circ> h in a single pass*}
lemma smaps2smap: "smap g\<cdot>(smap h\<cdot>xs) =  smap (\<lambda> x. g (h x))\<cdot>xs"
by (simp add: smap_snth_lemma snths_eq)

text {* @{term sdrop} after @{term smap} is like @{term smap} after @{term sdrop} *}
lemma sdrop_smap[simp]: "sdrop k\<cdot>(smap f\<cdot>s) = smap f\<cdot>(sdrop k\<cdot>s)"
apply (rule_tac x="k" in spec)
apply (rule ind [of _ s], simp+)
apply (rule allI)
by (case_tac "x", simp+)

text {* @{term "smap f"} is a homomorphism on streams with respect to concatenation *}
lemma smap_split: "smap f\<cdot>(a \<bullet> b) = (smap f\<cdot>a) \<bullet> (smap f\<cdot>b)"
proof (rule lncases [of "#a"], simp)
  fix k assume "#a = Fin k"
  thus ?thesis by (rule Streams.finind [of "a"], simp_all)
qed

(* smap distributes over infinite repetition *)
lemma smap2sinf[simp]: "smap f\<cdot>(x\<infinity>)= (smap f\<cdot>x)\<infinity>"
by (metis (no_types) rek2sinftimes sinftimes_unfold slen_empty_eq slen_smap smap_split strict_icycle)

lemma l5: "smap g\<cdot>\<up>x\<infinity> = \<up>(g x)\<infinity>"
  by simp
(* ----------------------------------------------------------------------- *)
subsection {* @{term sprojfst} and @{term sprojsnd} *}
(* ----------------------------------------------------------------------- *)

text {* basic properties of @{term sprojfst} *}

(* sprojfst extracts the first element of the first tuple in any non-empty stream of tuples *)
lemma sprojfst_scons[simp]: "sprojfst\<cdot>(\<up>(x, y) \<bullet> s) = \<up>x \<bullet> sprojfst\<cdot>s"
by (unfold sprojfst_def, simp)

(* the empty stream is a fixed point of sprojfst *)
lemma strict_sprojfst[simp]: "sprojfst\<cdot>\<epsilon> = \<epsilon>"
by (unfold sprojfst_def, simp)

(* sprojfst extracts the first element of any singleton tuple-stream *)
lemma [simp]: "sprojfst\<cdot>(\<up>(a,b)) = \<up>a"
by (simp add: sprojfst_def)

text {* same properties for @{term sprojsnd} *}

(* sprojsnd extracts the second element of the first tuple in any non-empty stream of tuples *)
lemma sprojsnd_scons[simp]: "sprojsnd\<cdot>(\<up>(x,y) \<bullet> s) = \<up>y \<bullet> sprojsnd\<cdot>s"
by (unfold sprojsnd_def, simp)

(* the empty stream is a fixed point of sprojsnd *)
lemma strict_sprojsnd[simp]: "sprojsnd\<cdot>\<epsilon> = \<epsilon>"
by (unfold sprojsnd_def, simp)

(* sprojsnd extracts the second element of any singleton tuple-stream *)
lemma [simp]: "sprojsnd\<cdot>(\<up>(a,b)) = \<up>b"
by (simp add: sprojsnd_def)

text {* @{term sprojfst} / @{term sprojsnd} and @{term srt} commute *}

lemma rt_Sproj_2_eq: "sprojsnd\<cdot>(srt\<cdot>x) = srt\<cdot>(sprojsnd\<cdot>x)"
by (rule ind [of _ x], auto)

lemma rt_Sproj_1_eq: "sprojfst\<cdot>(srt\<cdot>x) = srt\<cdot>(sprojfst\<cdot>x)"
by (rule ind [of _ x], auto)

text {* length of projections and the empty stream *}

lemma slen_sprojs_eq: "#(sprojsnd\<cdot>x) = #(sprojfst\<cdot>x)"
by (rule ind [of _ "x"], auto)

lemma strict_rev_sprojfst: "sprojfst\<cdot>x = \<epsilon> \<Longrightarrow> x = \<epsilon>"
by (rule ccontr, rule_tac x=x in scases, auto)

lemma strict_rev_sprojsnd: "sprojsnd\<cdot>x = \<epsilon> \<Longrightarrow> x = \<epsilon>"
by (rule ccontr, rule_tac x=x in scases, auto)

lemma slen_sprojfst: "#(sprojfst\<cdot>x) = #x"
by (rule ind [of _ "x"], auto)

lemma slen_sprojsnd: "#(sprojsnd\<cdot>x) = #x"
by (rule ind [of _ "x"], auto)

(* ----------------------------------------------------------------------- *)
subsection {* @{term sfilter} *}
(* ----------------------------------------------------------------------- *)

text {* basic properties of @{term sfilter} *}

(* note that M is a set, not a predicate *)

lemma strict_sfilter[simp]: "sfilter M\<cdot>\<epsilon> = \<epsilon>"
by (subst sfilter_def [THEN fix_eq2], simp)

(* if the head of a stream is in M, then sfilter will keep the head *)
lemma sfilter_in[simp]: 
  "a \<in> M \<Longrightarrow> sfilter M\<cdot>(\<up>a \<bullet> s) = \<up>a \<bullet> sfilter M\<cdot>s" 
by (subst sfilter_def [THEN fix_eq2], simp)

(* if the head of a stream isn't in M, then sfilter will discard the head *)
lemma sfilter_nin[simp]: 
  "a \<notin> M \<Longrightarrow> sfilter M\<cdot>(\<up>a \<bullet> s) = sfilter M\<cdot>s" 
by (subst sfilter_def [THEN fix_eq2], simp)

(* if the sole element in a singleton stream is in M then sfilter is a no-op *)
lemma [simp]: "a \<in> M \<Longrightarrow> sfilter M\<cdot>(\<up>a) = \<up>a"
by (subst sfilter_def [THEN fix_eq2], simp)

(* if the sole element in a singleton stream is not in M then sfilter produces the empty stream *)
lemma [simp]: "a \<notin> M \<Longrightarrow> sfilter M\<cdot>(\<up>a) = \<epsilon>"
by (subst sfilter_def [THEN fix_eq2], simp)

text {* @{term sfilter} and @{term sinftimes} *}

(* filtering all elements that aren't in {a} from a stream consisting only of the element a has no effect *)
lemma sfilter_sinftimes_in[simp]: 
  "sfilter {a}\<cdot>(sinftimes (\<up>a)) = sinftimes (\<up>a)"
apply (rule stream.take_lemma)
apply (induct_tac n, auto)
apply (subst sinftimes_unfold, simp)
apply (rule sym)
by (subst sinftimes_unfold, simp)

(* if the element a isn't in the set F then filtering a stream of infinitely many a's using F will
   produce the empty stream *)
lemma sfilter_sinftimes_nin:
  "a \<notin> F \<Longrightarrow> (F \<ominus> (sinftimes (\<up>a))) = \<epsilon>"
proof -
  assume a_nin_F: "a \<notin> F"
  have "\<And>i. (F \<ominus> (stake i\<cdot>(sinftimes (\<up>a)))) = \<epsilon>"
  proof (induct_tac i, simp_all)
    fix n assume "F \<ominus> (stake n\<cdot>(sinftimes (\<up>a))) = \<epsilon>"
    hence "F \<ominus> (stake (Suc n)\<cdot>(\<up>a \<bullet> sinftimes (\<up>a))) = \<epsilon>" using a_nin_F by simp
    thus "F \<ominus> stake (Suc n)\<cdot>(sinftimes (\<up>a)) = \<epsilon>" by (subst sinftimes_unfold)
  qed
  hence "(F \<ominus> (\<Squnion>i. stake i\<cdot>(sinftimes (\<up>a)))) = \<epsilon>" by (simp add:contlub_cfun_arg)
  thus ?thesis by (simp add: reach_stream)
qed

text {* Filtering a postfix is at most as long as filtering the whole stream *}
lemma slen_sfilter_sdrop_ile: 
  "#(sfilter X\<cdot>(sdrop n\<cdot>p)) \<le> #(sfilter X\<cdot>p)"
apply (rule spec [where x = "n"])
apply (rule ind [of _ p], auto)
apply (subst lnle_def, simp del: lnle_conv)
apply (case_tac "x", auto)
apply (case_tac "a \<in> X", auto)
apply (erule_tac x="nat" in allE)
by (rule trans_lnle, auto)

text {* If the filtered stream is infinite, each filtered postfix is infinite *}
lemma slen_sfilter_sdrop: 
  "\<forall>p X. #(sfilter X\<cdot>p) = \<infinity> \<longrightarrow> #(sfilter X\<cdot>(sdrop n\<cdot>p)) = \<infinity>" 
apply (induct_tac n, auto)
apply (rule_tac x=p in scases, auto)
by (case_tac "a\<in>X", auto)

text {* @{term sfilter} on @{term "stake n"} returns @{text "\<epsilon>"} if none of the first
  @{term n} elements is included in the filter *}
lemma sfilter_empty_snths_nin_lemma: 
  "\<forall>p. (\<forall>n. Fin n < #p \<longrightarrow> snth n p \<notin> X) \<longrightarrow> sfilter X\<cdot>(stake k\<cdot>p) = \<epsilon>"
apply (induct_tac k, auto)
apply (rule_tac x=p in scases, auto)
apply (case_tac "a\<in>X", auto)
apply (erule_tac x="0" in allE, simp)
apply (case_tac "n", auto)
apply (erule_tac x="s" in allE, auto)
by (erule_tac x="Suc n" in allE, auto)

text {* @{term sfilter} returns @{text "\<epsilon>"} if no element is included in the filter *}
lemma ex_snth_in_sfilter_nempty:
  "(\<forall>n. Fin n < #p \<longrightarrow> snth n p \<notin> X) \<Longrightarrow> sfilter X\<cdot>p = \<epsilon>"
apply (subgoal_tac "sfilter X\<cdot>p = (\<Squnion>k. sfilter X\<cdot>(stake k\<cdot>p))")
apply (erule ssubst)
apply (subst lub_eq_bottom_iff, simp)
apply (subst sfilter_empty_snths_nin_lemma, simp+)
apply (subst contlub_cfun_arg [THEN sym], simp)
by (simp add: reach_stream)

text {* The filtered stream is at most as long as the original one *}
lemma slen_sfilterl1: "#(sfilter S\<cdot>x) \<le> #x"
apply (rule ind [of _ x], auto)
apply (subst lnle_def, simp del: lnle_conv)
apply (case_tac "a \<in> S", auto)
by (rule trans_lnle, auto)

text {* If the filtered stream is infinite, the original one is infinite as well *}
lemma sfilterl4:
  "#(sfilter X\<cdot>x) = \<infinity> \<Longrightarrow> #x = \<infinity>"
by (insert slen_sfilterl1 [of X x], auto)

text {* Prepending to the original stream never shortens the filtered result *}
lemma sfilterl2: 
  "\<forall>z. #(sfilter X\<cdot>s) \<le> #(sfilter X\<cdot>((stake n\<cdot>z) \<bullet> s))"
apply (induct_tac n, auto)
apply (rule_tac x=z in scases, auto)
apply (case_tac "a\<in>X", auto)
apply (erule_tac x="sa" in allE)
by (drule trans_lnle, auto) 

text {* The filtered result is not changed by concatenating streams which are
  filtered to @{text "\<epsilon>"} *}
lemma sfilterl3:
  "\<forall>s. #s = Fin k \<and> sfilter S\<cdot>s = \<epsilon> \<longrightarrow> 
       sfilter S\<cdot>(s\<bullet>Z) = sfilter S\<cdot>Z" 
apply (induct_tac k, auto)
apply (rule_tac x=s in scases, auto)
by (case_tac "a \<in> S", auto)

text {* A stream can be split by @{term stake} and @{term sdrop} for filtering *}
lemma split_sfilter: "sfilter X\<cdot>x = sfilter X\<cdot>(stake n\<cdot>x) \<bullet> sfilter X\<cdot>(sdrop n\<cdot>x)"
apply (rule_tac x=x in spec)
apply (induct_tac n, simp)
apply (rule allI)
apply (rule_tac x=x in scases, simp)
apply (erule_tac x="s" in allE, auto)
by (case_tac "a \<in> X", auto)

text {* double filtering *}
lemma int_sfilterl1[simp]: "sfilter S\<cdot>(sfilter M\<cdot>s) = sfilter (S \<inter> M)\<cdot>s"
apply (rule ind [of _ s], auto)
apply (case_tac "a \<in> S \<inter> M", auto)
by (case_tac "a \<in> M", auto)

text {* Streams can be split for filtering *}
lemma add_sfilter:
  "#x = Fin k \<Longrightarrow> sfilter t\<cdot>(x \<bullet> y) = sfilter t\<cdot>x \<bullet> sfilter t\<cdot>y"
apply (simp add: atomize_imp)
apply (rule_tac x="y" in spec)
apply (rule_tac x="x" in spec)
apply (induct_tac k, auto)
apply (rule_tac x="x" in scases, auto)
by (case_tac "a \<in> t", auto)

text {* After applying @{term "smap f"}, all elements are in the range of @{term f} *}
lemma sfilter_smap_nrange: 
  "m \<notin> range f \<Longrightarrow> sfilter {m}\<cdot>(smap f\<cdot>x) = \<epsilon>"
apply (rule ex_snth_in_sfilter_nempty [rule_format], simp)
apply (subst smap_snth_lemma, simp+)
apply (rule notI)
apply (drule sym)
by (drule_tac f="f" in range_eqI, simp)

(* ----------------------------------------------------------------------- *)
subsection {* @{term stakewhile} *}
(* ----------------------------------------------------------------------- *)

text {* basic properties of @{term stakewhile} *}

lemma strict_stakewhile[simp]: "stakewhile f\<cdot>\<epsilon> = \<epsilon>"
by (subst stakewhile_def [THEN fix_eq2], simp)

(* if the head a passes the predicate f, then the result of stakewhile will start with \<up>a *)
lemma stakewhile_t[simp]: "f a \<Longrightarrow> stakewhile f\<cdot>(\<up>a \<bullet> s) = \<up>a \<bullet> stakewhile f\<cdot>s"
by (subst stakewhile_def [THEN fix_eq2], simp)

(* if the head a fails the predicate f, then stakewhile will produce the empty stream *)
lemma stakewhile_f[simp]: "\<not>f a \<Longrightarrow> stakewhile f\<cdot>(\<up>a \<bullet> s) = \<epsilon>"
by (subst stakewhile_def [THEN fix_eq2], simp)

(* if the element a passes the predicate f, then stakewhile applied to \<up>a is a no-op *)
lemma [simp]: "f a \<Longrightarrow> stakewhile f\<cdot>(\<up>a) = \<up>a"
by (subst stakewhile_def [THEN fix_eq2], simp)

(* if the element a fails the predicate f, then stakewhile applied to \<up>a will produce the empty stream *)
lemma [simp]: "\<not>f a \<Longrightarrow> stakewhile f\<cdot>(\<up>a) = \<epsilon>"
by (subst stakewhile_def [THEN fix_eq2], simp)

(* stakewhile can't increase the length of a stream *)
lemma stakewhile_less [simp]: "#(stakewhile f\<cdot>s)\<le>#s"
apply(rule ind [of _ s], auto)
apply (metis (mono_tags, lifting) admI inf_chainl4 inf_ub l42)
by (metis bot_is_0 lnle_def lnsuc_lnle_emb minimal slen_empty_eq slen_scons stakewhile_f stakewhile_t)

(* stakewhile doesn't take elements past an element that fails the predicate f *)
lemma stakewhile_slen[simp]: "\<not>f (snth n s) \<Longrightarrow> #(stakewhile f\<cdot>s)\<le>Fin n"
apply(induction n arbitrary: s)
apply (metis Fin_02bot lnat_po_eq_conv lnzero_def sdrop_0 slen_empty_eq snth_def stakewhile_f strict_stakewhile surj_scons)
by (smt inject_scons slen_rt_ile_eq snth_rt stakewhile_f stakewhile_t stream.take_strict strict_stakewhile surj_scons ub_slen_stake)

(* the prefix of the constant stream of x's whose elements aren't equal to x is empty *)
lemma [simp]: "stakewhile (\<lambda>a. a \<noteq> x)\<cdot>\<up>x\<infinity> = \<epsilon>"
by (metis sinftimes_unfold stakewhile_f)

(* stakewhile produces a prefix of the input *)
lemma stakewhile_below[simp]: "stakewhile f\<cdot>s \<sqsubseteq> s"
apply(induction s)
apply(simp+)
by (smt minimal monofun_cfun_arg stakewhile_f stakewhile_t stream.con_rews(2) stream.sel_rews(5) surj_scons)

(* if stakewhile leaves a stream s unchanged, then every element must pass the predicate f *) 
lemma stakewhile_id_snth: assumes "stakewhile f\<cdot>s = s" and "Fin n < #s"
shows "f (snth n s)"
by (metis Fin_leq_Suc_leq assms(1) assms(2) less2eq less2lnleD lnless_def stakewhile_slen)

(* if stakewhile produces a result of length n or greater, then the nth element in s must pass f *)
lemma stakewhile_snth[simp]: assumes  "Fin n < #(stakewhile f\<cdot>s)"
shows "f (snth n s)"
by (meson assms not_less stakewhile_slen)

(* if stakewhile changes the stream s, then there must be an element in s that fails the predicate f *)
lemma stakewhile_notin [simp]: 
  shows "stakewhile f\<cdot>s \<noteq> s \<Longrightarrow> #(stakewhile f\<cdot>s) = Fin n \<Longrightarrow> \<not> f (snth n s)"
  apply(induction n arbitrary:s)
   apply (metis Fin_02bot lnat.con_rews slen_scons snth_shd stakewhile_t surj_scons)
  by (smt Fin_02bot Fin_Suc approxl2 inject_scons lnat.con_rews lnat_po_eq_conv lnsuc_lnle_emb lnzero_def slen_empty_eq slen_rt_ile_eq snth_rt snth_shd stakewhile_below stakewhile_slen stakewhile_t stream.take_strict surj_scons ub_slen_stake)



(* ----------------------------------------------------------------------- *)
subsection {* @{term stwbl} *}
(* ----------------------------------------------------------------------- *)

text {* basic properties for @{term stwbl} *}

lemma strict_stwbl[simp]: "stwbl f\<cdot>\<epsilon> = \<epsilon>"
by (subst stwbl_def [THEN fix_eq2], simp)

(* if the head a passes the predicate f, then the result of stwbl will start with \<up>a *)
lemma stwbl_t[simp]: "f a \<Longrightarrow> stwbl f\<cdot>(\<up>a \<bullet> s) = \<up>a \<bullet> stwbl f\<cdot>s"
by (subst stwbl_def [THEN fix_eq2], simp)

(* if the head a fails the predicate f, then stwbl will produce only \<up>a *)
lemma stwbl_f[simp]: "\<not> f a \<Longrightarrow> stwbl f\<cdot>(\<up>a \<bullet> s) = \<up>a"
by (subst stwbl_def [THEN fix_eq2], simp)

lemma stwbl_notEps: "s\<noteq>\<epsilon> \<Longrightarrow> (stwbl f\<cdot>s)\<noteq>\<epsilon>"
by (smt lnat.con_rews lnzero_def sconc_snd_empty slen_scons strict_slen stwbl_f stwbl_t surj_scons)

lemma stwbl_eps: "stwbl f\<cdot>s = \<epsilon> \<longleftrightarrow> s=\<epsilon>"
using strict_stwbl stwbl_notEps by blast

text {* @{term sfilter} after @{term stakewhile}: produce the empty stream *}
lemma sfilter_twl1[simp]: 
  "sfilter X\<cdot>(stakewhile (\<lambda>x. x\<notin>X)\<cdot>p) = \<epsilon>"
apply (rule ind [of _ p], auto)
by (case_tac "a\<in>X", auto)

text {* @{term sfilter} after @{term stakewhile}: redundant filtering *}
lemma sfilter_twl2[simp]: 
  "sfilter X\<cdot>(stakewhile (\<lambda>x. x\<in>X)\<cdot>p) = stakewhile (\<lambda>x. x\<in>X)\<cdot>p"
apply (rule ind [of _ p], auto)
by (case_tac "a\<in>X", auto)

text {* If @{term "stakewhile (\<lambda>p. p = t)"} returns an infinite stream, all prefixes
  of the original stream only consist of "@{term t}"s *}
lemma stakewhile_sinftimes_lemma: 
  "\<forall>z. #(stakewhile (\<lambda>p. p = t)\<cdot>z) = \<infinity> \<longrightarrow> stake n\<cdot>z = stake n\<cdot>(sinftimes (\<up>t))"
apply (induct_tac n, auto)
apply (subst sinftimes_unfold, simp)
apply (rule_tac x=z in scases, auto)
by (case_tac "a=t", auto)

text {* If @{term "stakewhile (\<lambda>p. p = t)"} returns an infinite stream, the original stream
  is an infinite "@{term t}"-stream *}
lemma stakewhile_sinftimesup: 
  "#(stakewhile (\<lambda>p. p = t)\<cdot>z) = \<infinity> \<Longrightarrow> z = sinftimes (\<up>t)"
apply (rule stream.take_lemma)
by (rule stakewhile_sinftimes_lemma [rule_format])

(* ----------------------------------------------------------------------- *)
subsection {* @{term sdropwhile} *}
(* ----------------------------------------------------------------------- *)

text {* basic properties for @{term sdropwhile} *}

lemma strict_sdropwhile[simp]: "sdropwhile f\<cdot>\<epsilon> = \<epsilon>"
by (subst sdropwhile_def [THEN fix_eq2], simp)

(* if the head a passes the predicate f, then the result of sdropwhile will drop the head *)
lemma sdropwhile_t[simp]: "f a \<Longrightarrow> sdropwhile f\<cdot>(\<up>a \<bullet> s) = sdropwhile f\<cdot>s"
by (subst sdropwhile_def [THEN fix_eq2], simp)

(* if the head a fails the predicate f, then the result of sdropwhile will start with \<up>a *)
lemma sdropwhile_f[simp]: "\<not>f a \<Longrightarrow> sdropwhile f\<cdot>(\<up>a \<bullet> s) = \<up>a \<bullet> s"
by (subst sdropwhile_def [THEN fix_eq2], simp)

(* if the only element in a singleton stream passes the predicate f, then sdropwhile will produce
   the empty stream *)
lemma [simp]: "f a \<Longrightarrow> sdropwhile f\<cdot>(\<up>a) = \<epsilon>"
by (subst sdropwhile_def [THEN fix_eq2], simp)

(* if the only element in a singleton stream fails the predicate f, then sdropwhile will be a no-op *)
lemma [simp]: "\<not>f a \<Longrightarrow> sdropwhile f\<cdot>(\<up>a) = \<up>a"
by (subst sdropwhile_def [THEN fix_eq2], simp)

text {* special cases of @{term sfilter} after @{term sdropwhile} *}

(* the elements removed by sdropwhile are a subset of the elements removed by sfilter *)
lemma sfilter_dwl1[simp]: 
  "sfilter X\<cdot>(sdropwhile (\<lambda>x. x\<notin>X)\<cdot>p) = sfilter X\<cdot>p"
apply (rule ind [of _ p], auto)
by (case_tac "a\<in>X", auto)

(* the elements kept by sfilter are a subset of the elements kept by sdropwhile *)
lemma sfilter_dwl2:
  "sfilter T\<cdot>s \<noteq> \<epsilon> \<Longrightarrow> sdropwhile (\<lambda>a. a \<notin> T)\<cdot>s \<noteq> \<epsilon>"
apply (rule notI)
apply (erule notE)
apply (subst sfilter_dwl1 [THEN sym])
by simp

text {* Construct @{term stwbl} from @{term stakewhile}, @{term stake} and @{term sdropwhile} *}
lemma stwbl_stakewhile: "stwbl f\<cdot>s = stakewhile f\<cdot>s \<bullet> (stake (Suc 0)\<cdot>(sdropwhile f\<cdot>s))"
apply (rule stream.take_lemma)
apply (rule_tac x="s" in spec)
apply (induct_tac n, simp+)
apply (rule allI)
apply (rule_tac x="x" in scases, simp+)
by (case_tac "f a", simp+)

text {* Constructing @{term sdropwhile} from @{term stakewhile} and @{term sdrop} *}
lemma stakewhile_sdropwhilel1:
  "\<forall>x. #(stakewhile f\<cdot>x) = Fin n \<longrightarrow> sdropwhile f\<cdot>x = sdrop n\<cdot>x"  
apply (induct_tac n, auto)
apply (rule_tac x=x in scases, auto)
apply (case_tac "f a", auto)
apply (rule_tac x=x in scases, auto)
by (case_tac "f a", auto)

text {* @{term sdropwhile} is idempotent *}
lemma sdropwhile_idem: "sdropwhile f\<cdot>(sdropwhile f\<cdot>x) = sdropwhile f\<cdot>x"
apply (rule ind [of _ x], auto)
by (case_tac "f a", auto)

text {* @{term stakewhile} after @{term sdropwhile} gives the empty stream *}
lemma tdw[simp]: "stakewhile f\<cdot>(sdropwhile f\<cdot>s) = \<epsilon>"
apply (rule ind [of _ s], auto)
by (case_tac "f a", auto)

lemma stakewhileDropwhile[simp]: "stakewhile f\<cdot>s \<bullet> (sdropwhile f\<cdot>s) = s "
apply(rule ind [of _s])
apply (rule admI)
apply (metis (no_types, lifting) approxl2 inf_chainl4 lub_eqI lub_finch2 sconc_fst_inf split_streaml1 stakewhile_below stakewhile_sdropwhilel1)
apply simp
by (metis assoc_sconc sconc_fst_empty sdropwhile_f sdropwhile_t stakewhile_t tdw)

text {* For the head of @{term "sdropwhile f\<cdot>x"}, @{term f} does not hold *}
lemma sdropwhile_resup: "sdropwhile f\<cdot>x = \<up>a \<bullet> s \<Longrightarrow> \<not> f a"
apply (subgoal_tac "sdropwhile f\<cdot>(\<up>a \<bullet> s) = \<up>a \<bullet> s")
apply (case_tac "f a", auto)
apply rotate_tac
apply (drule cfun_arg_cong [of _ _ "stakewhile f"], simp)
apply (drule sym, simp)
by (rule sdropwhile_idem)

text {* elimination rule for @{term sfilter} after @{term sdropwhile} *}
lemma sfilter_srtdwl3[simp]: 
  "sfilter X\<cdot>(srt\<cdot>(sdropwhile (\<lambda>x. x\<notin>X)\<cdot>p)) = srt\<cdot>(sfilter X\<cdot>p)"
apply (rule ind [of _ p], auto)
by (case_tac "a\<in>X", auto)

text {* Further results concerning @{term sfilter} *}

text {* After filtering by filter @{term T}, the head of the result is in @{term T}
  (for non-empty results) *}
lemma sfilter_ne_resup: "sfilter T\<cdot>s \<noteq> \<epsilon> \<Longrightarrow> shd (sfilter T\<cdot>s) \<in> T"
apply (subst sfilter_dwl1 [THEN sym])
apply (rule_tac x="sdropwhile (\<lambda>x. x \<notin> T)\<cdot>s" in scases, auto)
apply (drule sfilter_dwl2, simp)
apply (rule_tac x="s" in scases, auto)
apply (case_tac "aa \<in> T", auto)
apply (drule inject_scons, simp)
by (drule sdropwhile_resup, simp)

text {* same result for @{term sconc} syntax *}
lemma sfilter_resl2:
  "sfilter T\<cdot>s = \<up>a \<bullet> as \<Longrightarrow> a \<in> T"
apply (case_tac "sfilter T\<cdot>s = \<epsilon>", simp)
by (drule sfilter_ne_resup, simp)

text {* After filtering with filter @{term T}, each element is in @{term T} *}
lemma sfilterl7:
  "\<lbrakk>Fin n < #x; sfilter T\<cdot>s = x\<rbrakk> \<Longrightarrow> snth n x \<in> T"
apply (simp add: atomize_imp)
apply (rule_tac x="s" in spec)
apply (rule_tac x="x" in spec)
apply (induct_tac n, auto)
apply (rule sfilter_ne_resup)
apply (rule_tac x="sfilter T\<cdot>xa" in scases, auto)
apply (rule_tac x="xa" in scases, auto)
apply (simp add: Fin_Suc [THEN sym] del: Fin_Suc)
apply (case_tac "a \<in> T", auto)
apply (case_tac "sfilter T\<cdot>s = \<epsilon>",simp+)
apply (simp add: Fin_Suc [THEN sym] del: Fin_Suc)
apply (rule_tac x="sfilter T\<cdot>s" in scases, auto)
apply (erule_tac x="sa" in allE,simp+)
apply (frule sfilter_resl2)
apply (drule mp)
by (rule_tac x="srt\<cdot>(sdropwhile (\<lambda>x. x\<notin>T)\<cdot>s)" in exI,simp+)

(* ----------------------------------------------------------------------- *)
subsection {* @{term srtdw} *}
(* ----------------------------------------------------------------------- *)

text {* basic properties of @{term srtdw} *}

lemma [simp]: "srtdw f\<cdot>\<epsilon> = \<epsilon>"
by (simp add: srtdw_def)

(* the rest of any singleton stream is the empty stream, regardless of whether the only element in
   the stream was dropped *)
lemma [simp]: "srtdw f\<cdot>(\<up>a) = \<epsilon>"
apply (simp add: srtdw_def)
by (case_tac "f a", auto)

(* if the head a passes the predicate f, srtdw will drop the head *)
lemma [simp]: "f a \<Longrightarrow> srtdw f\<cdot>(\<up>a\<bullet>as) = srtdw f\<cdot>as"
by (auto simp add: srtdw_def)

(* if the head a fails the predicate f, srtdw will produce the rest of the stream *)
lemma [simp]: "\<not> f a \<Longrightarrow> srtdw f\<cdot>(\<up>a\<bullet>as) = as"
by (simp add: srtdw_def)

text {* @{term "sfilter M"} after @{term "srtdw (\<lambda>x. x \<notin> M)"} almost behaves
  like @{term "sfilter M"} alone *}
lemma sfilterl8:
  "sfilter M\<cdot>x \<noteq> \<epsilon> \<Longrightarrow>
    #(sfilter M\<cdot>x) = lnsuc\<cdot>(#(sfilter M\<cdot>(srtdw (\<lambda>x. x \<notin> M)\<cdot>x)))"
apply (simp add: atomize_imp)
apply (rule ind [of _ x], simp+)
apply (rule impI)
by (case_tac "a \<in> M", simp+)

text {* similar result for infinite streams *}
lemma sfilter_srtdwl2:
  "#(sfilter X\<cdot>s) = \<infinity> \<Longrightarrow> #(sfilter X\<cdot>(srtdw (\<lambda>a. a \<notin> X)\<cdot>s)) = \<infinity>"
apply (case_tac "sfilter X\<cdot>s = \<epsilon>", auto)
by (drule sfilterl8, auto)

text {* streams can be split by @{term stwbl} and @{term srtdw} *}
lemma stwbl_srtdw: "stwbl f\<cdot>s \<bullet> srtdw f\<cdot>s = s"
apply (rule stream.take_lemma)
apply (rule_tac x="s" in spec)
apply (induct_tac n, simp+)
apply (rule allI)
apply (rule_tac x="x" in scases, simp+)
by (case_tac "f a", simp+)

lemma slen_srtdw: "#(srtdw f\<cdot>x) \<le> #x"
apply (rule ind [of _ x])
apply (subst lnle_conv [THEN sym], simp del: lnle_conv, simp)
apply (case_tac "f a", simp+)
by (rule trans_lnle, simp+)

(* stwbl produces a prefix of the input *)
lemma stwbl_below [simp]: "stwbl f\<cdot>s \<sqsubseteq> s"
by (metis (no_types) minimal monofun_cfun_arg sconc_snd_empty stwbl_srtdw)

lemma srtdw_stwbl [simp]: "srtdw f\<cdot> (stwbl f\<cdot>s) = \<epsilon>" (is "?F s")
proof(rule ind [of _s ])
  show "adm ?F" by simp
  show "?F \<epsilon>" by simp
  fix a
  fix s
  assume IH: "?F s"
  thus "?F (\<up>a \<bullet> s)" 
  proof (cases "f a")
    case True thus ?thesis by (simp add: IH)
  next
    case False thus ?thesis by simp
  qed
qed

(* ----------------------------------------------------------------------- *)
subsection {* @{term srcdups} *}
(* ----------------------------------------------------------------------- *)

text {* Basic simplification rules for @{term srcdups} *}

lemma strict_srcdups[simp]: "srcdups\<cdot>\<epsilon> = \<epsilon>" 
by (subst srcdups_def [THEN fix_eq2], simp)

(* a singleton stream can't possibly contain duplicates *)
lemma [simp]: "srcdups\<cdot>(\<up>a) = \<up>a"
by (subst srcdups_def [THEN fix_eq2], simp)

(* if the head a of a stream is followed by a duplicate, only one of the two elements will be kept by srcdups *)
lemma srcdups_eq[simp]: "srcdups\<cdot>(\<up>a\<bullet>\<up>a\<bullet>s) = srcdups\<cdot>(\<up>a\<bullet>s)" 
apply (subst srcdups_def [THEN fix_eq2], simp)
by (rule sym, subst srcdups_def [THEN fix_eq2], simp)

(* if the head a of a stream is followed by a distinct element, both elements will be keypt by srcdups *)
lemma srcdups_neq[simp]: 
  "a\<noteq>b \<Longrightarrow> srcdups\<cdot>(\<up>a \<bullet> \<up>b \<bullet> s) = \<up>a \<bullet>  srcdups\<cdot>(\<up>b \<bullet> s)" 
by (subst srcdups_def [THEN fix_eq2], simp)

(* ----------------------------------------------------------------------- *)
subsection {* @{term sscanl} *}
(* ----------------------------------------------------------------------- *)

lemma SSCANL_empty[simp]: "SSCANL n f q \<epsilon> = \<epsilon>"
by (induct_tac n, auto)

text {* monotonicity of SSCANL *}
lemma mono_SSCANL: 
  "\<forall> x y q. x \<sqsubseteq> y \<longrightarrow> SSCANL n f q x \<sqsubseteq> SSCANL n f q y"
apply (induct_tac n, auto)
apply (drule lessD, erule disjE, simp)
apply (erule exE)+
apply (erule conjE)+
by (simp, rule monofun_cfun_arg, simp)

text {* result of @{term "SSCANL n"} only depends on first @{term n}
  elements of input stream *}
lemma contlub_SSCANL:
  "\<forall>f q s. SSCANL n f q s = SSCANL n f q (stake n\<cdot>s)"
apply (induct_tac n, auto)
apply (rule_tac x=s in scases)
apply auto
apply (rule_tac x=s in scases)
by auto

text {* @{term SSCANL} is a chain. This means that, for all fixed inputs,
  @{term "SSCANL i"} returns a prefix of @{term "SSCANL (Suc i)"} *}
lemma chain_SSCANL: "chain SSCANL"
apply (rule chainI)
apply (subst fun_below_iff)+
apply (induct_tac i, auto)
apply (rule monofun_cfun_arg)
apply (erule_tac x="x" in allE)
apply (erule_tac x="x xa (shd xb)" in allE)
by (erule_tac x="srt\<cdot>xb" in allE, auto)

text {* @{term sscanl} is a continuous function *}
lemma cont_lub_SSCANL: "cont (\<lambda>s. \<Squnion>i. SSCANL i f q s)" 
apply (rule cont2cont_lub)
apply (rule ch2ch_fun)
apply (rule chainI)
apply (rule fun_belowD [of _ _ "q"])
apply (rule fun_belowD [of _ _ "f"])
apply (rule chainE)
apply (rule chain_SSCANL)
apply (rule pr_contI)
apply (rule monofunI)
apply (rule mono_SSCANL [rule_format], assumption)
apply (rule allI)
apply (rule_tac x="i" in exI)
by (rule contlub_SSCANL [rule_format])

text {* Basic simplification rules for @{term sscanl} *}

lemma sscanl_empty[simp]: "sscanl f q\<cdot>\<epsilon> = \<epsilon>"
apply (simp add: sscanl_def)
apply (subst beta_cfun, rule cont_lub_SSCANL)
by (subst is_lub_const 
  [THEN lub_eqI, of "\<epsilon>", THEN sym], simp)

(* scanning \<up>a\<bullet>s using q as the initial element is equivalent to computing \<up>(f q a) and appending the
   result of scanning s with (f q a) as the initial element *)
lemma sscanl_scons[simp]: 
  "sscanl f q\<cdot>(\<up>a\<bullet>s) = \<up>(f q a) \<bullet> sscanl f (f q a)\<cdot>s"  
apply (simp add: sscanl_def)
apply (subst beta_cfun, rule cont_lub_SSCANL)+
apply (subst contlub_cfun_arg)
apply (rule ch2ch_fun, rule ch2ch_fun)
apply (rule chainI)
apply (rule fun_belowD [of _ _ "f"])
apply (rule chain_SSCANL [THEN chainE])
apply (subst lub_range_shift [where j="Suc 0", THEN sym])
apply (rule ch2ch_fun, rule ch2ch_fun)
apply (rule chainI)
apply (rule fun_belowD [of _ _ "f"])
by (rule chain_SSCANL [THEN chainE], simp)

(* scanning a singleton stream is equivalent to computing \<up>(f a b) *)
lemma [simp]: "sscanl f a\<cdot>(\<up>b) = \<up>(f a b)"
by (insert sscanl_scons [of f a b \<epsilon>], auto)

text {* applying @{term sscanl} never shortens the stream *}
lemma fair2_sscanl: "#x \<le> #(sscanl f a\<cdot>x)"
apply (rule spec [where x = a])
apply (rule ind [of _ x], auto)
by (subst lnle_def, simp del: lnle_conv)

(* dropping the first element of the result of sscanl is equivalent to beginning the scan with 
   (f a (shd s)) as the initial element and proceeding with the rest of the input *)
lemma sscanl_srt: "srt\<cdot>(sscanl f a\<cdot>s) = sscanl f (f a (shd s)) \<cdot>(srt\<cdot>s) "
by (metis (no_types, lifting) sconc_fst_empty sconc_scons' sscanl_empty sscanl_scons stream.sel_rews(2) stream.sel_rews(5) sup'_def surj_scons up_defined)

(* the n + 1'st element produced by sscanl is the result of mering the n + 1'st item of s with the n'th
   element produced by sscanl *)
lemma sscanl_snth:  "Fin (Suc n) < #s \<Longrightarrow> snth (Suc n) (sscanl f a\<cdot>s) = f (snth n (sscanl f a\<cdot>s)) (snth (Suc n) s)"
apply(induction n arbitrary:  a s)
apply (smt Fin_02bot Fin_leq_Suc_leq less2lnleD less_lnsuc lnat_po_eq_conv lnless_def lnzero_def shd1 slen_empty_eq slen_rt_ile_eq snth_scons snth_shd sscanl_scons surj_scons)
by (smt Fin_Suc lnat_po_eq_conv lnle_def lnless_def lnsuc_lnle_emb lnzero_def minimal slen_scons snth_scons sscanl_scons strict_slen surj_scons)

(* the result of sscanl has the same length as the input stream x *)
lemma fair_sscanl[simp]: "#(sscanl f a\<cdot>x) = #x"
apply (rule spec [where x = a])
by (rule ind [of _ x], auto)


(* ----------------------------------------------------------------------- *)
subsection {* @{term szip} *}
(* ----------------------------------------------------------------------- *)

text {* Basic simplification rules of @{term szip} *}

lemma strict_szip_fst[simp]: "szip\<cdot>\<epsilon>\<cdot>s = \<epsilon>"
by (subst szip_def [THEN fix_eq2],simp)

lemma strict_szip_snd[simp]: "szip\<cdot>s\<cdot>\<epsilon> = \<epsilon>"
by (subst szip_def [THEN fix_eq2], simp)

lemma szip_scons[simp]: "szip\<cdot>(\<up>a\<bullet>s1)\<cdot>(\<up>b\<bullet>s2) = \<up>(a,b) \<bullet> (szip\<cdot>s1\<cdot>s2)"
by (subst szip_def [THEN fix_eq2], simp)

lemma [simp]: "szip\<cdot>(\<up>a)\<cdot>(\<up>b \<bullet> y) = \<up>(a,b)"
by (subst szip_def [THEN fix_eq2], simp)

lemma [simp]: "szip\<cdot>(\<up>a \<bullet> x)\<cdot>(\<up>b) = \<up>(a,b)"
by (subst szip_def [THEN fix_eq2], simp)

lemma [simp]: "szip\<cdot>(\<up>a)\<cdot>(\<up>b) = \<up>(a,b)"
by (subst szip_def [THEN fix_eq2], simp)

text {* If @{term szip} returns an empty stream, an input stream was empty *}
lemma strict_rev_szip: "szip\<cdot>x\<cdot>y = \<epsilon> \<Longrightarrow> x = \<epsilon> \<or> y = \<epsilon>"
apply (rule_tac x=x in scases, auto)
by (rule_tac x=y in scases, auto)

text {* @{term sprojfst} and @{term sprojsnd} are "inverse" functions of
  @{term szip} - if the other zipped stream is infinite *}

lemma sprojfst_szipl1[rule_format]: 
  "\<forall>x. #x = \<infinity> \<longrightarrow> sprojfst\<cdot>(szip\<cdot>i\<cdot>x) = i"
apply (rule ind [of _ i], auto)
by (rule_tac x=x in scases, auto)

lemma sprojsnd_szipl1[rule_format]: 
  "\<forall>x. #x = \<infinity> \<longrightarrow> sprojsnd\<cdot>(szip\<cdot>x\<cdot>i) = i"
apply (rule ind [of _ i], auto)
by (rule_tac x=x in scases, auto)

(* zipping the infinite constant streams \<up>x\<infinity> and \<up>y\<infinity> is equivalent to infinitely repeating the tuple
   \<up>(x, y) *)
lemma szip2sinftimes[simp]: "szip\<cdot>\<up>x\<infinity>\<cdot>\<up>y\<infinity> = \<up>(x, y)\<infinity> "
by (metis s2sinftimes sinftimes_unfold szip_scons)

lemma szip_len [simp]: "#(szip\<cdot>as\<cdot>bs) = min (#as) (#bs)"
apply(induction as arbitrary: bs)
apply(rule admI)
apply auto[1]
apply (metis inf_chainl4 inf_less_eq lub_eqI lub_finch2 min_def slen_sprojsnd sprojsnd_szipl1)
apply simp
apply(case_tac "bs=\<epsilon>")
apply auto[1]
proof -
  fix u :: "'a discr u"
  fix as:: "'a stream"
  fix bs:: "'b stream"
  assume as1: "u \<noteq> \<bottom>" and 
    as2: "(\<And>bs::'b stream. #(szip\<cdot>as\<cdot>bs) = min (#as) (#bs))" and as3: "bs \<noteq> \<epsilon>" 
  obtain a where a_def: "updis a = u" by (metis as1 lshd_updis stream.sel_rews(4) stream.sel_rews(5) surj_scons)
  obtain b bs2 where b_def: "bs = \<up>b \<bullet> bs2" by (metis as3 surj_scons) 
  hence "#(szip\<cdot>(\<up>a \<bullet> as)\<cdot>(\<up>b \<bullet> bs2)) = min (#(\<up>a \<bullet> as)) (#(\<up>b \<bullet> bs2))" by (simp add: as2 min_def) 
  thus "#(szip\<cdot>(u && as)\<cdot>bs) = min (#(u && as)) (#bs)" by (metis a_def b_def lscons_conv) 
qed


(* ----------------------------------------------------------------------- *)
subsection {* @{term szip} *}
(* ----------------------------------------------------------------------- *)

lemma merge_unfold: "merge f\<cdot>(\<up>x \<bullet> xs)\<cdot>(\<up>y\<bullet> ys) = \<up>(f x y) \<bullet> merge f\<cdot>xs\<cdot>ys"
  by(simp add: merge_def)

lemma merge_snth[simp]: "Fin n <#xs \<Longrightarrow>Fin n < #ys \<Longrightarrow> snth n (merge f\<cdot>xs\<cdot>ys) = f (snth n xs) (snth n ys)"
  apply(induction n arbitrary:xs ys)
   apply (metis Fin_02bot merge_unfold lnless_def lnzero_def shd1 slen_empty_eq snth_shd surj_scons)
  by (smt Fin_Suc Fin_leq_Suc_leq Suc_eq_plus1_left merge_unfold inject_lnsuc less2eq less2lnleD lnle_conv lnless_def lnsuc_lnle_emb sconc_snd_empty sdropostake shd1 slen_scons snth_rt snth_scons split_streaml1 stream.take_strict surj_scons ub_slen_stake)

lemma merge_eps1[simp]: "merge f\<cdot>\<epsilon>\<cdot>ys = \<epsilon>"
  by(simp add: merge_def)

lemma merge_eps2[simp]: "merge f\<cdot>xs\<cdot>\<epsilon> = \<epsilon>"
  by(simp add: merge_def)

lemma [simp]: "srt\<cdot>(merge f\<cdot>(\<up>a \<bullet> as)\<cdot>(\<up>b \<bullet> bs)) = merge f\<cdot>as\<cdot>bs"
  by (simp add: merge_unfold)

lemma merge_len [simp]: "#(merge f\<cdot>as\<cdot>bs) = min (#as) (#bs)"
by(simp add: merge_def)

lemma merge_commutative: assumes "\<And> a b. f a b = f b a"
  shows "merge f\<cdot>as\<cdot>bs = merge f\<cdot>bs\<cdot>as"
  apply(rule snths_eq)
   apply (simp add: min.commute)
  by (simp add: assms)
  

(* ----------------------------------------------------------------------- *)
subsection {* @{term siterate} *}
(* ----------------------------------------------------------------------- *)

text {* @{term siterate} is defined by running @{term sscanl} on an arbitrary
  infinite stream. Only the stream length is relevant for the result *}
lemma siterate_inv_lemma:
  "\<forall>x z a. #z = #x 
     \<longrightarrow> stake n\<cdot>(sscanl (\<lambda>a b. f a) a\<cdot>x) = 
        stake n\<cdot>(sscanl (\<lambda>a b. f a) a\<cdot>z)"
apply (induct_tac n, auto)
apply (rule_tac x=x in scases, auto)
by (rule_tac x=z in scases, auto)

text {* @{term siterate} is well-defined (because it is independent of
  the infinite stream on which @{term sscanl} is applied) *}
lemma siterate_def2:
  "#x = \<infinity> \<Longrightarrow> siterate f a = \<up>a \<bullet> sscanl (\<lambda>a b. f a) a\<cdot>x"
apply (subst siterate_def)
apply (rule someI2_ex)
apply (rule_tac x="sinftimes (\<up>(SOME a. True))" in exI, simp)
apply (rule cfun_arg_cong)
apply (rule stream.take_lemma)
by (rule siterate_inv_lemma [rule_format], simp)

text {* unfolding of @{term siterate} definition *}
lemma siterate_scons: "siterate f a = \<up>a \<bullet> siterate f (f a)"
apply (rule stream.take_lemma [OF spec [where x="a"]])
apply (induct_tac n, auto)
apply (insert siterate_def2 [of _ f], atomize)
apply (erule_tac x="sinftimes (\<up>x)" in allE, auto)
by (subst sinftimes_unfold, simp)

(* to define the nth element of siterate we define a helper function \<open>niterate\<close> *)
(* \<open>iterate\<close> cannot be used, because the function is only about CPO's, maybe some
of those lemmata about niterate could be in Prelude, but not all of them*)

primrec niterate :: "nat \<Rightarrow> ('a::type \<Rightarrow> 'a) \<Rightarrow> ('a \<Rightarrow> 'a)" where
    "niterate 0 = (\<lambda> F x. x)"
  | "niterate (Suc n) = (\<lambda> F x. F (niterate n F x))"

lemma niterate_Suc2: "niterate (Suc n) F x = niterate n F (F x)"
apply(induction n)
by(simp_all)

lemma niter2iter: "iterate g\<cdot>h\<cdot>x = niterate g (Rep_cfun h) x"
apply (induction g)
by(simp_all)
  
lemma iterate_eps [simp]: assumes "g \<epsilon> = \<epsilon>"
  shows "(iterate i\<cdot>(\<Lambda> h. (\<lambda>s. s \<bullet> h (g s)))\<cdot>\<bottom>) \<epsilon> = \<epsilon>" 
using assms by (induction i, auto)
  
lemma fix_eps [simp]: assumes "g \<epsilon> = \<epsilon>"
  shows "(\<mu> h. (\<lambda>s. s \<bullet> h (g s))) \<epsilon> = \<epsilon>"
proof -
  have aI: "max_in_chain 0 (\<lambda>i. (iterate i\<cdot>(\<Lambda> h. (\<lambda>s. s \<bullet> h (g s)))\<cdot>\<bottom>) \<epsilon> )" by (simp add: max_in_chainI assms)
  hence "(\<Squnion>i. (iterate i\<cdot>(\<Lambda> h. (\<lambda>s. s \<bullet> h (g s)))\<cdot>\<bottom>) \<epsilon>) = \<epsilon>"  using assms by auto 
  hence " (\<Squnion> i. iterate i\<cdot>(\<Lambda> h. (\<lambda>s. s \<bullet> h (g s)))\<cdot>\<bottom>) \<epsilon> = \<epsilon>" by (simp add: lub_fun) 
  thus ?thesis using lub_fun fix_def2 by (metis (no_types, lifting) lub_eq)
qed

(* beginning the iteration of the function h with the element (h x) is equivalent to beginning the
   iteration with x and dropping the head of the iteration *)
lemma siterate_sdrop: "siterate h (h x) = sdrop 1\<cdot>(siterate h x)"
by (metis One_nat_def sdrop_0 sdrop_scons siterate_scons)

(* iterating the function h infinitely often after having already iterated i times is equivalent to
   beginning the iteration with x and then dropping i elements from the resulting stream *)
lemma siterate_drop2iter: "siterate h (niterate i h x) = sdrop i\<cdot>(siterate h x)"
apply (induction i)
apply (simp add: One_nat_def)
by (simp add: sdrop_back_rt siterate_sdrop One_nat_def)

(* the head of iterating the function g on x doesn't have any applications of g *)
lemma shd_siter[simp]: "shd (siterate g x) = x"
by (simp add: siterate_def)

(* dropping i elements from the infinite iteration of the function g on x and then extracting the head
   is equivalent to computing the i'th iteration via niterate *)
lemma shd_siters: "shd (sdrop i\<cdot>(siterate g x)) = niterate i g x"
by (metis shd_siter siterate_drop2iter)   

text {* Addition of two numbers using @{term "siterate Suc"} *}

lemma snth_siterate_Suc: "snth k (siterate Suc j) = k + j"
apply (rule_tac x="j" in spec)
apply (induct_tac k, simp)
apply (rule allI)
by (subst siterate_scons, simp)+

lemma snth_siterate_Suc_0[simp]: "snth k (siterate Suc 0) = k"
by (simp add: snth_siterate_Suc)

lemma sdrop_siterate:
  "sdrop k\<cdot>(siterate Suc j) = siterate Suc (j + k)"
apply (rule_tac x="j" in spec)
apply (induct_tac k, simp+)
apply (rule allI)
by (subst siterate_scons, simp)

text {* @{term siterate} only creates infinite outputs *}
lemma [simp]: "#(siterate f k) = \<infinity>"
apply (rule infI)
apply (rule allI)
apply (rule_tac x="k" in spec)
apply (induct_tac k, simp+)
by (subst siterate_scons, simp)+

(* the i'th element of the infinite stream of iterating the function g on x can alternatively be found
   with (niterate i g x) *)
lemma snth_siter: "snth i (siterate g x) = niterate i g x"
by (simp add: shd_siters snth_def)

(* dropping j elements from the stream x and then extracting the i'th element is equivalent to extracting
   the i+j'th element directly *)
lemma snth_sdrop: "snth i (sdrop j\<cdot>x) = snth (i+j) x"
by (simp add: sdrop_plus snth_def)

(* extracting the i+1'st element from the stream of iterating the function g on x is equivalent to extracting
   the i'th element and then applying g one more time *)
lemma snth_snth_siter: "snth (Suc i) (siterate g x) = g (snth i (siterate g x))"
by (simp add: snth_siter)

(* dropping the first element from the chain of iterates is equivalent to shifting the chain by applying g *)
lemma sdrop_siter:  "sdrop 1\<cdot>(siterate g x) = smap g\<cdot>(siterate g x)"
apply(rule sinf_snt2eq)
apply (simp add: fair_sdrop) 
apply simp
by (simp add: smap_snth_lemma snth_sdrop snth_snth_siter One_nat_def)

(* if the functions g and h commute then g also commutes with any number of iterations of h *)
lemma iterate_insert: assumes "\<forall>z. h (g z) = g (h z)"
  shows "niterate i h (g x) = g (niterate i h x)"
using assms by (induction i, auto)

(* lifts iterate_insert from particular iterations to streams of iterations *)
lemma siterate_smap:  assumes "\<forall>z. g (h z) = h (g z)"
  shows "smap g\<cdot>(siterate h x) = siterate h (g x)"
apply (rule sinf_snt2eq, auto)
by (simp add: assms smap_snth_lemma snth_siter iterate_insert)

(* iterating the function g on x is equivalent to the stream produced by concatenating \<up>x and the 
   iteration of g on x shifted by another application of g *)
lemma siterate_unfold: "siterate g x = \<up>x \<bullet> smap g\<cdot>(siterate g x)"
by (metis siterate_scons siterate_smap)

(* iterating the identity function produces an infinite constant stream of the element x *)
lemma siter2sinf: "siterate id x = sinftimes (\<up>x)"
by (metis id_apply s2sinftimes siterate_scons)

lemma "sdrop i\<cdot>(siterate id x) = siterate id x"
  by (smt sdrops_sinf siter2sinf)

(* if g acts as the identity for the element x then iterating g on x produces an infinite constant
   stream of x *)
lemma siter2sinf2: assumes "g x = x"
  shows "siterate g x = sinftimes (\<up>x)"
by (smt assms s2sinftimes siterate_scons)

(* shows the equivalence of an alternative recursive definition of iteration *)
lemma rek2niter: assumes "xs = \<up>x \<bullet> (smap g\<cdot>xs)"
  shows "snth i xs = niterate i g x"
proof (induction i)
  case 0 thus ?case by (metis assms niterate.simps(1) shd1 snth_shd)
next
  case (Suc i) 
  have "#xs = \<infinity>" by (metis Inf'_def assms below_refl fix_least_below inf_less_eq lnle_def slen_scons slen_smap)
  thus ?case by (metis Fin_neq_inf Suc assms inf_ub lnle_def lnless_def niterate.simps(2) smap_snth_lemma snth_scons)
qed

(* wichtig *)
(* recursively mapping the function g over the rest of xs is equivalent to the stream of iterations of g on x *)
lemma rek2siter: assumes "xs = \<up>x \<bullet> (smap g\<cdot>xs)"
  shows "xs = siterate g x" 
apply (rule sinf_snt2eq, auto)
apply (metis Inf'_def assms fix_least inf_less_eq lnle_conv slen_scons slen_smap) 
by (metis assms rek2niter snth_siter)

(* shows that siterate produces the least fixed point of the alternative recursive definition *)
lemma fixrek2siter: "fix\<cdot>(\<Lambda> s . (\<up>x \<bullet> smap g\<cdot>s)) =  siterate g x"
by (metis (no_types) cfcomp1 cfcomp2 fix_eq rek2siter)

(* dropping elements from a stream of iterations is equivalent to adding iterations to every element *)
lemma sdrop2smap: "sdrop i\<cdot>(siterate g x) = smap (niterate i g)\<cdot>(siterate g x)"
by (simp add: iterate_insert siterate_drop2iter siterate_smap)

(* ----------------------------------------------------------------------- *)
section {* Adm simp rules *}
(* ----------------------------------------------------------------------- *)

text{* For functions g and h producing sets the following predicate is admissible *}
lemma adm_subsetEq [simp]: "adm (\<lambda>s. g\<cdot>s \<subseteq> h\<cdot>s)"
by (metis (full_types) SetPcpo.less_set_def adm_below cont_Rep_cfun2)

text{* For a function g producing sets and a set cs the following predicate is admissible *}
lemma adm_subsetEq_rc [simp]: "adm (\<lambda>s. g\<cdot>s \<subseteq> cs)"
by (metis (no_types, lifting) adm_def chain_monofun contlub_cfun_arg lub_below set_cpo_simps(1))

text{* For a function h producing sets and a set cs the following predicate is admissible *}
lemma adm_subsetEq_lc [simp]: "adm (\<lambda>s. cs \<subseteq> h\<cdot>s)"
by (simp add: adm_subst adm_superset)

text{* For a set cs and a function g producing sets, the following predicate is admissible *}
lemma adm_subsetNEq_rc [simp]: "adm (\<lambda>s. \<not> g\<cdot>s \<subseteq> cs)"
  apply(rule admI)
  apply(rule+)
  by (metis SetPcpo.less_set_def is_ub_thelub monofun_cfun_arg subset_eq)

text{*For a function g over streams, the admissiblity of the following predicate over streams holds*}
lemma sdom_adm2[simp]: "adm (\<lambda>a. sdom\<cdot>(g\<cdot>a) \<subseteq> sdom\<cdot>a)"
apply(rule admI)
by (smt SetPcpo.less_set_def ch2ch_Rep_cfunR contlub_cfun_arg is_ub_thelub lub_below subset_iff)

lemma adm_finstream [simp]: "adm (\<lambda>s. #s<\<infinity> \<longrightarrow> P s)"
apply(rule admI)
apply auto
using inf_chainl4 lub_eqI lub_finch2 by fastforce

lemma adm_fin_below: "adm (\<lambda>x . \<not> Fin n \<sqsubseteq> # x)"
  apply(rule admI)
  apply auto
  by (metis Streams.inf_chainl3 finite_chain_def maxinch_is_thelub)

lemma adm_fin_below2: "adm (\<lambda>x . \<not> Fin n \<le> # x)"
by(simp only: lnle_def adm_fin_below)

(* ----------------------------------------------------------------------- *)
section {*New @{term sfilter} lemmata and @{term sfoot} *}
(* ----------------------------------------------------------------------- *)

(* ----------------------------------------------------------------------- *)
subsection {*New @{term sfilter} lemmata *}
(* ----------------------------------------------------------------------- *)


text{* Appending the singleton stream \<up>a increases the length of the stream y by one *}
lemma slen_lnsuc: 
  shows "#(y \<bullet> \<up>a) = lnsuc\<cdot>(#y)"
  apply(induction y)
    apply (smt admI fold_inf inf_chainl4 lub_eqI lub_finch2 sconc_fst_inf)
   apply (metis sconc_fst_empty sconc_snd_empty slen_scons)
  by (metis (no_types, lifting) assoc_sconc slen_scons stream.con_rews(2) stream.sel_rews(5) surj_scons)


(* if filtering the stream s2 with the set A produces infinitely many elements then prepending any
   finite stream s1 to s2 will still produce infinitely many elements *)
lemma sfilter_conc2[simp]: assumes "#(sfilter A\<cdot>s2) = \<infinity>" and "#s1 < \<infinity>"
  shows "#(sfilter A\<cdot>(s1\<bullet>s2)) = \<infinity>"
proof -
  have "(sfilter A\<cdot>(s1\<bullet>s2)) = ((sfilter A\<cdot>s1) \<bullet> (sfilter A\<cdot>s2))"
    using add_sfilter assms(2) lnless_def ninf2Fin by fastforce 
  thus ?thesis by (simp add: assms(1) slen_sconc_snd_inf) 
qed

(* if the stream z is a prefix of another non-empty stream (y\<bullet>\<up>a) but isn't equal to it, then z is
   also a prefix of y *)
lemma below_conc: assumes "z \<sqsubseteq> (y\<bullet>\<up>a)" and "z\<noteq>(y\<bullet>\<up>a)"
  shows "z\<sqsubseteq>y"
proof(cases "#y = \<infinity>")
  case True thus ?thesis using assms(1) sconc_fst_inf by auto  
next
  case False 
  obtain n_y where "Fin n_y= #y" using False ninf2Fin by fastforce
  have "#z \<le> #(y\<bullet>\<up>a)" using assms(1) mono_slen by blast
  have "#z \<noteq> #(y\<bullet>\<up>a)" using assms(1) assms(2) eq_slen_eq_and_less by blast
  hence "#z < #(y\<bullet>\<up>a)" using \<open>#z \<le> #(y \<bullet> \<up>a)\<close> lnle_def lnless_def by blast 
  obtain n_z where nz_def: "Fin n_z = #z" using approxl2 assms(1) assms(2) by blast 
  have "#y < #(y \<bullet> \<up>a)"
    by (metis \<open>Fin n_y = #y\<close> eq_slen_eq_and_less inject_sconc lnless_def minimal monofun_cfun_arg sconc_snd_empty stream.con_rews(2) sup'_def up_defined)
  have "#y < \<infinity>" by (simp add: False lnless_def) 
  hence "Fin n_z \<le> #y" by (metis Fin_Suc \<open>#z < #(y \<bullet> \<up>a)\<close> less2lnleD lnsuc_lnle_emb nz_def slen_lnsuc) 
  have "\<And>s. stake n_y\<cdot>(y \<bullet> s) = y" by (simp add: \<open>Fin n_y = #y\<close> approxl1)
  hence "stake n_z\<cdot>y = stake n_z\<cdot>(y\<bullet>\<up>a)" by (metis \<open>Fin n_y = #y\<close> \<open>Fin n_z \<le> #y\<close> less2nat min_def stakeostake)
  thus ?thesis by (metis \<open>Fin n_z = #z\<close> approxl1 assms(1) stream.take_below) 
qed

(* for any set A and singleton stream \<up>a the following predicate over streams is admissible *)
lemma sfilter_conc_adm: "adm (\<lambda>b. #b<\<infinity> \<longrightarrow> #(A \<ominus> b) < #(A \<ominus> b \<bullet> \<up>a))" (is "adm ?F")
by (metis (mono_tags, lifting) admI inf_chainl4 lnless_def lub_eqI lub_finch2)

(* the element a is kept when filtering with A, so (x \<bullet> \<up>a) produces a larger result than just x,
   provided that x is finite *)
lemma sfilter_conc: assumes "a\<in>A" 
  shows "#x<\<infinity> \<Longrightarrow> #(A \<ominus> x) < #(A \<ominus> (x \<bullet> \<up>a))" (is "_ \<Longrightarrow> ?F x")
  proof(induction x)
    show "adm (\<lambda>b. #b < \<infinity> \<longrightarrow> #(A \<ominus> b) < #(A \<ominus> b \<bullet> \<up>a))" using sfilter_conc_adm by blast
   show "?F \<epsilon>" using assms(1) lnless_def by auto
  next
  fix u :: "'a discr u"
  fix s :: "'a stream"
  assume "u\<noteq>\<bottom>" and "#s<\<infinity> \<Longrightarrow> ?F s" and "#(u && s) < \<infinity>"
  obtain ua where "(updis ua) = u" by (metis \<open>u \<noteq> \<bottom>\<close> discr.exhaust upE)
  hence "u && s = \<up>ua \<bullet>s" using lscons_conv by blast
  thus "?F (u&&s)"
  by (smt \<open>#(u && s) < \<infinity>\<close> \<open>#s < \<infinity> \<Longrightarrow> #(A \<ominus> s) < #(A \<ominus> s \<bullet> \<up>a)\<close> assoc_sconc fold_inf lnat.sel_rews(2) lnless_def monofun_cfun_arg sfilter_in sfilter_nin slen_scons)
qed

(* for any finite stream s and set A, if filtering s with A doesn't produce the empty stream, then
   filtering and infinite repetition are associative *)
lemma sfilter_sinf [simp]: assumes "#s<\<infinity>" and "(A \<ominus> s) \<noteq> \<epsilon>"
  shows "A \<ominus> (s\<infinity>) = (A \<ominus> s)\<infinity>"
by (metis add_sfilter assms(1) assms(2) infI lnless_def rek2sinftimes sinftimes_unfold)

(* if filtering the stream s with the set A produces infinitely many elements, then filtering the 
   rest of s with A also produces infinitely many elements *)
lemma sfilter_srt_sinf [simp]: assumes "#(A \<ominus> s) = \<infinity>" 
  shows  "#(A \<ominus> (srt\<cdot>s)) = \<infinity>"
by (smt assms inf_scase inject_scons sfilter_in sfilter_nin stream.sel_rews(2) surj_scons) 

(* ----------------------------------------------------------------------- *)
section {* @{term sfoot} *}
(* ----------------------------------------------------------------------- *)


(* appending the singleton stream \<up>a to a finite stream s causes sfoot to extract a again *)
lemma sfoot1[simp]: assumes "xs = s\<bullet>(\<up>a)" and "#xs < \<infinity>"
   shows "sfoot xs = a"
proof -
  have "xs \<noteq> \<epsilon>" using assms(1) strictI by force
  obtain n where n_def: "Fin n = #xs" by (metis assms(2) lncases lnless_def) 
  hence "n>0" using assms(2) gr0I using Fin_02bot \<open>xs \<noteq> \<epsilon>\<close> lnzero_def slen_empty_eq by fastforce 
  hence "(THE n'. lnsuc\<cdot>(Fin n') = #xs) = n-1" by (metis (mono_tags, lifting) Fin_Suc Suc_diff_1 n_def inject_Fin inject_lnsuc the_equality)
  have "snth (n-1) xs = a" by (metis Fin_0 Fin_Suc Fin_neq_inf Suc_diff_1 assms(1) n_def bot_is_0 inf_ub inject_lnsuc lnat.con_rews lnle_conv lnless_def lscons_conv neq0_conv sconc_fst_inf sdropl6 shd1 slen_lnsuc snth_def sup'_def)
  thus ?thesis by (metis \<open>(THE n'. lnsuc\<cdot>(Fin n') = #xs) = n - 1\<close> sfoot_def)
qed

(* sfoot extracts the element a from any finite stream ending with \<up>a *)
lemma sfoot12 [simp]: assumes "#s<\<infinity>"
  shows "sfoot (s\<bullet>\<up>a) = a"
by (metis assms fold_inf inject_lnsuc lnless_def monofun_cfun_arg sfoot1 slen_lnsuc)

(* sfoot extracts a from the singleton stream \<up>a *)
lemma sfoot_one [simp]: "sfoot (\<up>a) = a"
by (metis Inf'_neq_0 inf_ub lnle_def lnless_def sconc_fst_empty sfoot12 strict_slen)

(* concatenating finite streams produces another finite stream *)
lemma sconc_slen [simp]: assumes "#s<\<infinity>" and "#xs<\<infinity>"
  shows "#(s\<bullet>xs) < \<infinity>"
by (metis Fin_neq_inf assms(1) assms(2) infI inf_ub lnle_def lnless_def slen_sconc_all_finite)

(* if the foot of a non-empty stream xs is a, then xs consists of another stream s (possibly empty)
   concatenated with \<up>a *)
lemma sfoot2 [simp]: assumes "sfoot xs = a" and "xs\<noteq>\<epsilon>"
  shows "\<exists>s. xs = s \<bullet> \<up>a"
proof (cases "#xs = \<infinity>")
  case True thus ?thesis by (metis sconc_fst_inf) 
next
  case False 
  obtain n where "#xs = Fin n" using False lncases by auto
  hence "(THE n'. lnsuc\<cdot>(Fin n') = #xs) = n-1"
    by (smt Fin_02bot Fin_Suc Suc_diff_1 assms(2) bot_is_0 inject_Fin inject_lnsuc neq0_conv slen_empty_eq the_equality)
  have "stake (n-1)\<cdot>xs \<bullet> \<up>(snth (n-1) xs) = xs"
    by (smt Fin_0 Fin_Suc Inf'_def Suc_diff_1 \<open>#xs = Fin n\<close> assms(2) fin2stake fix_least_below lnle_def neq0_conv notinfI3 sconc_snd_empty sdrop_back_rt sdropostake slen_empty_eq snth_def split_streaml1 surj_scons ub_slen_stake)
  thus ?thesis by (metis \<open>(THE n'. lnsuc\<cdot>(Fin n') = #xs) = n - 1\<close> assms(1) sfoot_def) 
qed

(* when sfoot is applied to the concatenation of two finite streams s and xs, and xs is not empty,
   then sfoot will produce the foot of xs *)
lemma sfoot_conc [simp]: assumes "#s<\<infinity>" and "#xs<\<infinity>" and "xs\<noteq>\<epsilon>"
  shows "sfoot (s\<bullet>xs) = sfoot xs"
by (metis (no_types, hide_lams) assms(1) assms(2) assms(3) assoc_sconc sconc_slen sfoot1 sfoot2)

(* if the finite stream s contains more than one element then the foot of s will be the foot of the
   rest of s *)
lemma sfoot_sdrop: assumes "Fin 1<#s" and "#s<\<infinity>"
  shows "sfoot (srt\<cdot>s) = sfoot s"
proof -
  obtain s' where "s = s' \<bullet> \<up>(sfoot s)" by (metis assms below_antisym bot_is_0 lnless_def minimal sfoot2 strict_slen)
  hence "s' \<noteq> \<epsilon>"
    by (metis Fin_02bot Fin_Suc Inf'_neq_0 One_nat_def assms lnless_def lnzero_def minimal slen_lnsuc strict_slen)
  hence "srt\<cdot>s = srt\<cdot>s' \<bullet> \<up>(sfoot s)"
    by (smt \<open>s = s' \<bullet> \<up>(sfoot s)\<close> assoc_sconc inject_scons sconc_snd_empty strictI surj_scons)
  thus ?thesis
    by (metis \<open>s = s' \<bullet> \<up>(sfoot s)\<close> \<open>s' \<noteq> \<epsilon>\<close> assms(2) inf_ub lnle_conv lnless_def sconc_snd_empty sfoot1 slen_sconc_snd_inf strictI surj_scons) 
qed

lemma [simp]: assumes "#xs < \<infinity>"
  shows "sfoot (\<up>a \<bullet> \<up>b \<bullet> xs) = sfoot (\<up>b \<bullet> xs)"
using assms lnless_def by auto 

(* the foot of any stream s is the nth element of s for some natural number n *)
lemma sfoot_exists [simp]:"\<exists>n. snth n s = sfoot s"
by (metis sfoot_def)

(* if the stream s contains n+1 elements then the foot of s will be found at index n *)
lemma  sfoot_exists2: 
  shows "Fin (Suc n) = #s \<Longrightarrow> snth n s = sfoot s"
  apply(induction n arbitrary: s)
   apply (metis (mono_tags, lifting) Fin_02bot Fin_Suc Zero_lnless_infty inject_lnsuc lnzero_def sconc_fst_empty sconc_snd_empty sfoot12 slen_empty_eq slen_scons snth_shd surj_scons)
  by (smt Fin_Suc Fin_neq_inf fold_inf inf_ub inject_lnsuc lnat.con_rews lnle_conv lnless_def lnzero_def sconc_snd_empty sfoot_conc slen_scons snth_rt strict_slen surj_scons)

text {* Streams can be split for filtering *}
lemma add_sfilter2: assumes "#x < \<infinity>" 
  shows "sfilter A\<cdot>(x \<bullet> y) = sfilter A\<cdot>x \<bullet> sfilter A\<cdot>y"
by (metis (no_types) add_sfilter assms lncases lnless_def)

lemma sfood_id: assumes"#s = Fin (Suc n)"
  shows "(stake n\<cdot>s) \<bullet> \<up>(sfoot s) = s"
  using assms apply(induction n arbitrary: s)
   apply simp
   apply (metis Fin_02bot Fin_Suc lnat.sel_rews(2) lnsuc_neq_0_rev lnzero_def lscons_conv sfoot_exists2 slen_scons snth_shd strict_slen sup'_def surj_scons)
  apply (subst stake_suc)
  apply simp
  by (smt Fin_02bot Fin_Suc One_nat_def Rep_cfun_strict1 Zero_not_Suc leI lnat.sel_rews(2) lnle_Fin_0 lnzero_def notinfI3 sconc_snd_empty sfoot_sdrop slen_rt_ile_eq slen_scons stake_Suc stream.take_0 strict_slen surj_scons)


(* ----------------------------------------------------------------------- *)
subsection {* @{term sdom} *}
(* ----------------------------------------------------------------------- *)

text {* A stream and its prefix agree on their first elements *}
lemma snth_less: "\<lbrakk>Fin n < #x; x \<sqsubseteq> y\<rbrakk> \<Longrightarrow> snth n x = snth n y"
apply (simp add: atomize_imp)
apply (rule_tac x="x" in spec)
apply (rule_tac x="y" in spec)
apply (induct_tac n, auto)
by (drule lessD, auto)+


text {* monotonicity of @{term sdom} *}
lemma sdom_mono: "monofun (\<lambda>x. {z. \<exists>n. Fin n < #x \<and> z = snth n x})"
apply (rule monofunI)
apply (rule_tac x="#x" in lncases)
apply (drule eq_less_and_fst_inf, simp+)
apply (simp add: atomize_imp)
apply (rule_tac x="y" in spec)
apply (rule_tac x="x" in spec)
apply (induct_tac k, simp+)
apply (auto simp add: less_set_def)
apply (drule lessD, auto)
apply (erule_tac x="q" in allE)
apply (erule_tac x="w" in allE, auto)
apply (case_tac "na", auto)
apply (rule_tac x="0" in exI, auto)
apply (frule_tac f="slen" in monofun_cfun_arg, simp)
apply (rule_tac x="Suc nat" in exI, auto)
apply (rule_tac x="#w" in lncases, auto)
by (rule snth_less, auto)

text {* In infinite chains, the length of the streams is unbounded *}
lemma inf_chainl3rf:
  "\<lbrakk>chain Y; \<not>finite_chain Y\<rbrakk> \<Longrightarrow> \<exists>k. Fin n \<le> #(Y k)"
by (rule inf_chainl3 [rule_format], auto)

text {* @{term sdom} is a continuous function *}
lemma sdom_cont: "cont (\<lambda>s. {z. \<exists>n. Fin n < #s \<and> z = snth n s})"
apply (rule contI2)
apply (rule sdom_mono)
apply (rule allI, rule impI)
apply (simp add: less_set_def)
apply (auto simp add: lub_eq_Union) 
apply (case_tac "finite_chain Y")
apply (subst lub_finch2 [THEN lub_eqI], simp)
apply (rule_tac x="LEAST i. max_in_chain i Y" in exI)
apply (rule_tac x="n" in exI, simp)
apply (subst lub_finch2 [THEN lub_eqI, THEN sym], simp+)
apply (frule_tac n="Suc n" in inf_chainl3rf, simp+)
apply (erule exE)
apply (rule_tac x="k" in exI)
apply (rule_tac x="n" in exI)
apply (rule conjI)
apply (rule_tac x="#(Y k)" in lncases, simp+)
apply (rule sym)
apply (rule snth_less)
apply (rule_tac x="#(Y k)" in lncases, simp+)
by (rule is_ub_thelub)

text {* @{term sdom} is a continuous function *}
lemma sdom_def2: "sdom\<cdot>s = {z. \<exists>n. Fin n < #s \<and> z = snth n s}"
apply (subst sdom_def)
apply (subst beta_cfun)
by (rule sdom_cont, simp)

lemma sdom_cont2: "\<forall>Y. chain Y \<longrightarrow> sdom\<cdot>(\<Squnion> i. Y i) = (\<Squnion> i. sdom\<cdot>(Y i))"
by (simp add: contlub_cfun_arg)

text {* Basic properties of @{term sdom} *}

lemma [simp]: "sdom\<cdot>\<epsilon> = {}"
by (auto simp add: sdom_def2 lnless_def)

(* the head of any stream is always an element of the domain *)
lemma sdom2un[simp]: "sdom\<cdot>(\<up>z \<bullet> s) = {z} \<union> sdom\<cdot>s"
apply (auto simp add: sdom_def2)
apply (case_tac "n", auto)
apply (rule_tac x="0" in exI, auto)
by (rule_tac x="Suc n" in exI, auto)

(* only the empty stream has no elements in its domain *)
lemma strict_sdom_rev: "sdom\<cdot>s = {} \<Longrightarrow> s = \<epsilon>"
apply (auto simp add: sdom_def2)
apply (rule_tac x="s" in scases, auto)
apply (erule_tac x="a" in allE)
by (erule_tac x="0" in allE, auto)

(* the infinite repetition of a only has a in its domain *)
(*with new lemmata not necessary:
 apply (subst sinftimes_unfold, simp)*)
(*apply (induct_tac n, auto)
apply (subst sinftimes_unfold, simp)
apply (rule_tac x="0" in exI)
by (subst sinftimes_unfold, simp)*)
lemma [simp]: "sdom\<cdot>(sinftimes (\<up>a)) = {a}"
by (auto simp add: sdom_def2)


(* any singleton stream of z only has z in its domain *)
lemma [simp]: "sdom\<cdot>(\<up>z) = {z}"
by (auto simp add: sdom_def2)

(* if an element z is in the domain of a stream s, then z is the n'th element of s for some n *)
lemma sdom2snth: "z \<in> sdom\<cdot>s \<Longrightarrow> \<exists>n. snth n s = z"
by (auto simp add: sdom_def2)

(* if the natural number n is less than the length of the stream s, then snth n s is in the domain of s *)
lemma snth2sdom: "Fin n < #s \<Longrightarrow> snth n s \<in> sdom\<cdot>s"
by (auto simp add: sdom_def2)

(* checking if the domain of a stream x isn't a subset of another set M is an admissible predicate *)
lemma [simp]: "adm (\<lambda>x. \<not> sdom\<cdot>x \<subseteq> M)"
apply (rule admI)
apply (rule notI)
apply (frule_tac x="0" in is_ub_thelub)
apply (frule_tac f="sdom" in monofun_cfun_arg)
by (erule_tac x="0" in allE, auto simp add: less_set_def)

text {* filtering with a superset of the stream's domain does not change the stream *}
lemma sfilter_sdoml3:
  "sdom\<cdot>s \<subseteq> X \<longrightarrow> sfilter X\<cdot>s = s"
apply (rule impI)
apply (rule stream.take_lemma)
apply (simp add: atomize_imp)
apply (rule_tac x="s" in spec)
apply (rule_tac x="X" in spec)
apply (induct_tac n, simp+)
apply (rule allI)+
apply (rule impI)
by (rule_tac x="xa" in scases, simp+)

text {* filtering with the stream's domain does not change the stream *}
lemma sfilter_sdoml4 [simp]:
  "sfilter (sdom\<cdot>s)\<cdot>s = s"
by (rule sfilter_sdoml3 [rule_format, of "s" "sdom\<cdot>s"], simp)

text {* The domain of a concatenated stream is the union of the single domains *}
lemma sdom_sconc2un:
  "#x = Fin k \<Longrightarrow> sdom\<cdot>(x \<bullet> y) = sdom\<cdot>x \<union> sdom\<cdot>y"
apply (simp add: atomize_imp)
apply (rule_tac x="x" in spec)
apply (induct_tac k, simp+)
apply (rule allI, rule impI)
by (rule_tac x="x" in scases, simp+)

lemma sconc_sdom: "sdom\<cdot>(s1\<bullet>s2) \<subseteq> sdom\<cdot>s1 \<union> sdom\<cdot>s2"
by (metis SetPcpo.less_set_def below_refl lncases sconc_fst_inf sdom_sconc2un sup.coboundedI1)

lemma sfoot_dom: assumes "#s = Fin (Suc n)" and "sdom\<cdot>s\<subseteq>A"
  shows "sfoot s\<in>A"
by (metis Suc_n_not_le_n assms(1) assms(2) contra_subsetD leI less2nat_lemma sfoot_exists2 snth2sdom)

(* stakewhile doesn't include the element a that failed the predicate f in the result *)
lemma stakewhile_dom[simp]:assumes "\<not>f a"
  shows "a\<notin>sdom\<cdot>(stakewhile f\<cdot>s)"
by (smt assms below_antisym lnle_conv lnless_def mem_Collect_eq sdom_def2 snth_less stakewhile_below stakewhile_slen)

(* if stakewhile changes the stream s, which is a prefix of the stream s', then stakewhile of s and s'
   produce the same result *)
lemma stakewhile_finite_below: 
shows "stakewhile f\<cdot>s \<noteq> s \<Longrightarrow> s\<sqsubseteq>s' \<Longrightarrow> stakewhile f\<cdot>s = stakewhile f\<cdot>s'"
apply(induction s)
apply simp+
by (smt approxl1 approxl2 lnless_def monofun_cfun_arg rev_below_trans snth_less stakewhile_below stakewhile_notin stakewhile_snth)

(* if there is an element in the stream s that fails the predicate f, then stakewhile will change s *)
lemma stakewhile_noteq[simp]: assumes "\<not>f (snth n s)" and "Fin n < #s"
  shows "stakewhile f\<cdot>s \<noteq> s"
proof (rule ccontr)
  assume "\<not> stakewhile f\<cdot>s \<noteq> s"
  hence "sdom\<cdot>(stakewhile f\<cdot>s) = sdom\<cdot>s" by simp
  hence "(snth n s)\<in>sdom\<cdot>(stakewhile f\<cdot>s)" by (simp add: assms(2) snth2sdom)
  thus False by (simp add: assms(1)) 
qed

(* if there's an element a in the domain of s which fails the predicate f, then stwbl will produce a
   finite result *)
lemma stwbl_fin [simp]: assumes "a\<in>sdom\<cdot>s" and "\<not> f a"
  shows "#(stwbl f\<cdot>s) < \<infinity>"
by (metis assms(1) assms(2) inf_ub lnle_conv lnless_def notinfI3 sconc_slen sdom2snth stakewhile_slen stwbl_stakewhile ub_slen_stake)

(* stwbl keeps at least all the elements that stakewhile keeps *)
lemma stakewhile_stwbl [simp]: "stakewhile f\<cdot>(stwbl f\<cdot>s) = stakewhile f\<cdot>s"
proof -
  have "\<And>s sa. (s::'a stream) \<sqsubseteq> s \<bullet> sa"
    by simp
  then have "stakewhile f\<cdot>(stwbl f\<cdot>s) = stwbl f\<cdot>s \<longrightarrow> stakewhile f\<cdot>(stwbl f\<cdot>s) = stakewhile f\<cdot>s"
    by (metis (no_types) below_antisym monofun_cfun_arg stwbl_below stwbl_stakewhile)
  then show ?thesis
    using stakewhile_finite_below stwbl_below by blast
qed



lemma sntimes_sdom1[simp]: "sdom\<cdot>(sntimes n s) \<subseteq> sdom\<cdot>s"
proof (induction n)
  case 0 thus ?case by simp
next
  case (Suc n) thus ?case using sconc_sdom sntimes.simps(2) sup.orderE by auto
qed

(* if filtering everything except z from the stream x doesn't produce the empty stream, then z must
   be an element of the domain of x *)
lemma sfilter2dom:
  "sfilter {z}\<cdot>x \<noteq> \<epsilon> \<Longrightarrow> z \<in> sdom\<cdot>x"
apply (subgoal_tac "\<exists>k. snth k x = z \<and> Fin k < #x", erule exE)
apply (erule conjE)
apply (drule sym, simp)
apply (rule snth2sdom, simp)
apply (rule ccontr, simp)
by (insert ex_snth_in_sfilter_nempty [of x "{z}"], auto)

text {* For injective functions @{term f} with @{term "f(y) = x"}, @{term x} can only
  be contained in @{term "smap f\<cdot>s"} if the original stream contained @{term y} *}
lemma sdom_smapl1: "\<lbrakk>x \<in> sdom\<cdot>(smap f\<cdot>s); inj f; f y = x\<rbrakk> \<Longrightarrow> y \<in> sdom\<cdot>s" 
apply (auto simp add: sdom_def2)
apply (rule_tac x="n" in exI, simp)
apply (simp add: smap_snth_lemma)
by (simp add: inj_on_def)

(* appending another stream xs can't shrink the domain of a stream x *)
lemma sdom_sconc[simp]: "sdom\<cdot>x \<subseteq> sdom\<cdot>(x \<bullet> xs)"
by (metis minimal monofun_cfun_arg sconc_snd_empty set_cpo_simps(1))

(* repeating a stream doesn't add elements to the domain *)
lemma sinftimes_sdom[simp]: "sdom\<cdot>(sinftimes s) \<subseteq> sdom\<cdot>s"
by (smt chain_monofun contlub_cfun_arg lub_below set_cpo_simps(1) sntimesLub sntimes_chain sntimes_sdom1)

(* repeating a stream doesn't remove elements from the domain either *)
lemma sinf_sdom [simp]: "sdom\<cdot>(s\<infinity>) = sdom\<cdot>s"
by (metis antisym_conv sdom_sconc sinftimes_sdom sinftimes_unfold)

(* sfilter doesn't add elements to the domain *)
lemma sbfilter_sbdom[simp]: "sdom\<cdot>(sfilter A\<cdot>s) \<subseteq> sdom\<cdot>s"
apply(rule ind [of _s], auto)
by (metis (mono_tags, lifting) UnE contra_subsetD sdom2un sfilter_in sfilter_nin singletonD)

(* smap can only produce elements in the range of the mapped function f *)
lemma smap_sdom_range [simp]: "sdom\<cdot>(smap f\<cdot>s) \<subseteq> range f"
by (smt mem_Collect_eq range_eqI sdom_def2 slen_smap smap_snth_lemma subsetI)

(* every element produced by (smap f) is in the image of the function f *)
lemma smap_sdom: "sdom\<cdot>(smap f\<cdot>s) =  f ` sdom\<cdot>s"
apply(rule)
apply (smt image_eqI mem_Collect_eq sdom_def2 slen_smap smap_snth_lemma subsetI)
by (smt image_subset_iff mem_Collect_eq sdom_def2 slen_smap smap_snth_lemma)

(* Lemmas fr SB *)
(* if the stream a is a prefix of the stream b then a's domain is a subset of b's *)
lemma f1 [simp]: "a \<sqsubseteq> b \<Longrightarrow> sdom\<cdot>a \<subseteq> sdom\<cdot>b"
by (metis SetPcpo.less_set_def monofun_cfun_arg)

(* the lub of a chain of streams contains any elements contained in any stream in the chain *)
lemma l4: "chain S \<Longrightarrow> sdom\<cdot>(S i) \<subseteq> sdom\<cdot>(\<Squnion> j. S j)"
using f1 is_ub_thelub by auto

lemma l402: "chain S \<Longrightarrow> S i \<noteq> \<up>8 \<Longrightarrow> \<forall>i. S i \<sqsubseteq> s \<Longrightarrow> (\<Squnion> j. S j) \<sqsubseteq> s"
by (simp add: lub_below)

lemma l403: "chain S \<Longrightarrow> \<forall>i. S i \<sqsubseteq> s \<Longrightarrow> \<forall>i. sdom\<cdot>(S i) \<subseteq> sdom\<cdot>s"
by (simp add: f1)

lemma l404: "chain S \<Longrightarrow>  \<forall>i. S i \<sqsubseteq> s \<Longrightarrow> sdom\<cdot>(\<Squnion> j. S j) \<subseteq> sdom\<cdot>s"
using f1 lub_below by blast

(* streams appearing later in the chain S contain the elements of preceding streams *)
lemma l405: "chain S \<Longrightarrow> i \<le> j \<Longrightarrow> sdom\<cdot>(S i) \<subseteq> sdom\<cdot>(S j)"
by (simp add: f1 po_class.chain_mono)

lemma l43: "chain S \<Longrightarrow> finite_chain S \<Longrightarrow> sdom\<cdot>(\<Squnion> j. S j) \<subseteq> (\<Union>i. sdom\<cdot>(S i))"
using l42 by fastforce


(*wichtig*)
(* the lub doesn't have any elements that don't appear somewhere in the chain *)
lemma sdom_lub: "chain S \<Longrightarrow> sdom\<cdot>(\<Squnion> j. S j) = (\<Union>i. sdom\<cdot>(S i))"
apply (simp add: contlub_cfun_arg)
by (simp add: lub_eq_Union)

text {*Sei i in N ein index der Kette S von Strmen und B eine Menge von Nachrichten. *}
lemma l44: assumes "chain S" and "\<forall>i. sdom\<cdot>(S i) \<subseteq> B"
  shows "sdom\<cdot>(\<Squnion> j. S j) \<subseteq> B"
by (metis (mono_tags, lifting) UN_E assms sdom_lub subsetCE subsetI)


lemma l6: "chain S \<Longrightarrow> \<forall>i. sdom\<cdot>(S i) \<subseteq> B \<Longrightarrow> sdom\<cdot>(\<Squnion> j. S (j + (SOME k. A))) \<subseteq> B"
by (simp add: l44 lub_range_shift)

(* dropping elements can't increase the domain *)
lemma sdrop_sdom[simp]: "sdom\<cdot>(sdrop n\<cdot>s)\<subseteq>sdom\<cdot>s"
by (metis Un_upper2 approxl2 f1 sdom_sconc2un sdrop_0 sdropostake split_streaml1 stream.take_below)


(* if none of the elements in the domain of the stream s are in the set A, then filtering s with A
   produces the empty stream *)
lemma sfilter_sdom_eps: "sdom\<cdot>s \<inter> A = {} \<Longrightarrow> (A \<ominus> s) = \<epsilon>"
by (meson disjoint_iff_not_equal ex_snth_in_sfilter_nempty snth2sdom)

lemma sdom_sfilter1: assumes "x\<in>sdom\<cdot>(A\<ominus>s)" 
shows "x\<in>A"
by (smt assms mem_Collect_eq sdom_def2 sfilterl7)

lemma sdom_subset: assumes "u\<noteq>\<bottom>"
shows "sdom\<cdot>s\<subseteq>sdom\<cdot>(u && s)"
by (metis Un_upper2 assms sdom2un stream.con_rews(2) stream.sel_rews(5) surj_scons)

lemma sdom_sfilter_subset: assumes "u\<noteq>\<bottom>"
shows "sdom\<cdot>(A\<ominus>s)\<subseteq>sdom\<cdot>(A \<ominus> (u && s))"
by (smt Un_upper2 assms eq_iff sdom2un sfilter_in sfilter_nin stream.con_rews(2) stream.sel_rews(5) surj_scons)

lemma sdom_sfilter2: assumes  "x\<in>A"
shows "x\<in>sdom\<cdot>s \<Longrightarrow> x\<in>(sdom\<cdot>(A \<ominus> s))"
apply(induction s)
apply(rule admI)
apply rule
apply (smt SUP_def UN_E ch2ch_Rep_cfunR contlub_cfun_arg contra_subsetD l4 set_cpo_simps(2))
apply simp
by (smt UnE assms empty_iff insert_iff sconc_sdom sdom2un sdom_sconc sdom_sfilter_subset sfilter_in stream.con_rews(2) stream.sel_rews(5) subsetCE surj_scons)

lemma sdom_sfilter[simp]: "sdom\<cdot>(A\<ominus>s) = sdom\<cdot>s \<inter> A"
apply rule
apply (meson IntI sbfilter_sbdom sdom_sfilter1 subset_iff)
apply rule
by (meson IntD1 IntD2 sdom_sfilter2)

lemma sfilterEq2sdom_h: "sfilter A\<cdot>s = s \<longrightarrow> sdom\<cdot>s \<subseteq> A"
  apply(rule ind [of _s])
    apply (smt admI inf.orderI sdom_sfilter)
   apply(simp)
  apply(rule)
  by (smt mem_Collect_eq sdom_def2 sfilterl7 subsetI)

lemma sfilterEq2sdom: "sfilter A\<cdot>s = s \<Longrightarrow> sdom\<cdot>s \<subseteq> A"
  by (simp add: sfilterEq2sdom_h)

lemma stwbl_id_help:
  shows "(\<forall>a\<in>sdom\<cdot>s. f a) \<longrightarrow> stwbl f\<cdot>s = s"
  apply (rule ind [of _s])
    apply(rule adm_imp)
     apply(rule admI, rule+)
     using l4 apply blast
    apply(rule admI)
    apply (metis cont2contlubE cont_Rep_cfun2 lub_eq)
   using strict_stwbl apply blast
  apply rule+
  by simp

lemma stwbl_id [simp]: "(\<And> a. a\<in>sdom\<cdot>s \<Longrightarrow> f a) \<Longrightarrow> stwbl f\<cdot>s = s"
by (simp add: stwbl_id_help)

lemma stwbl2stakewhile: assumes "a\<in>sdom\<cdot>s" and "\<not>f a"
  shows "\<exists>x. (stwbl f\<cdot>s) = stakewhile f\<cdot>s \<bullet> \<up>x" 
proof -
  have "#(stwbl f\<cdot>s) < \<infinity>" using assms(1) assms(2) snth2sdom stwbl_fin by blast
  hence "stwbl f\<cdot>s \<noteq> \<epsilon>" by (metis assms(1) assms(2) stakewhile_dom strict_stakewhile stwbl_notEps) 
  thus ?thesis
    by (smt Fin_02bot approxl2 assms(1) assms(2) bottomI lnle_def lnzero_def mem_Collect_eq sconc_snd_empty sdom_def2 sdrop_0 slen_empty_eq slen_rt_ile_eq split_streaml1 stakewhile_below stakewhile_noteq stakewhile_sdropwhilel1 stwbl_notEps stwbl_stakewhile surj_scons tdw ub_slen_stake) 
qed

lemma stwbl_sfoot: assumes "a\<in>sdom\<cdot>s" and "\<not>f a"
  shows "\<not> f (sfoot (stwbl f\<cdot>s))" 
proof(rule ccontr)
  assume "\<not> \<not> f (sfoot (stwbl f\<cdot>s))"
  hence "f (sfoot (stwbl f\<cdot>s))" by blast
  obtain x where x_def:"(stwbl f\<cdot>s) = stakewhile f\<cdot>s \<bullet> \<up>x"
    using assms(1) assms(2) stwbl2stakewhile by blast
  hence "sfoot (stwbl f\<cdot>s) = x"
    using assms(1) assms(2) sfoot1 stwbl_fin by blast
  have "stakewhile f\<cdot>s \<bullet> \<up>x \<sqsubseteq> s" by (metis stwbl_below x_def)
  have "f x"
    using \<open>f (sfoot (stwbl f\<cdot>s))\<close> \<open>sfoot (stwbl f\<cdot>s) = x\<close> by blast
  thus False
    by (smt Fin_02bot \<open>sfoot (stwbl f\<cdot>s) = x\<close> approxl2 assms(1) assms(2) assoc_sconc bottomI lnle_def lnzero_def sconc_fst_empty sconc_snd_empty sdrop_0 sdropwhile_t sfoot1 slen_empty_eq slen_rt_ile_eq split_streaml1 stakewhile_below stakewhile_dom stakewhile_sdropwhilel1 stakewhile_stwbl stream.take_strict strict_stakewhile stwbl_fin stwbl_notEps stwbl_stakewhile surj_scons tdw ub_slen_stake)
qed

lemma stwbl2stbl[simp]: "stwbl f\<cdot>(stwbl f\<cdot>s) = stwbl f\<cdot>s"
  apply(rule ind [of _s])
    apply simp_all
  by (metis sconc_snd_empty stwbl_f stwbl_t)

lemma adm_nsdom [simp]:  "adm (\<lambda>x. b \<notin> sdom\<cdot>x)"
proof (rule admI)
  fix Y
  assume as1: "chain Y" and as2: "\<forall>i. b\<notin>sdom\<cdot>(Y i)"
  thus "b\<notin>sdom\<cdot>(\<Squnion>i. Y i)"
  proof (cases "finite_chain Y")
    case True thus ?thesis using as1 as2 l42 by fastforce 
  next
    case False
    hence "#(\<Squnion>i. Y i) = \<infinity>" using as1 inf_chainl4 by blast
    hence "\<And>n. snth n (\<Squnion>i. Y i) \<noteq> b"
    proof -
      fix n
      obtain j where "Fin n < # (Y j)"  by (metis False Streams.inf_chainl2 as1 inf_chainl3rf less_le) 
      hence "snth n (Y j) \<noteq>b" using as2 snth2sdom by blast
      thus "snth n (\<Squnion>i. Y i) \<noteq> b" using \<open>Fin n < #(Y j)\<close> as1 is_ub_thelub snth_less by blast
    qed
    thus ?thesis using sdom2snth by blast 
  qed
qed

lemma strdw_filter_h: "b\<in>sdom\<cdot>s \<longrightarrow> lnsuc\<cdot>(#({b} \<ominus> srtdw (\<lambda>a. a \<noteq> b)\<cdot>s)) = #({b} \<ominus> s)"
proof(rule ind [of _s])
  have "adm (\<lambda>a. lnsuc\<cdot>(#({b} \<ominus> srtdw (\<lambda>a. a \<noteq> b)\<cdot>a)) = #({b} \<ominus> a))" by simp
  thus "adm (\<lambda>a. b \<in> sdom\<cdot>a \<longrightarrow> lnsuc\<cdot>(#({b} \<ominus> srtdw (\<lambda>a. a \<noteq> b)\<cdot>a)) = #({b} \<ominus> a))" by(simp add: adm_nsdom)
  show "b \<in> sdom\<cdot>\<epsilon> \<longrightarrow> lnsuc\<cdot>(#({b} \<ominus> srtdw (\<lambda>a. a \<noteq> b)\<cdot>\<epsilon>)) = #({b} \<ominus> \<epsilon>)" by simp
  fix a 
  fix s
  assume IH: " b \<in> sdom\<cdot>s \<longrightarrow> lnsuc\<cdot>(#({b} \<ominus> srtdw (\<lambda>a. a \<noteq> b)\<cdot>s)) = #({b} \<ominus> s)"
  show " b \<in> sdom\<cdot>(\<up>a \<bullet> s) \<longrightarrow> lnsuc\<cdot>(#({b} \<ominus> srtdw (\<lambda>a. a \<noteq> b)\<cdot>(\<up>a \<bullet> s))) = #({b} \<ominus> \<up>a \<bullet> s)"
  proof (cases "a=b")
    case True thus ?thesis by (simp add: sfilter_in singletonI slen_scons stwbl_f stwbl_srtdw) 
  next
    case False
    hence f1:"#({b} \<ominus> \<up>a \<bullet> s) = #({b} \<ominus> s)" using sfilter_nin singletonD by auto
    hence f2:"#({b} \<ominus> srtdw (\<lambda>a. a \<noteq> b)\<cdot>(\<up>a \<bullet> s)) = #({b} \<ominus> srtdw (\<lambda>a. a \<noteq> b)\<cdot>(s))" using False by auto
    hence "b \<in> sdom\<cdot>(\<up>a \<bullet> s) \<Longrightarrow> b\<in>sdom\<cdot>s" using False by auto
    thus ?thesis using IH f2 local.f1 by auto 
  qed
qed

lemma strdw_filter: "b\<in>sdom\<cdot>s \<Longrightarrow> lnsuc\<cdot>(#({b} \<ominus> srtdw (\<lambda>a. a \<noteq> b)\<cdot>s)) = #({b} \<ominus> s)"
by(simp add: strdw_filter_h)


lemma stwbl_filterlen[simp]: "b\<in>sdom\<cdot>ts \<longrightarrow> #({b} \<ominus> stwbl (\<lambda>a. a \<noteq> b)\<cdot>ts) = Fin 1"
  apply(rule ind [of _ ts])
    apply(rule adm_imp)
     apply simp
    apply simp
   apply simp
  apply auto
  by (metis (mono_tags, lifting) Fin_02bot Fin_Suc One_nat_def lnzero_def sconc_snd_empty sfilter_in sfilter_nin singletonD singletonI slen_scons strict_sfilter strict_slen stwbl_f stwbl_t)


lemma srtdw_conc: "b\<in>sdom\<cdot>ts  \<Longrightarrow> (srtdw (\<lambda>a. a \<noteq> b)\<cdot>(ts \<bullet> as)) = srtdw (\<lambda>a. a \<noteq> b)\<cdot>(ts) \<bullet> as"
  apply(induction ts arbitrary: as)
    apply (rule adm_imp)
     apply auto
   apply(rule admI)
   apply rule+
   apply (metis (no_types, lifting) approxl3 assoc_sconc is_ub_thelub)
proof -
  fix u ts as
  assume as1: "u \<noteq> \<bottom>" and as2: "(\<And>as. b \<in> sdom\<cdot>ts \<Longrightarrow> srtdw (\<lambda>a. a \<noteq> b)\<cdot>(ts \<bullet> as) = srtdw (\<lambda>a. a \<noteq> b)\<cdot>ts \<bullet> as)"
       and as3: "b \<in> sdom\<cdot>(u && ts)"
  obtain a where a_def: "updis a = u" by (metis Exh_Up as1 discr.exhaust) 
  have "a\<noteq>b \<Longrightarrow> b\<in>sdom\<cdot>ts" by (metis UnE a_def as3 lscons_conv sdom2un singletonD) 
  hence "a\<noteq>b \<Longrightarrow> srtdw (\<lambda>a. a \<noteq> b)\<cdot>(\<up>a\<bullet> (ts \<bullet> as)) = srtdw (\<lambda>a. a \<noteq> b)\<cdot>(\<up>a\<bullet> ts) \<bullet> as " using as2 a_def by auto
  thus "srtdw (\<lambda>a. a \<noteq> b)\<cdot>((u && ts) \<bullet> as) = srtdw (\<lambda>a. a \<noteq> b)\<cdot>(u && ts) \<bullet> as "
    by (smt a_def inject_scons lscons_conv sconc_scons stwbl_f stwbl_srtdw) 
qed


lemma stwbl_conc[simp]: "b\<in>sdom\<cdot>ts \<Longrightarrow>
    (stwbl (\<lambda>a. a \<noteq> b)\<cdot>(stwbl (\<lambda>a. a \<noteq> b)\<cdot>ts \<bullet> xs)) =
    (stwbl (\<lambda>a. a \<noteq> b)\<cdot>(ts))"
  apply(induction ts)
    apply(rule adm_imp)
     apply simp
    apply(rule admI)
    apply (metis (no_types, lifting) ch2ch_Rep_cfunR contlub_cfun_arg inf_chainl4 lub_eqI lub_finch2 sconc_fst_inf stwbl2stbl)
   apply simp
  by (smt UnE assoc_sconc sdom2un singletonD stream.con_rews(2) stream.sel_rews(5) stwbl_f stwbl_t surj_scons)


(* ----------------------------------------------------------------------- *)
section {* @{term siterateBlock} *}
(* ----------------------------------------------------------------------- *)

(* block-iterating the function f on the stream x is equivalent to the stream produced by concatenating x
   and the iteration of f on x shifted by another application of f *)
lemma siterateBlock_unfold: "siterateBlock f x = x \<bullet> siterateBlock f (f x)"
by(subst siterateBlock_def [THEN fix_eq2], auto)

(* if g doesn't change the length of the input, then iterating g doesn't either *)
lemma niterate_len[simp]: assumes "\<forall>z. #z = #(g z)" 
  shows "#((niterate i g) x) = #x"
using assms by(induction i, auto)

(* dropping i blocks from siterateBlock g x is equivalent to beginning siterateBlock after i iterations
   of g have already been applied *)
lemma siterateBlock_sdrop2: assumes "#x = Fin y" and "\<forall>z. #z = #(g z)" 
  shows "sdrop (y*i)\<cdot>(siterateBlock g x) = siterateBlock g ((niterate i g) x)"
apply (induction i, auto)
by (metis assms(1) assms(2) niterate_len sdrop_plus sdropl6 siterateBlock_unfold)

(* the y*i'th element of siterateBlock is the same as the head of the i'th iteration *)
lemma siterateBlock_snth: assumes "#x = Fin y" and "\<forall>z. #z = #(g z)" and "#x > Fin 0" 
  shows "snth (y*i) (siterateBlock g x) = shd ((niterate i g) x)"
proof -
  have eq1: "sdrop (y*i)\<cdot>(siterateBlock g x) = siterateBlock g ((niterate i g) x)" using assms(1) assms(2) siterateBlock_sdrop2 by blast 

  have "#((niterate i g) x) > 0" by (metis Fin_02bot assms(2) assms(3) lnzero_def niterate_len)  
  hence "shd (siterateBlock g ((niterate i g) x)) = shd (((niterate i g) x))" by (metis Fin_0 minimal monofun_cfun_arg sconc_snd_empty siterateBlock_unfold snth_less snth_shd)
  thus ?thesis by (simp add: eq1 snth_def) 
qed

(* dropping a single block from siterateBlock is equivalent to beginning the iteration with (g x) *)
lemma siterateBlock_sdrop: assumes "#x = Fin y"
  shows "sdrop y\<cdot>(siterateBlock g x) = siterateBlock g (g x)"
by (metis assms sdropl6 siterateBlock_unfold)

(* block-iterating the function g on the empty stream produces the empty stream again *)
lemma siterateBlock_eps[simp]: assumes "g \<epsilon> = \<epsilon>"
  shows "siterateBlock g \<epsilon> = \<epsilon>" 
by(simp add: siterateBlock_def assms)

(* block-iterating the identity on the element x is equivalent to infinitely repeating x *)
lemma siterateBlock2sinf: "siterateBlock id x = sinftimes x"
by (metis id_apply rek2sinftimes siterateBlock_eps siterateBlock_unfold strict_icycle)

(* siterateBlock doesn't affect infinite streams *)
lemma siterBlock_inf [simp]: assumes "#s = \<infinity>"
  shows "siterateBlock f s = s"
by (metis assms sconc_fst_inf siterateBlock_unfold)

(* the first element of siterateBlock doesn't have any applications of g *)
lemma siterateBlock_shd [simp]: "shd (siterateBlock g (\<up>x)) = x"
by (metis shd1 siterateBlock_unfold)

(* helper lemma for siterateBlock2siter *)
lemma siterateBlock2niter: "snth i (siterateBlock (\<lambda>s. (smap g\<cdot>s)) (\<up>x)) = niterate i g x" (is "snth i (?B) = ?N i")
proof -
  have f1: "#(\<up>x) = Fin 1" by simp
  have "\<forall>z. #z = #((\<lambda>s. (smap g\<cdot>s)) z)" by simp 
  hence f2: " snth (i) (siterateBlock (\<lambda>s. (smap g\<cdot>s)) (\<up>x)) = shd (niterate i (\<lambda>s. (smap g\<cdot>s)) (\<up>x))"
  by (metis Fin_0 Fin_Suc One_nat_def f1 lnat.con_rews lnless_def lnzero_def minimal nat_mult_1 siterateBlock_snth) 
  
  have "shd (niterate i (\<lambda>s. (smap g\<cdot>s)) (\<up>x)) = niterate i g x"
  proof (induction i)
    case 0 thus ?case by simp
  next
    case (Suc i) thus ?case
    by (smt Fin_0 f1 inject_scons neq0_conv niterate.simps(2) niterate_len slen_smap smap_scons strict_slen surj_scons zero_less_one) 
  qed
  thus ?thesis by (simp add: f2) 
qed

(* siterateBlock creates an infinitely long stream *)
lemma siterateBlock_len [simp]: "#(siterateBlock (\<lambda>s. (smap g\<cdot>s)) (\<up>x)) = \<infinity>"
apply (rule infI)
apply (rule allI)
apply (rule_tac x="x" in spec)
apply (induct_tac k, simp+)
apply (metis bot_is_0 lnat.con_rews siterateBlock_unfold slen_scons strict_slen)
by (metis Fin_Suc lnat.sel_rews(2) sconc_snd_empty siterateBlock_unfold slen_scons smap_scons strict_smap)

(* iterating the identity function commutes with any function f *)
lemma siterateBlock_smap: "siterateBlock id (smap f\<cdot>x) =  smap f\<cdot>(siterateBlock id x)"
by (simp add: siterateBlock2sinf smap2sinf)

(* converting x to a singleton stream and applying siterateBlock using smap g is equivalent to
   iterating using g directly on x *)
lemma siterateBlock2siter [simp]: "siterateBlock (\<lambda>s. (smap g\<cdot>s)) (\<up>x) = siterate g x" 
apply (rule sinf_snt2eq, auto)
by (simp add: siterateBlock2niter snth_siter) 


(* ----------------------------------------------------------------------- *)
subsection {* @{term sislivespf} *}
(* ----------------------------------------------------------------------- *)

text {* Some different formulations and implications of the @{term sislivespf} definition *}

lemma sislivespfI:
  "(\<And>x. #(f\<cdot>x) = \<infinity> \<Longrightarrow> #x = \<infinity>) \<Longrightarrow> sislivespf f"
by (simp add: sislivespf_def)

lemma sislivespfI2:
  "(\<And>k. \<forall>x. #x = Fin k \<longrightarrow> #(f\<cdot>x) \<noteq> \<infinity>) \<Longrightarrow> sislivespf f"
apply (rule sislivespfI)
by (rule_tac x="#x" in lncases, simp+)

lemma sislivespfD1:
  "\<lbrakk>sislivespf f; #x = Fin k\<rbrakk> \<Longrightarrow> #(f\<cdot>x) \<noteq> \<infinity>"
apply (rule notI)
by (simp add: sislivespf_def)

lemma sislivespfD2:
  "\<lbrakk>sislivespf f; #(f\<cdot>x) = \<infinity>\<rbrakk> \<Longrightarrow> #x = \<infinity>"
by (simp add: sislivespf_def)

(* ----------------------------------------------------------------------- *)
section {* Lemmas on lists and streams *}
(* ----------------------------------------------------------------------- *)

(* ----------------------------------------------------------------------- *)
subsection {* @{term list2s} *}
(* ----------------------------------------------------------------------- *)

(* consing onto a list is equivalent to prepending an element to a stream *)
lemma [simp]: "list2s (a#as) = \<up>a \<bullet> list2s as"
by (simp add: lscons_conv)

declare list2s_Suc [simp del]

(* infinite lists don't exist *)
lemma [simp]: "#(list2s x) \<noteq> \<infinity>"
by (induct x, simp+)

text {* Every finite stream can be converted to a list *}
lemma s2list_ex: 
  "#s = Fin k \<Longrightarrow> \<exists>l. list2s l = s"
apply (simp add: atomize_imp)
apply (rule_tac x="s" in spec)
apply (induct_tac k, simp+)
apply (rule_tac x="[]" in exI, simp+)
apply (rule allI, rule impI)
apply (rule_tac x="x" in scases, simp+)
apply (erule_tac x="s" in allE)
apply (drule mp)
apply (simp add: Fin_Suc [THEN sym] del: Fin_Suc)
apply (erule exE)
by (rule_tac x="a # l" in exI, simp)

(* the empty stream corresponds to the empty list *)
lemma [simp]: "s2list \<epsilon> = []"
apply (simp add: s2list_def)
apply (rule someI2_ex)
apply (rule_tac x="[]" in exI, simp)
apply (simp add: atomize_imp)
by (induct_tac x, simp+)

(* the singleton stream corresponds to the singleton list *)
lemma [simp]: "s2list (\<up>a) = [a]"
apply (simp add: s2list_def)
apply (rule someI2_ex)
apply (rule_tac x="[a]" in exI, simp)
apply (simp add: atomize_imp)
apply (induct_tac x, auto)
by (case_tac "list", simp+)

(* the empty list is the bottom element for lists *)
lemma [simp]: "[] \<sqsubseteq> l"
by (simp add: sq_le_list)

text {* The prefix relation translates from lists to streams *}
lemma list2s_emb: "\<lbrakk>#s \<noteq> \<infinity>; #s' \<noteq> \<infinity>\<rbrakk> \<Longrightarrow> (s2list s \<sqsubseteq> s2list s') = (s \<sqsubseteq> s')"
apply (simp add: s2list_def)
apply (rule someI2_ex)
apply (rule_tac x="#s'" in lncases, simp) 
apply (frule s2list_ex, simp)
apply (rule someI2_ex)
apply (rule_tac x="#s" in lncases, simp) 
apply (frule s2list_ex, simp)
apply (rule iffI)
apply (drule sym, drule sym, simp)
apply (simp add: sq_le_list)
by (simp add: sq_le_list)

text {* @{term list2s} is monotone *}
lemma list2s_mono: "l \<sqsubseteq> l' \<Longrightarrow> list2s l \<sqsubseteq> list2s l'"
by (simp add: sq_le_list)

text {* Prepending a fixed element to a list is a monotone function *}
lemma monofun_lcons: "monofun (\<lambda>l. a # l)"
apply (rule monofunI)
apply (simp add: atomize_imp)
apply (rule_tac x="a" in spec)
apply (induct_tac x, simp+)
apply (rule allI)
apply (simp add: sq_le_list)
apply (rule allI)
apply (rule impI)
apply (simp add: sq_le_list)
by (rule monofun_cfun_arg, simp)

text {* Head and rest on streams translate to head and rest on lists *}
lemma s2list2lcons: "#s \<noteq> \<infinity> \<Longrightarrow> s2list (\<up>a \<bullet> s) = a # (s2list s)"
apply (rule_tac x="#s" in lncases, simp+)
apply (simp add: atomize_imp)
apply (rule_tac x="s" in spec)
apply (rule_tac x="a" in spec)
apply (induct_tac k, simp+)
apply (rule allI,rule allI, rule impI)
apply (rule_tac x="xa" in scases, simp+)
apply (simp add: s2list_def)
apply (rule someI2_ex)
apply (frule s2list_ex, simp)
apply (rule someI2_ex)
apply (frule s2list_ex)
apply (erule exE)
apply (rule_tac x="x#a#l" in exI, simp+)
by (rule list2s_inj [THEN iffD1], simp)

text {* @{term s2list} is left-inverse to @{term list2s} *}
lemma [simp]: "s2list (list2s l) = l"
apply (induct_tac l, simp+)
by (subst s2list2lcons, simp+)

text {* Evaluation of @{term list2s} from right to left *}
lemma slistl5[simp]: "list2s (l @ [m]) = list2s l \<bullet> \<up>m"
by (induct_tac l, simp+)

(* ----------------------------------------------------------------------- *)
subsection {* List- and stream-processing functions *}
(* ----------------------------------------------------------------------- *)

(* concatenating streams corresponds to concatenating lists *)
lemma listConcat: "<l1> \<bullet> <l2> = <(l1 @ l2)>"
apply(induction l1)
by auto

(* smap for streams is equivalent to map for lists *)
lemma smap2map: "smap g\<cdot>(<ls>) = <(map g ls)>"
apply(induction ls)
by auto



(* the notion of length is the same for streams as for lists *)
lemma list2streamFin: "#(<ls>) = Fin (length ls)"
apply(induction ls)
by auto

text {* Monotone list-processing functions induce monotone stream-processing functions
  by applying them to the stream's k-element prefix *}
lemma mono_slpf2spf:
  "monofun f \<Longrightarrow> monofun (\<lambda>s. list2s (f (s2list (stake k\<cdot>s))))"
apply (rule monofunI)
apply (simp add: atomize_imp)
apply (rule_tac x="y" in spec)
apply (rule_tac x="x" in spec)
apply (induct_tac k, simp+)
apply (rule impI)
apply (drule mp, assumption)
apply (rule allI)+
apply (rule impI)
apply (drule lessD, simp)
apply (erule disjE, simp)
apply (rule list2s_mono)
apply (rule_tac f="f" in monofunE,simp+)
apply (erule exE)+
apply (erule conjE)
apply (erule exE,simp)
apply (erule conjE)
apply (rule list2s_mono)
apply (rule_tac f="f" in monofunE,simp+)
apply (rule_tac x="xa" in scases,simp)
apply (subst list2s_emb,simp+)
apply (rule monofun_cfun_arg)+
by simp

text {* Applying a monotone list-processing function to the @{term k}-element prefix of a stream
  is monotone with respect to @{term k} *}
lemma chain_slpf2spf:
  "monofun f \<Longrightarrow> list2s (f (s2list (stake i\<cdot>x))) \<sqsubseteq> list2s (f (s2list (stake (Suc i)\<cdot>x)))"
apply (rule list2s_mono)
apply (rule_tac f="f" in monofunE,simp+)
apply (subst list2s_emb,simp+)
by (rule chainE, simp)

text {* Now, a list-processing function is converted to a stream-processing one by building
  the LUB of applying the function to all prefixes of the stream *}
lemma slpf2spfl_contl:
  "monofun f \<Longrightarrow> 
  cont (\<lambda>s. (\<Squnion>k. list2s (f (s2list (stake k\<cdot>s)))))"
apply (rule cont2cont_lub)
apply (rule chainI)
apply (rule chain_slpf2spf, simp)
apply (rule pr_contI) 
apply (rule mono_slpf2spf, assumption) 
apply (rule allI)
by (rule_tac x="k" in exI, simp)

text {* The output function of @{term slpf2spf} is continuous *}
lemma slpf2spf_cont:
  "monofun f \<Longrightarrow> 
     (\<Lambda> s. (\<Squnion>k. list2s (f (s2list (stake k\<cdot>s)))))\<cdot>s = (\<Squnion>k. list2s (f (s2list (stake k\<cdot>s))))"
apply (subst beta_cfun)
by (rule slpf2spfl_contl, assumption, simp)

text {* Applying @{term "slpf2spf f"} to an element @{term x} *}
lemma slpf2spf_def2:
  "monofun f \<Longrightarrow> slpf2spf f\<cdot>x = (\<Squnion>k. list2s (f (s2list (stake k\<cdot>x))))"
apply (simp add: slpf2spf_def)
by (rule slpf2spf_cont)

text {* The output of @{term slpf2spf} is live *}
lemma sislivespf_slpf2spf:
  "monofun f \<Longrightarrow> sislivespf (slpf2spf f)"
apply (rule sislivespfI)
apply (rule_tac x="#x" in lncases, assumption)
apply (simp add: slpf2spf_def2)
apply (subgoal_tac 
  "finite_chain (\<lambda>k. list2s (f (s2list (stake k\<cdot>x))))")
apply (simp add: finite_chain_def)
apply (erule conjE, erule exE)
apply (frule lub_finch1, simp+)
apply (frule lub_eqI, simp)
apply (simp add: finite_chain_def, rule conjI)
apply (rule chainI)
apply (rule chain_slpf2spf, assumption)
apply (rule_tac x="k" in exI)
apply (simp add: max_in_chain_def)
apply (rule allI, rule impI)
apply (subgoal_tac "stake j\<cdot>x = stake k\<cdot>x", simp)
apply (subst fin2stake [THEN sym], simp+)
by (simp add: min_def)

text {* Any live stream-processing function can be converted to a monotone
  list-processing function *}
lemma sspf2lpf_mono: 
  "sislivespf f \<Longrightarrow> monofun (sspf2lpf f)"
apply (rule monofunI)
apply (simp add: sspf2lpf_def)
apply (subst list2s_emb)
apply (rule notI, frule sislivespfD2, simp+)+
apply (rule monofun_cfun_arg)
by (simp add: sq_le_list)

text {* The result of applying continuous functions to infinite inputs
  does not change on even longer inputs *}
lemma monofun_spf_ubl[simp]:
  "#(f\<cdot>x) = \<infinity> \<Longrightarrow> f\<cdot>(x \<bullet> y) = f\<cdot>x"
apply (rule sym)
apply (rule eq_less_and_fst_inf [of "f\<cdot>x"])
by (rule monofun_cfun_arg, auto)

text {* Some special results about @{term smap} and injective functions
  on streams of natural successors *}

lemma inj_sfilter_smap_siteratel1:
  "inj f \<Longrightarrow> sfilter {f j}\<cdot>(smap f\<cdot>(siterate Suc (Suc (k + j)))) = \<epsilon>"
apply (rule ex_snth_in_sfilter_nempty [rule_format])
apply (simp add: atomize_imp)
apply (rule impI)
apply (subst smap_snth_lemma, simp+)
apply (simp add: snth_siterate_Suc)
apply (rule notI)
by (frule_tac x="Suc (n+(k+j))" and y="j" in injD, simp+)

(* an element m can't appear infinitely often in a stream produced by mapping an injective function f
   over the natural numbers *)
lemma inj_sfilter_smap_siteratel2[simp]:
  "inj f \<Longrightarrow> #(sfilter {m}\<cdot>(smap f\<cdot>(siterate Suc j))) \<noteq> \<infinity>"
apply (case_tac "m\<in>range f")
apply (rule_tac b="m" and f="f" in rangeE, simp+)
apply (rule notI)
apply (drule_tac n="Suc x" in slen_sfilter_sdrop [rule_format], simp)
apply (simp add: sdrop_siterate)
apply (simp add: inj_sfilter_smap_siteratel1)
by (simp add: sfilter_smap_nrange)




(* ----------------------------------------------------------------------- *)
subsection {* compact lemmas *}
(* ----------------------------------------------------------------------- *)


lemma finChainapprox: assumes "chain Y" and "# (\<Squnion>i. Y i) =Fin  k" 
  shows "\<exists>i. Y i = (\<Squnion>i. Y i)"
  using assms(1) assms(2) inf_chainl4 lub_eqI lub_finch2 by fastforce

lemma finCompact: assumes "#s = Fin k"
  shows "compact s"
  proof (rule compactI2)
  fix Y assume as1: "chain Y" and as2: "s \<sqsubseteq> (\<Squnion>i. Y i)"
  show "\<exists>i. s \<sqsubseteq> Y i" by (metis approxl2 as1 as2 assms finChainapprox lub_approx stream.take_below)
qed

lemma "compact \<epsilon>"
  by simp

lemma "compact (\<up>x)"
  by (simp add: sup'_def)

(* nicht so compactes Zeug *)
lemma nCompact: assumes "chain Y" and "\<forall>i. (Y i \<sqsubseteq> x)" and "\<forall>i.  (Y i \<noteq> x)" and "x \<sqsubseteq> (\<Squnion>i. Y i)"
  shows "\<not>(compact x)"
  by (meson assms below_antisym compactD2)

lemma infNCompact: assumes "#s = \<infinity>"
  shows"\<not> (compact s)"
  proof (rule nCompact)
     show "chain (\<lambda>i. stake i\<cdot>s)" by simp
    show "\<forall>i. stake i\<cdot>s \<sqsubseteq> s" by simp
   show "\<forall>i. stake i\<cdot>s \<noteq> s" by (metis Inf'_neq_0 assms fair_sdrop sdropostake strict_slen)
  show "s \<sqsubseteq> (\<Squnion> i. stake i\<cdot>s)" by (simp add: reach_stream)
qed

lemma "\<not> (compact (sinftimes (\<up>x)))"
  by (simp add: infNCompact slen_sinftimes)

(* add function *)

definition add:: "nat stream \<rightarrow> nat stream \<rightarrow> nat stream" where
"add \<equiv> \<Lambda> s1 s2 . smap (\<lambda> s3. (fst s3) + (snd s3))\<cdot>(szip\<cdot>s1\<cdot>s2)"

lemma "cont (\<lambda> s1 s2 . smap (\<lambda> s3. (fst s3) + (snd s3))\<cdot>(szip\<cdot>s1\<cdot>s2))"
by simp

lemma "add = merge plus"
by(simp add: add_def merge_def)

lemma add_unfold: "add\<cdot>(\<up>x \<bullet> xs)\<cdot>(\<up>y\<bullet> ys) = \<up>(x+y) \<bullet> add\<cdot>xs\<cdot>ys"
  by(simp add: add_def)

lemma add_snth: "Fin n <#xs \<Longrightarrow>Fin n < #ys \<Longrightarrow> snth n (add\<cdot>xs\<cdot>ys) = snth n xs + snth n ys"
  apply(induction n arbitrary: xs ys)
   apply (metis Fin_02bot add_unfold lnless_def lnzero_def shd1 slen_empty_eq snth_shd surj_scons)
  by (smt Fin_Suc Fin_leq_Suc_leq Suc_eq_plus1_left add_unfold inject_lnsuc less2eq less2lnleD lnle_conv lnless_def lnsuc_lnle_emb sconc_snd_empty sdropostake shd1 slen_scons snth_rt snth_scons split_streaml1 stream.take_strict surj_scons ub_slen_stake)

lemma add_eps1[simp]: "add\<cdot>\<epsilon>\<cdot>ys = \<epsilon>"
  by(simp add: add_def)

lemma add_eps2[simp]: "add\<cdot>xs\<cdot>\<epsilon> = \<epsilon>"
  by(simp add: add_def)

lemma [simp]: "srt\<cdot>(add\<cdot>(\<up>a \<bullet> as)\<cdot>(\<up>b \<bullet> bs)) = add\<cdot>as\<cdot>bs"
  by (simp add: add_unfold)

lemma add_commu_helper: assumes "\<And>y. add\<cdot>x\<cdot>y = add\<cdot>y\<cdot>x"
  shows "add\<cdot>(\<up>a \<bullet> x)\<cdot>y = add\<cdot>y\<cdot>(\<up>a \<bullet> x)"
  apply(cases "y = \<epsilon>")
   apply auto[1]
  by (metis (no_types, lifting) Groups.add_ac(2) assms add_unfold surj_scons)

lemma add_commutative: "add\<cdot>x\<cdot>y = add\<cdot>y\<cdot>x"
  apply(induction x arbitrary: y)
    apply(simp_all)
  by (metis add_commu_helper stream.con_rews(2) stream.sel_rews(5) surj_scons)

lemma add_len: assumes "xs\<noteq>\<bottom>" and "u\<noteq>\<bottom>"
  shows "#(add\<cdot>xs\<cdot>(u && ys)) = lnsuc\<cdot>(#(add\<cdot>(srt\<cdot>xs)\<cdot>ys))"
  by (metis (no_types, lifting) add_unfold assms(1) assms(2) slen_scons stream.con_rews(2) stream.sel_rews(5) surj_scons)

lemma add_slen_help [simp]: "#xs \<sqsubseteq> #ys \<Longrightarrow> #(add\<cdot>xs\<cdot>ys) = #xs"
  apply(induction xs arbitrary: ys)
    apply(rule admI)
    apply rule+
    apply (smt ch2ch_Rep_cfunL ch2ch_Rep_cfunR contlub_cfun_arg contlub_cfun_fun lub_below_iff lub_eq)
   apply(simp)
  proof -
  fix u
  fix xs ys :: "nat stream"
  assume as1: "u \<noteq> \<bottom>" and as2: "(\<And>ys. #xs \<sqsubseteq> #ys \<Longrightarrow> #(add\<cdot>xs\<cdot>ys) = #xs)" and as3: " #(u && xs) \<sqsubseteq> #ys"
  obtain a where a_def: "updis a = u" by (metis as1 discr.exhaust upE)
  show "#(add\<cdot>(u && xs)\<cdot>ys) = #(u && xs)"
  proof (cases "ys = \<epsilon>")
   case True thus ?thesis using add_eps2 as3 bot_is_0 bottomI strict_slen by auto
  next
  case False
  hence "#(add\<cdot>xs\<cdot>(srt\<cdot>ys)) = #xs" by (metis a_def as2 as3 lnat.inverts lscons_conv slen_scons surj_scons)
  thus ?thesis by (metis False \<open>updis a = u\<close> add_unfold lscons_conv slen_scons surj_scons)
  qed
qed

lemma add_slen [simp]: "#(add\<cdot>x\<cdot>y) = min (#x) (#y)"
  apply(cases "#x\<le>#y")
   apply (metis add_slen_help lnle_def min.commute min_absorb2)
  by (metis add_commutative add_slen_help linear lnle_def min.absorb2)

lemma add_slen_sinf [simp]: 
  shows " #xs = \<infinity> \<Longrightarrow> #(add\<cdot>xs\<cdot>ys) =(#ys)"
  by (simp add: min.absorb2)

lemma snth_add: "Fin n < #ys \<Longrightarrow> snth n (add\<cdot>\<up>x\<infinity>\<cdot>ys) = snth n (smap (\<lambda>z. z + x)\<cdot>ys)"
  apply(induction n arbitrary: ys)
   apply (smt Fin_02bot add.commute add_unfold lnless_def lnzero_def shd1 sinftimes_unfold slen_empty_eq smap_snth_lemma snth_shd surj_scons)
  by (smt Fin_Suc add_slen_sinf add_unfold lnle_conv lnless_def lnsuc_lnle_emb sinftimes_unfold slen_empty_eq slen_scons slen_sinftimes slen_smap smap_snth_lemma snth_scons strict_icycle surj_scons)

lemma add2smap: "add\<cdot>(\<up>x\<infinity>)\<cdot>ys = smap (\<lambda>z. z+x)\<cdot>ys"
  apply(rule snths_eq)
   apply auto[1]
  by (metis add_slen_sinf lnat.con_rews lnzero_def lscons_conv slen_empty_eq slen_scons slen_sinftimes snth_add sup'_def)


end

